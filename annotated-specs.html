<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>EIP-7928 Annotated Specification</title>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github-dark.min.css">
  <style>
    :root {
      --bg: #0d1117;
      --bg-secondary: #161b22;
      --bg-tertiary: #21262d;
      --text: #e6edf3;
      --text-muted: #8b949e;
      --accent: #58a6ff;
      --accent-muted: #388bfd;
      --border: #30363d;
      --code-bg: #161b22;
    }
    
    * { box-sizing: border-box; margin: 0; padding: 0; }
    
    html { scroll-behavior: smooth; }
    
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Helvetica, Arial, sans-serif;
      background: var(--bg);
      color: var(--text);
      line-height: 1.6;
      font-size: 15px;
    }
    
    /* Layout */
    .container {
      min-height: 100vh;
    }
    
    /* Sidebar */
    nav {
      position: fixed;
      top: 0;
      left: 0;
      width: 260px;
      height: 100vh;
      background: var(--bg-secondary);
      border-right: 1px solid var(--border);
      overflow-y: auto;
      padding: 24px 0;
    }
    
    .nav-header {
      padding: 0 20px 20px;
      border-bottom: 1px solid var(--border);
      margin-bottom: 16px;
    }
    
    .nav-header h1 {
      font-size: 16px;
      font-weight: 600;
      color: var(--text);
      margin-bottom: 4px;
    }
    
    .nav-header .subtitle {
      font-size: 12px;
      color: var(--text-muted);
    }
    
    .nav-item {
      display: block;
      padding: 8px 20px;
      color: var(--text-muted);
      text-decoration: none;
      font-size: 13px;
      transition: all 0.15s;
      border-left: 2px solid transparent;
    }
    
    .nav-item:hover {
      color: var(--text);
      background: var(--bg-tertiary);
    }
    
    .nav-item.active {
      color: var(--accent);
      border-left-color: var(--accent);
      background: rgba(88, 166, 255, 0.1);
    }
    
    /* Main content */
    main {
      margin-left: 260px;
      padding: 48px 64px;
      max-width: 1100px;
    }
    
    .ai-notice {
      font-size: 12px;
      color: var(--text-muted);
      padding: 8px 12px;
      background: var(--bg-secondary);
      border-radius: 6px;
      margin-bottom: 16px;
      border: 1px solid var(--border);
    }
    
    .intro {
      margin-bottom: 48px;
      padding-bottom: 32px;
      border-bottom: 1px solid var(--border);
    }
    
    .intro p {
      margin-bottom: 8px;
    }
    
    .intro .links {
      font-size: 14px;
      color: var(--text-muted);
    }
    
    .intro .links span {
      margin: 0 8px;
      opacity: 0.5;
    }
    
    section {
      margin-bottom: 64px;
      padding-bottom: 64px;
      border-bottom: 1px solid var(--border);
    }
    
    section:last-child {
      border-bottom: none;
    }
    
    /* Typography */
    h1 {
      font-size: 28px;
      font-weight: 600;
      margin-bottom: 16px;
      padding-bottom: 12px;
      border-bottom: 1px solid var(--border);
    }
    
    h2 {
      font-size: 20px;
      font-weight: 600;
      margin: 32px 0 16px;
      color: var(--text);
    }
    
    h3 {
      font-size: 16px;
      font-weight: 600;
      margin: 24px 0 12px;
      color: var(--text);
    }
    
    h4 {
      font-size: 14px;
      font-weight: 600;
      margin: 20px 0 8px;
      color: var(--text-muted);
    }
    
    p {
      margin-bottom: 16px;
      color: var(--text);
    }
    
    a {
      color: var(--accent);
      text-decoration: none;
    }
    
    a:hover {
      text-decoration: underline;
    }
    
    strong {
      font-weight: 600;
      color: var(--text);
    }
    
    em {
      font-style: italic;
    }
    
    /* Code */
    code {
      font-family: 'SF Mono', Monaco, 'Cascadia Code', monospace;
      font-size: 13px;
      background: var(--code-bg);
      padding: 2px 6px;
      border-radius: 4px;
      color: #ff7b72;
    }
    
    pre {
      background: var(--code-bg);
      border: 1px solid var(--border);
      border-radius: 8px;
      padding: 16px;
      overflow-x: auto;
      margin: 16px 0;
    }
    
    pre code {
      background: none;
      padding: 0;
      color: var(--text);
      font-size: 13px;
      line-height: 1.5;
    }
    
    /* Tables */
    table {
      width: 100%;
      border-collapse: collapse;
      margin: 16px 0;
      font-size: 14px;
    }
    
    th, td {
      text-align: left;
      padding: 10px 12px;
      border: 1px solid var(--border);
    }
    
    th {
      background: var(--bg-secondary);
      font-weight: 600;
      color: var(--text);
    }
    
    td {
      background: var(--bg);
    }
    
    tr:hover td {
      background: var(--bg-secondary);
    }
    
    /* Lists */
    ul, ol {
      margin: 16px 0;
      padding-left: 24px;
    }
    
    li {
      margin-bottom: 8px;
    }
    
    li::marker {
      color: var(--text-muted);
    }
    
    /* Horizontal rule */
    hr {
      border: none;
      border-top: 1px solid var(--border);
      margin: 32px 0;
    }
    
    /* Scrollbar */
    ::-webkit-scrollbar {
      width: 8px;
      height: 8px;
    }
    
    ::-webkit-scrollbar-track {
      background: var(--bg);
    }
    
    ::-webkit-scrollbar-thumb {
      background: var(--border);
      border-radius: 4px;
    }
    
    ::-webkit-scrollbar-thumb:hover {
      background: var(--text-muted);
    }
    
    /* Responsive */
    @media (max-width: 900px) {
      nav {
        position: sticky;
        top: 0;
        z-index: 100;
        width: 100%;
        height: auto;
        max-height: 50vh;
        padding: 12px;
        border-right: none;
        border-bottom: 1px solid var(--border);
        overflow-y: auto;
      }
      
      .nav-header {
        padding: 0 8px 12px;
        margin-bottom: 12px;
      }
      
      .nav-item {
        display: inline-block;
        padding: 6px 10px;
        border-left: none;
        border-radius: 4px;
        margin: 2px;
        font-size: 12px;
      }
      
      main {
        margin-left: 0;
        padding: 20px 16px;
      }
      
      h1 { font-size: 22px; }
      h2 { font-size: 18px; }
      h3 { font-size: 15px; }
      
      pre {
        padding: 12px;
        font-size: 12px;
        margin: 12px -16px;
        border-radius: 0;
        border-left: none;
        border-right: none;
      }
      
      code { font-size: 12px; }
      
      table {
        display: block;
        overflow-x: auto;
        white-space: nowrap;
        font-size: 13px;
      }
      
      th, td {
        padding: 8px 10px;
      }
      
      .ai-notice {
        font-size: 11px;
        padding: 6px 10px;
      }
      
      .intro {
        margin-bottom: 32px;
        padding-bottom: 24px;
      }
      
      .intro .links {
        font-size: 13px;
      }
      
      section {
        margin-bottom: 48px;
        padding-bottom: 48px;
      }
    }
    
    @media (max-width: 480px) {
      main {
        padding: 16px 12px;
      }
      
      h1 { font-size: 20px; }
      h2 { font-size: 16px; margin: 24px 0 12px; }
      h3 { font-size: 14px; }
      
      body { font-size: 14px; }
      
      pre {
        padding: 10px;
        font-size: 11px;
      }
      
      .nav-item {
        padding: 5px 8px;
        font-size: 11px;
      }
      
      ul, ol {
        padding-left: 18px;
      }
    }
  </style>
</head>
<body>
  <div class="container">
    <nav>
      <div class="nav-header">
        <h1>EIP-7928</h1>
        <div class="subtitle">Block-Level Access Lists</div>
      </div>
      <a href="#section-01-rlp-types" class="nav-item">RLP Types</a>
<a href="#section-02-rlp-utilities" class="nav-item">RLP Utilities</a>
<a href="#section-03-state-tracker---data-structures" class="nav-item">State Tracker - Data Structures</a>
<a href="#section-04-state-tracker---recording-logic" class="nav-item">State Tracker - Recording Logic</a>
<a href="#section-05-state-tracker---frame-management" class="nav-item">State Tracker - Frame Management</a>
<a href="#section-06-bal-builder---construction" class="nav-item">BAL Builder - Construction</a>
<a href="#section-07-bal-builder---finalization" class="nav-item">BAL Builder - Finalization</a>
<a href="#section-08-block-processing" class="nav-item">Block Processing</a>
<a href="#section-09-vm-integration" class="nav-item">VM Integration</a>
<a href="#section-10-fork-definition" class="nav-item">Fork Definition</a>
<a href="#section-11-engine-api" class="nav-item">Engine API</a>
<a href="#section-12-consensus-layer" class="nav-item">Consensus Layer</a>
<a href="#section-13-networking-and-synchronization" class="nav-item">Networking and Synchronization</a>
<a href="#section-14-eip-overview" class="nav-item">EIP Overview</a>
    </nav>
    <main>
      <div class="ai-notice">This specification was annotated with AI assistance.</div>
      
      <div class="intro">
        <p>Annotated specification for <a href="https://eips.ethereum.org/EIPS/eip-7928">EIP-7928</a>: Block-Level Access Lists.</p>
        <p class="links">
          <a href="https://ethresear.ch/t/block-level-access-lists-bals/22331">Research post</a>
          <span>·</span>
          <a href="https://ethereum-magicians.org/t/eip-7928-block-level-access-lists/23337">EthMagicians discussion</a>
          <span>·</span>
          <a href="https://github.com/ethereum/execution-specs">EELS source</a>
        </p>
      </div>
      <section id="section-01-rlp-types">
<h1>Section 01: RLP Types</h1>

<h2>Source Files</h2>
<ul><li><code>specs/execution-specs/src/ethereum/forks/amsterdam/block_access_lists/rlp_types.py</code> (121 lines)</li>
</ul>
<h2>Overview</h2>

<p>This file defines the canonical RLP data structures for Block-Level Access Lists. Every BAL transmitted over the network or validated during block processing uses these exact types. The file is 121 lines—small but foundational.</p>

<hr>

<h2>Module Docstring (lines 1-8)</h2>

<pre><code class="language-python">&quot;&quot;&quot;
Defines the RLP data structures for Block-Level Access Lists
as specified in EIP-7928. These structures enable efficient encoding and
decoding of all accounts and storage locations accessed during block execution.

The encoding follows the pattern:
address -&gt; field -&gt; block_access_index -&gt; change.
&quot;&quot;&quot;</code></pre>

<strong>Key insight</strong>: The "address → field → block_access_index → change" pattern describes the nesting hierarchy:
<ul><li>Top level: list of accounts (by address)</li>
<li>Per account: grouped by field type (storage, balance, nonce, code)</li>
<li>Per field: ordered by block_access_index</li>
<li>Leaf: the actual change value</li>
</ul>
This hierarchical grouping enables:
<ul><li>Efficient compression (addresses deduplicated)</li>
<li>Parallel prefetching (all slots for an address together)</li>
<li>Clear change attribution (which tx caused what)</li>
</ul>
<hr>

<h2>Imports (lines 9-15)</h2>

<pre><code class="language-python">from dataclasses import dataclass
from typing import List, Tuple

from ethereum_types.bytes import Bytes, Bytes20
from ethereum_types.frozen import slotted_freezable
from ethereum_types.numeric import U64, U256, Uint</code></pre>

<strong><code>slotted_freezable</code></strong>: A decorator that makes dataclasses both:
<ul><li><strong>Slotted</strong>: Uses <code>__slots__</code> for memory efficiency (no <code>__dict__</code>)</li>
<li><strong>Freezable</strong>: Instances are immutable after creation</li>
</ul>
This matters because BAL structures are created once during block execution and then serialized. Immutability prevents accidental modification; slots reduce memory overhead when processing blocks with thousands of accounts.

<hr>

<h2>Type Aliases (lines 17-23)</h2>

<pre><code class="language-python"># Type aliases for clarity (matching EIP-7928 specification)
Address = Bytes20
StorageKey = U256
StorageValue = U256
CodeData = Bytes
BlockAccessIndex = Uint  # uint16 in the spec, but using Uint for compatibility
Balance = U256  # Post-transaction balance in wei
Nonce = U64</code></pre>

<h3>Why these specific types?</h3>

<table><tr><th>Alias</th><th>Underlying</th><th>Reason</th></tr>
<tr><td><code>Address</code></td><td><code>Bytes20</code></td><td>Ethereum addresses are exactly 20 bytes</td></tr>
<tr><td><code>StorageKey</code></td><td><code>U256</code></td><td>Storage slots are 256-bit keys</td></tr>
<tr><td><code>StorageValue</code></td><td><code>U256</code></td><td>Storage values are 256-bit</td></tr>
<tr><td><code>CodeData</code></td><td><code>Bytes</code></td><td>Contract bytecode is variable-length</td></tr>
<tr><td><code>BlockAccessIndex</code></td><td><code>Uint</code></td><td>See below</td></tr>
<tr><td><code>Balance</code></td><td><code>U256</code></td><td>Wei balances can exceed 2^64</td></tr>
<tr><td><code>Nonce</code></td><td><code>U64</code></td><td>EIP-2681 limits nonces to 64 bits</td></tr></table>
<h3>BlockAccessIndex: uint16 vs Uint</h3>

<p>The comment is important: <pre><code class="language-python">BlockAccessIndex = Uint  # uint16 in the spec, but using Uint for compatibility</code></pre></p>

<strong>EIP-7928 specifies uint16</strong> (max 65,535), but EELS uses <code>Uint</code> (arbitrary precision) for Python compatibility. The constraint is enforced elsewhere via <code>MAX_TXS</code>:

<pre><code class="language-python"># Constants chosen to support a 630m block gas limit
MAX_TXS = 30_000</code></pre>

<p>At 630M gas with ~21,000 gas per simple transfer, you get ~30,000 transactions max. The uint16 limit (65,535) provides headroom.</p>

<strong>BlockAccessIndex semantics</strong>:
<ul><li><code>0</code> = pre-execution phase (system contracts before tx 1)</li>
<li><code>1</code> to <code>n</code> = transaction indices (1-indexed, not 0-indexed!)</li>
<li><code>n+1</code> = post-execution phase (withdrawals, post-block system calls)</li>
</ul>
<hr>

<h2>Constants (lines 25-30)</h2>

<pre><code class="language-python"># Constants chosen to support a 630m block gas limit
MAX_TXS = 30_000
# MAX_SLOTS = 300_000
# MAX_ACCOUNTS = 300_000
MAX_CODE_SIZE = 24_576
MAX_CODE_CHANGES = 1</code></pre>

<h3>MAX_TXS = 30,000</h3>

<p>Derived from: 630M gas ÷ 21,000 gas/transfer ≈ 30,000.</p>

<p>This caps <code>BlockAccessIndex</code> values. Any BAL with an index > MAX_TXS + 1 is invalid.</p>

<h3>MAX_CODE_SIZE = 24,576</h3>

<p>From EIP-170. Contract bytecode cannot exceed 24 KiB. This bounds the size of <code>CodeData</code> in <code>CodeChange</code>.</p>

<h3>MAX_CODE_CHANGES = 1</h3>

<strong>Critical constraint</strong>: An account can have at most ONE code change per transaction. This is because:
<ul><li><code>CREATE</code>/<code>CREATE2</code> deploys code once</li>
<li><code>SELFDESTRUCT</code> (in same tx) clears it once</li>
<li>EIP-7702 sets delegation once</li>
</ul>
Multiple code changes per tx would indicate a bug or invalid BAL.

<h3>Commented-out constants</h3>

<pre><code class="language-python"># MAX_SLOTS = 300_000
# MAX_ACCOUNTS = 300_000</code></pre>

<p>These were considered but not enforced. In practice, gas limits bound these implicitly.</p>

<hr>

<h2>StorageChange (lines 32-42)</h2>

<pre><code class="language-python">@slotted_freezable
@dataclass
class StorageChange:
    &quot;&quot;&quot;
    Storage change: [block_access_index, new_value].
    RLP encoded as a list.
    &quot;&quot;&quot;

    block_access_index: BlockAccessIndex
    new_value: StorageValue</code></pre>

<strong>RLP encoding</strong>: <code>[block_access_index, new_value]</code> as a 2-element list.

<strong>Example</strong>:
<pre><code class="language-python"># TX 3 sets storage to 0x42
change = StorageChange(block_access_index=Uint(3), new_value=U256(0x42))
# RLP: [0x03, 0x42] → 0xc20342</code></pre>

<strong>Why <code>new_value</code>, not delta?</strong>

<p>Recording the post-value (not the change amount) enables state reconstruction without knowing the pre-state. This is essential for executionless sync.</p>

<hr>

<h2>BalanceChange (lines 44-54)</h2>

<pre><code class="language-python">@slotted_freezable
@dataclass
class BalanceChange:
    &quot;&quot;&quot;
    Balance change: [block_access_index, post_balance].
    RLP encoded as a list.
    &quot;&quot;&quot;

    block_access_index: BlockAccessIndex
    post_balance: Balance</code></pre>

<strong>Field name <code>post_balance</code></strong>: Explicitly "post" to emphasize this is the balance <em>after</em> the transaction, not a delta.

<strong>Multiple entries per account</strong>: Unlike code changes, an account can have multiple balance changes (one per tx that affects it). COINBASE typically has many entries—one for each tx that pays fees.

<hr>

<h2>NonceChange (lines 56-66)</h2>

<pre><code class="language-python">@slotted_freezable
@dataclass
class NonceChange:
    &quot;&quot;&quot;
    Nonce change: [block_access_index, new_nonce].
    RLP encoded as a list.
    &quot;&quot;&quot;

    block_access_index: BlockAccessIndex
    new_nonce: Nonce</code></pre>

<strong>Nonce semantics</strong>: Nonces only increment, never decrement. <code>new_nonce</code> is always greater than the previous value.

<strong>When recorded</strong>:
<ul><li>Transaction sender: nonce increments</li>
<li>Contract using <code>CREATE</code>/<code>CREATE2</code>: nonce increments</li>
<li>Newly deployed contract: nonce set to 1 (EIP-161)</li>
</ul>
<hr>

<h2>CodeChange (lines 68-78)</h2>

<pre><code class="language-python">@slotted_freezable
@dataclass
class CodeChange:
    &quot;&quot;&quot;
    Code change: [block_access_index, new_code].
    RLP encoded as a list.
    &quot;&quot;&quot;

    block_access_index: BlockAccessIndex
    new_code: CodeData</code></pre>

<strong><code>new_code</code> contents</strong>:
<ul><li>Contract deployment: the deployed bytecode (after initcode runs)</li>
<li>EIP-7702 delegation: <code>0xef0100</code> + 20-byte target address (23 bytes total)</li>
<li>SELFDESTRUCT (same-tx): empty bytes <code>b''</code></li>
</ul>
<strong>Size bound</strong>: <code>len(new_code) <= MAX_CODE_SIZE</code> (24,576 bytes)

<hr>

<h2>SlotChanges (lines 80-90)</h2>

<pre><code class="language-python">@slotted_freezable
@dataclass
class SlotChanges:
    &quot;&quot;&quot;
    All changes to a single storage slot: [slot, [changes]].
    RLP encoded as a list.
    &quot;&quot;&quot;

    slot: StorageKey
    changes: Tuple[StorageChange, ...]</code></pre>

<strong>Grouping by slot</strong>: A single slot may be modified by multiple transactions in a block. <code>SlotChanges</code> groups all modifications to one slot.

<strong>Example</strong>:
<pre><code class="language-python"># Slot 0x01 modified by TX 2 (→0x100) and TX 5 (→0x200)
slot_changes = SlotChanges(
    slot=U256(0x01),
    changes=(
        StorageChange(Uint(2), U256(0x100)),
        StorageChange(Uint(5), U256(0x200)),
    )
)
# RLP: [0x01, [[0x02, 0x820100], [0x05, 0x820200]]]</code></pre>

<strong>Ordering</strong>: Changes within a slot are ordered by <code>block_access_index</code> (ascending). This is enforced during BAL construction (see Section 07).

<hr>

<h2>AccountChanges (lines 92-115)</h2>

<pre><code class="language-python">@slotted_freezable
@dataclass
class AccountChanges:
    &quot;&quot;&quot;
    All changes for a single account, grouped by field type.
    RLP encoded as: [address, storage_changes, storage_reads,
    balance_changes, nonce_changes, code_changes].
    &quot;&quot;&quot;

    address: Address

    # slot -&gt; [block_access_index -&gt; new_value]
    storage_changes: Tuple[SlotChanges, ...]

    # read-only storage keys
    storage_reads: Tuple[StorageKey, ...]

    # [block_access_index -&gt; post_balance]
    balance_changes: Tuple[BalanceChange, ...]

    # [block_access_index -&gt; new_nonce]
    nonce_changes: Tuple[NonceChange, ...]

    # [block_access_index -&gt; new_code]
    code_changes: Tuple[CodeChange, ...]</code></pre>

<strong>RLP field order</strong> (fixed, positional):
<ul><li><code>address</code> (20 bytes)</li>
<li><code>storage_changes</code> (list of SlotChanges)</li>
<li><code>storage_reads</code> (list of StorageKey)</li>
<li><code>balance_changes</code> (list of BalanceChange)</li>
<li><code>nonce_changes</code> (list of NonceChange)</li>
<li><code>code_changes</code> (list of CodeChange)</li>
</ul>
<strong>Why <code>storage_reads</code> is separate from <code>storage_changes</code></strong>:

<p>Storage reads don't need post-values (there's nothing to reconstruct). Separating them: <ul><li>Reduces BAL size (~1/3 smaller per read vs write)</li> <li>Makes intent clear (read vs write)</li> <li>Enables different handling in clients (reads for prefetch, writes for state update)</li> </ul> <strong>Empty lists are valid</strong>: An account touched but unchanged has all-empty lists. The address still appears in the BAL to indicate it was accessed.</p>

<hr>

<h2>BlockAccessList (line 118-121)</h2>

<pre><code class="language-python">BlockAccessList = List[AccountChanges]</code></pre>

<strong>The top-level type</strong>: A BAL is simply a list of <code>AccountChanges</code>.

<strong>Ordering</strong>: Accounts are sorted lexicographically by address. This is NOT enforced here (just a type alias) but is enforced during construction (see Section 07).

<strong>Hash computation</strong>:
<pre><code class="language-python">block_access_list_hash = keccak256(rlp.encode(block_access_list))</code></pre>

<hr>

<h2>Cross-References</h2>

<ul><li><strong>Section 02 (RLP Utilities)</strong>: Encoding/decoding functions for these types</li>
<li><strong>Section 06-07 (Builder)</strong>: How these structures are constructed during execution</li>
<li><strong>Section 03-05 (State Tracker)</strong>: The recording layer that feeds the builder</li>
<li><strong>EIP-7928</strong>: Canonical specification text</li>
</ul>
<hr>

<h2>Gotchas</h2>

<h3>1. BlockAccessIndex is 1-indexed for transactions</h3>

<pre><code class="language-python"># Transaction 1 has block_access_index = 1, NOT 0
# Index 0 is reserved for pre-execution
# Index n+1 is post-execution</code></pre>

<h3>2. Tuples, not Lists</h3>

<p>All collection fields use <code>Tuple[..., ...]</code> (immutable) not <code>List[...]</code>. This ensures BAL structures can't be modified after creation.</p>

<h3>3. storage_reads contains ONLY reads</h3>

<p>A slot that was both read AND written goes in <code>storage_changes</code>, not <code>storage_reads</code>. The "read" is implicit in the write.</p>

<h3>4. Empty code means cleared, not absent</h3>

<pre><code class="language-python">CodeChange(block_access_index=Uint(3), new_code=b'')  # Code was CLEARED
# vs
code_changes=()  # No code change occurred</code></pre>

<h3>5. U256(0) RLP encoding</h3>

<p>Zero encodes as empty RLP string <code>0x80</code>, not <code>0x00</code>: <pre><code class="language-python">rlp.encode(U256(0)) == b'\x80'  # Correct
rlp.encode(U256(0)) != b'\x00'  # Wrong</code></pre></p>
</section>

<section id="section-02-rlp-utilities">
<h1>Section 02: RLP Utilities</h1>

<h2>Source</h2>
<code>specs/execution-specs/src/ethereum/forks/amsterdam/block_access_lists/rlp_utils.py</code> (117 lines)

<hr>

<h2>Imports (lines 16-24)</h2>

<pre><code class="language-python">from typing import cast

from ethereum_rlp import Extended, rlp
from ethereum_types.bytes import Bytes
from ethereum_types.numeric import Uint

from ethereum.crypto.hash import Hash32, keccak256

from .rlp_types import BlockAccessList</code></pre>

<code>Extended</code> is the union type for RLP-encodable values. <code>cast</code> is needed because Python's type system can't verify nested list structures match <code>Extended</code>.

<hr>

<h2>compute_block_access_list_hash (lines 27-47)</h2>

<pre><code class="language-python">def compute_block_access_list_hash(
    block_access_list: BlockAccessList,
) -&gt; Hash32:
    block_access_list_bytes = rlp_encode_block_access_list(block_access_list)
    return keccak256(block_access_list_bytes)</code></pre>

<strong>This is the consensus-critical function.</strong> The returned hash goes into the block header as <code>block_access_list_hash</code>.

<strong>Validation path</strong>:
<ul><li>Builder produces BAL during execution</li>
<li><code>compute_block_access_list_hash(bal)</code> → hash in header</li>
<li>Validator re-executes, builds BAL, computes hash</li>
<li>Hash mismatch → block invalid</li>
</ul>
<hr>

<h2>rlp_encode_block_access_list (lines 50-113)</h2>

<pre><code class="language-python">def rlp_encode_block_access_list(block_access_list: BlockAccessList) -&gt; Bytes:
    account_changes_list = []
    for account in block_access_list:
        storage_changes_list = [
            [
                slot_changes.slot,
                [
                    [Uint(c.block_access_index), c.new_value]
                    for c in slot_changes.changes
                ],
            ]
            for slot_changes in account.storage_changes
        ]

        storage_reads_list = list(account.storage_reads)

        balance_changes_list = [
            [Uint(bc.block_access_index), Uint(bc.post_balance)]
            for bc in account.balance_changes
        ]

        nonce_changes_list = [
            [Uint(nc.block_access_index), Uint(nc.new_nonce)]
            for nc in account.nonce_changes
        ]

        code_changes_list = [
            [Uint(cc.block_access_index), cc.new_code]
            for cc in account.code_changes
        ]

        account_changes_list.append(
            [
                account.address,
                storage_changes_list,
                storage_reads_list,
                balance_changes_list,
                nonce_changes_list,
                code_changes_list,
            ]
        )

    encoded = rlp.encode(cast(Extended, account_changes_list))
    return Bytes(encoded)</code></pre>

<h3>Encoding Structure</h3>

<pre><code class="language-text">BlockAccessList = [
  AccountChanges_0,
  AccountChanges_1,
  ...
]

AccountChanges = [
  address,                    # Bytes20
  storage_changes,            # [[slot, [[idx, val], ...]], ...]
  storage_reads,              # [slot, ...]
  balance_changes,            # [[idx, balance], ...]
  nonce_changes,              # [[idx, nonce], ...]
  code_changes                # [[idx, code], ...]
]</code></pre>

<h3>Uint() Wrapping</h3>

<p>Notice explicit <code>Uint()</code> conversions: <pre><code class="language-python">[Uint(c.block_access_index), c.new_value]
[Uint(bc.block_access_index), Uint(bc.post_balance)]</code></pre></p>

<p>This ensures RLP integer encoding (minimal big-endian, no leading zeros). Without wrapping, Python ints might encode incorrectly.</p>

<h3>No Validation</h3>

<p>This function does NOT validate: <ul><li>Ordering (addresses sorted, slots sorted, indices ascending)</li> <li>Bounds (MAX_TXS, MAX_CODE_SIZE)</li> <li>Semantic correctness (valid indices)</li> </ul> Validation happens in <code>builder.py</code> during construction. This function assumes input is already valid.</p>

<hr>

<h2>What's Missing</h2>

<p>The file is minimal—only encoding, no decoding. This is intentional:</p>

<ul><li><strong>Block producers</strong> encode BALs they build</li>
<li><strong>Validators</strong> don't decode received BALs—they rebuild from execution and compare hashes</li>
<li><strong>Sync nodes</strong> using executionless sync would need decoding, but that's not in EELS yet</li>
</ul>
If decoding is added later, it would mirror the encoding structure with validation checks.

<hr>

<h2>RLP Output Example</h2>

<p>For a simple transfer (Alice → Bob, TX 1):</p>

<pre><code class="language-python">bal = [
    AccountChanges(
        address=ALICE,
        storage_changes=(),
        storage_reads=(),
        balance_changes=(BalanceChange(1, 4_000_000_000_000_000_000),),
        nonce_changes=(NonceChange(1, 43),),
        code_changes=(),
    ),
    AccountChanges(
        address=BOB,
        storage_changes=(),
        storage_reads=(),
        balance_changes=(BalanceChange(1, 2_000_000_000_000_000_000),),
        nonce_changes=(),
        code_changes=(),
    ),
]

# Encodes to (simplified):
# [
#   [alice_addr, [], [], [[1, 4e18]], [[1, 43]], []],
#   [bob_addr, [], [], [[1, 2e18]], [], []]
# ]</code></pre>

<hr>

<h2>Cross-References</h2>

<ul><li><strong>Section 01</strong>: Type definitions being encoded</li>
<li><strong>Section 07</strong>: Where ordering/validation happens before encoding</li>
<li><strong>Section 08</strong>: <code>blocks.py</code> calls <code>compute_block_access_list_hash</code></li>
</ul>
</section>

<section id="section-03-state-tracker---data-structures">
<h1>Section 03: State Tracker - Data Structures</h1>

<h2>Source</h2>
<code>specs/execution-specs/src/ethereum/forks/amsterdam/state_tracker.py</code> (lines 1-110)

<hr>

<h2>Module Docstring (lines 1-11)</h2>

<pre><code class="language-python">&quot;&quot;&quot;
EIP-7928 Block Access Lists: Hierarchical State Change Tracking.

Frame hierarchy mirrors EVM execution: Block -&gt; Transaction -&gt; Call frames.
Each frame tracks state accesses and merges to parent on completion.

On success, changes merge upward with net-zero filtering (pre-state vs final).
On failure, only reads merge (writes discarded). Pre-state captures use
first-write-wins semantics and are stored at the transaction frame level.
&quot;&quot;&quot;</code></pre>

<p>Three key concepts: <ul><li><strong>Frame hierarchy</strong>: Block → Transaction → Call (nested arbitrarily deep)</li> <li><strong>Merge semantics</strong>: Success = merge all; Failure = merge reads only</li> <li><strong>First-write-wins</strong>: Pre-values captured on first access, not overwritten</li> </ul> <hr></p>

<h2>StateChanges Dataclass (lines 24-56)</h2>

<pre><code class="language-python">@dataclass
class StateChanges:
    parent: Optional[&quot;StateChanges&quot;] = None
    block_access_index: BlockAccessIndex = BlockAccessIndex(0)

    touched_addresses: Set[Address] = field(default_factory=set)
    storage_reads: Set[Tuple[Address, Bytes32]] = field(default_factory=set)
    storage_writes: Dict[Tuple[Address, Bytes32, BlockAccessIndex], U256] = (
        field(default_factory=dict)
    )

    balance_changes: Dict[Tuple[Address, BlockAccessIndex], U256] = field(
        default_factory=dict
    )
    nonce_changes: Set[Tuple[Address, BlockAccessIndex, U64]] = field(
        default_factory=set
    )
    code_changes: Dict[Tuple[Address, BlockAccessIndex], Bytes] = field(
        default_factory=dict
    )

    # Pre-state captures (transaction-scoped)
    pre_balances: Dict[Address, U256] = field(default_factory=dict)
    pre_storage: Dict[Tuple[Address, Bytes32], U256] = field(default_factory=dict)
    pre_code: Dict[Address, Bytes] = field(default_factory=dict)</code></pre>

<h3>Field Breakdown</h3>

<table><tr><th>Field</th><th>Key Type</th><th>Value Type</th><th>Purpose</th></tr>
<tr><td><code>parent</code></td><td>-</td><td><code>StateChanges?</code></td><td>Links frame hierarchy</td></tr>
<tr><td><code>block_access_index</code></td><td>-</td><td><code>Uint</code></td><td>Current tx index (0=pre, 1..n=tx, n+1=post)</td></tr>
<tr><td><code>touched_addresses</code></td><td>-</td><td><code>Set[Address]</code></td><td>All accessed addresses</td></tr>
<tr><td><code>storage_reads</code></td><td><code>(addr, slot)</code></td><td>-</td><td>Slots read but not written</td></tr>
<tr><td><code>storage_writes</code></td><td><code>(addr, slot, idx)</code></td><td><code>U256</code></td><td>Slot writes with tx attribution</td></tr>
<tr><td><code>balance_changes</code></td><td><code>(addr, idx)</code></td><td><code>U256</code></td><td>Balance after tx</td></tr>
<tr><td><code>nonce_changes</code></td><td><code>(addr, idx, nonce)</code></td><td>-</td><td>Nonce increments (set, not dict)</td></tr>
<tr><td><code>code_changes</code></td><td><code>(addr, idx)</code></td><td><code>Bytes</code></td><td>Code deployments/delegations</td></tr>
<tr><td><code>pre_balances</code></td><td><code>addr</code></td><td><code>U256</code></td><td>Pre-tx balance (for net-zero filter)</td></tr>
<tr><td><code>pre_storage</code></td><td><code>(addr, slot)</code></td><td><code>U256</code></td><td>Pre-tx storage (for net-zero filter)</td></tr>
<tr><td><code>pre_code</code></td><td><code>addr</code></td><td><code>Bytes</code></td><td>Pre-tx code (for net-zero filter)</td></tr></table>
<h3>Why nonce_changes is a Set, not Dict</h3>

<pre><code class="language-python">nonce_changes: Set[Tuple[Address, BlockAccessIndex, U64]]</code></pre>

<p>Nonces only increment. Multiple nonce changes per address/tx can occur (CREATE inside a tx), but only the final nonce matters. Using a Set with the nonce value as part of the tuple allows deduplication during merge (keep highest).</p>

<h3>Why storage_writes includes BlockAccessIndex in key</h3>

<pre><code class="language-python">storage_writes: Dict[Tuple[Address, Bytes32, BlockAccessIndex], U256]</code></pre>

<p>A single slot can be written by multiple transactions. The index in the key allows tracking each write separately, which is needed for the BAL's <code>SlotChanges.changes</code> list.</p>

<hr>

<h2>get_block_frame (lines 59-74)</h2>

<pre><code class="language-python">def get_block_frame(state_changes: StateChanges) -&gt; StateChanges:
    block_frame = state_changes
    while block_frame.parent is not None:
        block_frame = block_frame.parent
    return block_frame</code></pre>

<p>Walks to root. Block frame has <code>parent = None</code>.</p>

<hr>

<h2>increment_block_access_index (lines 77-88)</h2>

<pre><code class="language-python">def increment_block_access_index(root_frame: StateChanges) -&gt; None:
    root_frame.block_access_index = BlockAccessIndex(
        root_frame.block_access_index + Uint(1)
    )</code></pre>

<p>Called between transactions. Index 0 → 1 before tx 1, index 1 → 2 before tx 2, etc.</p>

<hr>

<h2>get_transaction_frame (lines 91-108)</h2>

<pre><code class="language-python">def get_transaction_frame(state_changes: StateChanges) -&gt; StateChanges:
    tx_frame = state_changes
    while tx_frame.parent is not None and tx_frame.parent.parent is not None:
        tx_frame = tx_frame.parent
    return tx_frame</code></pre>

<p>Walks up until <code>parent.parent is None</code>. The tx frame is the direct child of the block frame.</p>

<strong>Frame depth identification</strong>:
<ul><li><code>parent is None</code> → block frame</li>
<li><code>parent.parent is None</code> → transaction frame</li>
<li><code>parent.parent.parent is None</code> → first call frame</li>
<li>etc.</li>
</ul>
<hr>

<h2>capture_pre_balance (lines 111-130)</h2>

<pre><code class="language-python">def capture_pre_balance(
    tx_frame: StateChanges, address: Address, balance: U256
) -&gt; None:
    assert tx_frame.parent is None or tx_frame.parent.parent is None
    if address not in tx_frame.pre_balances:
        tx_frame.pre_balances[address] = balance</code></pre>

<strong>First-write-wins</strong>: Only captures if not already present. The pre-value is the state at transaction start, not at current call frame start.

<strong>Assertion</strong>: Must be called on tx frame (or block frame for system calls).

<hr>

<h2>capture_pre_storage (lines 133-156)</h2>

<pre><code class="language-python">def capture_pre_storage(
    tx_frame: StateChanges, address: Address, key: Bytes32, value: U256
) -&gt; None:
    assert tx_frame.parent is None or tx_frame.parent.parent is None
    slot = (address, key)
    if slot not in tx_frame.pre_storage:
        tx_frame.pre_storage[slot] = value</code></pre>

<p>Same pattern. Pre-storage is used for net-zero filtering: <ul><li>If <code>storage_writes[(addr, key, idx)] == pre_storage[(addr, key)]</code>, the write is converted to a read.</li> </ul> <hr></p>

<h2>capture_pre_code (lines 159-178)</h2>

<pre><code class="language-python">def capture_pre_code(
    tx_frame: StateChanges, address: Address, code: Bytes
) -&gt; None:
    assert tx_frame.parent is None or tx_frame.parent.parent is None
    if address not in tx_frame.pre_code:
        tx_frame.pre_code[address] = code</code></pre>

<p>Same pattern. Used for EIP-7702 delegation changes that might restore original code.</p>

<hr>

<h2>Frame Hierarchy Diagram</h2>

<pre><code class="language-text">┌──────────────────────────────────────────────────────────┐
│ Block Frame (parent=None)                                │
│   block_access_index: managed here                       │
│   touched_addresses: accumulated from all txs            │
│   storage_reads/writes: final BAL data                   │
│                                                          │
│  ┌────────────────────────────────────────────────────┐  │
│  │ TX Frame (parent=block, parent.parent=None)        │  │
│  │   pre_balances, pre_storage, pre_code: captured    │  │
│  │   block_access_index: inherited from block         │  │
│  │                                                    │  │
│  │  ┌──────────────────────────────────────────────┐  │  │
│  │  │ Call Frame 1 (parent=tx)                     │  │  │
│  │  │   No pre-captures (delegated to tx frame)    │  │  │
│  │  │                                              │  │  │
│  │  │  ┌────────────────────────────────────────┐  │  │  │
│  │  │  │ Call Frame 2 (parent=call1)            │  │  │  │
│  │  │  │   Arbitrary nesting depth              │  │  │  │
│  │  │  └────────────────────────────────────────┘  │  │  │
│  │  └──────────────────────────────────────────────┘  │  │
│  └────────────────────────────────────────────────────┘  │
└──────────────────────────────────────────────────────────┘</code></pre>

<hr>

<h2>Cross-References</h2>

<ul><li><strong>Section 04</strong>: Recording functions (<code>track_<em></code>)</li>
<li><strong>Section 05</strong>: Frame management (<code>merge_</em></code>, <code>commit_<em></code>, <code>filter_</em></code>)</li>
<li><strong>Section 06-07</strong>: Builder consumes the block frame after all txs complete</li>
</ul>
</section>

<section id="section-04-state-tracker---recording-logic">
<h1>Section 04: State Tracker - Recording Logic</h1>

<h2>Source</h2>
<code>specs/execution-specs/src/ethereum/forks/amsterdam/state_tracker.py</code> (lines 180-330)

<hr>

<h2>track_address (lines 188-201)</h2>

<pre><code class="language-python">def track_address(state_changes: StateChanges, address: Address) -&gt; None:
    state_changes.touched_addresses.add(address)</code></pre>

<p>Called for every address access regardless of type. Even if no state changes, the address appears in the BAL.</p>

<strong>Call sites</strong>:
<ul><li>Transaction sender/recipient</li>
<li><code>BALANCE</code>, <code>EXTCODESIZE</code>, <code>EXTCODECOPY</code>, <code>EXTCODEHASH</code> targets</li>
<li><code>CALL</code>, <code>DELEGATECALL</code>, <code>STATICCALL</code>, <code>CALLCODE</code> targets</li>
<li><code>CREATE</code>, <code>CREATE2</code> deployments</li>
<li>Precompile calls</li>
<li>System contract calls</li>
</ul>
<hr>

<h2>track_storage_read (lines 204-220)</h2>

<pre><code class="language-python">def track_storage_read(
    state_changes: StateChanges, address: Address, key: Bytes32
) -&gt; None:
    state_changes.storage_reads.add((address, key))</code></pre>

<p>Called on <code>SLOAD</code>. The slot goes into <code>storage_reads</code> initially. If the same slot is later written in the same tx, the final placement (reads vs writes) is determined by net-zero filtering at commit time.</p>

<hr>

<h2>track_storage_write (lines 223-243)</h2>

<pre><code class="language-python">def track_storage_write(
    state_changes: StateChanges,
    address: Address,
    key: Bytes32,
    value: U256,
) -&gt; None:
    idx = state_changes.block_access_index
    state_changes.storage_writes[(address, key, idx)] = value</code></pre>

<p>Called on <code>SSTORE</code>. Note: <ul><li>Key includes <code>block_access_index</code> to track per-tx writes</li> <li>Value is the <em>new</em> value, not delta</li> <li>Same <code>(addr, key, idx)</code> overwrites previous (latest value wins within a tx)</li> </ul> <strong>Gas validation already passed</strong>: If <code>track_storage_write</code> is called, the SSTORE stipend check (>2300 gas) succeeded. See Section 09.</p>

<hr>

<h2>track_balance_change (lines 246-265)</h2>

<pre><code class="language-python">def track_balance_change(
    state_changes: StateChanges,
    address: Address,
    new_balance: U256,
) -&gt; None:
    idx = state_changes.block_access_index
    state_changes.balance_changes[(address, idx)] = new_balance</code></pre>

<p>Called when balance changes: <ul><li>Transaction value transfer</li> <li>Gas payment (sender)</li> <li>Gas refund (sender)</li> <li>Fee payment (COINBASE)</li> <li><code>SELFDESTRUCT</code> balance transfer</li> <li>Withdrawals</li> </ul> Multiple calls with same <code>(addr, idx)</code> overwrite—only final balance matters.</p>

<hr>

<h2>track_nonce_change (lines 268-287)</h2>

<pre><code class="language-python">def track_nonce_change(
    state_changes: StateChanges,
    address: Address,
    new_nonce: U64,
) -&gt; None:
    idx = state_changes.block_access_index
    state_changes.nonce_changes.add((address, idx, new_nonce))</code></pre>

<strong>Uses <code>.add()</code> not assignment</strong>: Multiple nonce increments in a tx (e.g., tx sender + CREATE) each add an entry. During merge, only highest nonce per address is kept.

<p>Called when: <ul><li>Transaction execution (sender nonce++)</li> <li><code>CREATE</code>/<code>CREATE2</code> (deployer nonce++)</li> <li>Newly deployed contract (nonce set to 1 per EIP-161)</li> </ul> <hr></p>

<h2>track_code_change (lines 290-310)</h2>

<pre><code class="language-python">def track_code_change(
    state_changes: StateChanges,
    address: Address,
    new_code: Bytes,
) -&gt; None:
    idx = state_changes.block_access_index
    state_changes.code_changes[(address, idx)] = new_code</code></pre>

<p>Called when: <ul><li>Contract deployment completes (<code>CREATE</code>/<code>CREATE2</code> returns)</li> <li>EIP-7702 delegation set (<code>0xef0100 + target</code>)</li> <li><code>SELFDESTRUCT</code> clears code (same-tx creation, <code>new_code = b''</code>)</li> </ul> <strong>MAX_CODE_CHANGES = 1</strong>: At most one code change per address per tx. The dict key <code>(addr, idx)</code> enforces this—multiple calls overwrite.</p>

<hr>

<h2>track_selfdestruct (lines 313-365)</h2>

<pre><code class="language-python">def track_selfdestruct(
    tx_frame: StateChanges,
    address: Address,
) -&gt; None:
    assert tx_frame.parent is not None and tx_frame.parent.parent is None

    idx = tx_frame.block_access_index

    # Remove nonce changes from current transaction
    tx_frame.nonce_changes = {
        (addr, i, nonce)
        for addr, i, nonce in tx_frame.nonce_changes
        if not (addr == address and i == idx)
    }

    # Remove balance changes from current transaction
    if (address, idx) in tx_frame.balance_changes:
        pre_balance = tx_frame.pre_balances[address]
        if pre_balance == U256(0):
            del tx_frame.balance_changes[(address, idx)]

    # Remove code changes from current transaction
    if (address, idx) in tx_frame.code_changes:
        del tx_frame.code_changes[(address, idx)]

    # Convert storage writes from current transaction to reads
    for addr, key, i in list(tx_frame.storage_writes.keys()):
        if addr == address and i == idx:
            del tx_frame.storage_writes[(addr, key, i)]
            tx_frame.storage_reads.add((addr, key))</code></pre>

<strong>EIP-6780 interaction</strong>: <code>SELFDESTRUCT</code> only destroys contracts created in the same transaction. This function handles BAL implications:

<ul><li><strong>Nonce</strong>: Removed (account ceases to exist)</li>
<li><strong>Balance</strong>: Kept only if pre-balance was non-zero (transfer to beneficiary is recorded)</li>
<li><strong>Code</strong>: Removed (no deployment in final state)</li>
<li><strong>Storage writes</strong>: Converted to reads (slots were accessed but final state is empty)</li>
</ul>
<strong>Why tx_frame assertion?</strong>: SELFDESTRUCT can only happen within a tx, and we need access to <code>pre_balances</code> for the balance logic.

<hr>

<h2>Recording Flow Example</h2>

<pre><code class="language-text">TX 1: Alice (0xaaaa) sends 1 ETH to Bob (0xbbbb)

1. begin_transaction(block_frame) → tx_frame created
2. increment_block_access_index(block_frame) → idx = 1

3. track_address(tx_frame, ALICE)
4. capture_pre_balance(tx_frame, ALICE, 5 ETH)
5. track_balance_change(tx_frame, ALICE, 3.999 ETH)  # after value + gas
6. track_nonce_change(tx_frame, ALICE, 43)

7. track_address(tx_frame, BOB)
8. capture_pre_balance(tx_frame, BOB, 1 ETH)
9. track_balance_change(tx_frame, BOB, 2 ETH)

10. track_address(tx_frame, COINBASE)
11. capture_pre_balance(tx_frame, COINBASE, 100 ETH)
12. track_balance_change(tx_frame, COINBASE, 100.001 ETH)

13. commit_transaction_frame(tx_frame)  # filters net-zero, merges to block</code></pre>

<hr>

<h2>Cross-References</h2>

<ul><li><strong>Section 03</strong>: StateChanges dataclass these functions populate</li>
<li><strong>Section 05</strong>: merge_<em> and commit_</em> that consume the recorded data</li>
<li><strong>Section 09</strong>: VM integration showing where track_* is called from EVM opcodes</li>
</ul>
</section>

<section id="section-05-state-tracker---frame-management">
<h1>Section 05: State Tracker - Frame Management</h1>

<h2>Source</h2>
<code>specs/execution-specs/src/ethereum/forks/amsterdam/state_tracker.py</code> (lines 368-558)

<hr>

<h2>merge_on_success (lines 368-412)</h2>

<pre><code class="language-python">def merge_on_success(child_frame: StateChanges) -&gt; None:
    assert child_frame.parent is not None
    parent_frame = child_frame.parent

    # Merge address accesses
    parent_frame.touched_addresses.update(child_frame.touched_addresses)

    # Merge storage: reads union, writes overwrite
    parent_frame.storage_reads.update(child_frame.storage_reads)
    for storage_key, storage_value in child_frame.storage_writes.items():
        parent_frame.storage_writes[storage_key] = storage_value

    # Merge balance changes: child overwrites parent
    for balance_key, balance_value in child_frame.balance_changes.items():
        parent_frame.balance_changes[balance_key] = balance_value

    # Merge nonce changes: keep highest nonce per address
    address_final_nonces: Dict[Address, Tuple[BlockAccessIndex, U64]] = {}
    for addr, idx, nonce in child_frame.nonce_changes:
        if addr not in address_final_nonces or nonce &gt; address_final_nonces[addr][1]:
            address_final_nonces[addr] = (idx, nonce)
    for addr, (idx, final_nonce) in address_final_nonces.items():
        parent_frame.nonce_changes.add((addr, idx, final_nonce))

    # Merge code changes: child overwrites parent
    for code_key, code_value in child_frame.code_changes.items():
        parent_frame.code_changes[code_key] = code_value</code></pre>

<p>Called when a call frame returns successfully (no revert).</p>

<strong>Key behaviors</strong>:
<ul><li><code>touched_addresses</code>: Union (both parent and child addresses kept)</li>
<li><code>storage_reads</code>: Union</li>
<li><code>storage_writes</code>: Child overwrites (latest value wins)</li>
<li><code>balance_changes</code>: Child overwrites</li>
<li><code>nonce_changes</code>: Keep highest nonce per address</li>
<li><code>code_changes</code>: Child overwrites</li>
</ul>
<strong>No net-zero filtering here</strong>: That happens once at <code>commit_transaction_frame</code>.

<hr>

<h2>merge_on_failure (lines 415-437)</h2>

<pre><code class="language-python">def merge_on_failure(child_frame: StateChanges) -&gt; None:
    assert child_frame.parent is not None
    parent_frame = child_frame.parent

    # Only merge reads and address accesses on failure
    parent_frame.touched_addresses.update(child_frame.touched_addresses)
    parent_frame.storage_reads.update(child_frame.storage_reads)

    # Convert writes to reads
    for address, key, _idx in child_frame.storage_writes.keys():
        parent_frame.storage_reads.add((address, key))

    # balance_changes, nonce_changes, code_changes: NOT merged</code></pre>

<p>Called when a call frame reverts.</p>

<strong>Key behaviors</strong>:
<ul><li><code>touched_addresses</code>: Merged (addresses were still accessed)</li>
<li><code>storage_reads</code>: Merged</li>
<li><code>storage_writes</code>: <strong>Converted to reads</strong> (write happened but was reverted)</li>
<li><code>balance_changes</code>: <strong>Discarded</strong></li>
<li><code>nonce_changes</code>: <strong>Discarded</strong></li>
<li><code>code_changes</code>: <strong>Discarded</strong></li>
</ul>
<strong>Why convert writes to reads?</strong>: The slot was accessed (for prefetch purposes) even though the final value didn't change.

<hr>

<h2>commit_transaction_frame (lines 440-477)</h2>

<pre><code class="language-python">def commit_transaction_frame(tx_frame: StateChanges) -&gt; None:
    assert tx_frame.parent is not None
    block_frame = tx_frame.parent

    # Filter net-zero changes before committing
    filter_net_zero_frame_changes(tx_frame)

    # Merge all state to block frame
    block_frame.touched_addresses.update(tx_frame.touched_addresses)
    block_frame.storage_reads.update(tx_frame.storage_reads)
    for (addr, key, idx), value in tx_frame.storage_writes.items():
        block_frame.storage_writes[(addr, key, idx)] = value
    for (addr, idx), final_balance in tx_frame.balance_changes.items():
        block_frame.balance_changes[(addr, idx)] = final_balance
    for addr, idx, nonce in tx_frame.nonce_changes:
        block_frame.nonce_changes.add((addr, idx, nonce))
    for (addr, idx), final_code in tx_frame.code_changes.items():
        block_frame.code_changes[(addr, idx)] = final_code</code></pre>

<p>Called after successful tx execution (or after rollback_transaction if failed).</p>

<strong>Critical</strong>: Calls <code>filter_net_zero_frame_changes</code> BEFORE merging. This ensures only actual state changes make it to the block frame.

<hr>

<h2>create_child_frame (lines 480-504)</h2>

<pre><code class="language-python">def create_child_frame(parent: StateChanges) -&gt; StateChanges:
    return StateChanges(
        parent=parent,
        block_access_index=parent.block_access_index,
    )</code></pre>

<p>Creates a new frame linked to parent. Inherits <code>block_access_index</code> so track functions don't need to walk up the hierarchy.</p>

<hr>

<h2>filter_net_zero_frame_changes (lines 507-558)</h2>

<pre><code class="language-python">def filter_net_zero_frame_changes(tx_frame: StateChanges) -&gt; None:
    idx = tx_frame.block_access_index

    # Filter storage: convert net-zero writes to reads
    addresses_to_check_storage = [
        (addr, key)
        for (addr, key, i) in tx_frame.storage_writes.keys()
        if i == idx
    ]
    for addr, key in addresses_to_check_storage:
        assert (addr, key) in tx_frame.pre_storage
        pre_value = tx_frame.pre_storage[(addr, key)]
        post_value = tx_frame.storage_writes[(addr, key, idx)]
        if pre_value == post_value:
            del tx_frame.storage_writes[(addr, key, idx)]
            tx_frame.storage_reads.add((addr, key))

    # Filter balance: remove if pre == post
    addresses_to_check_balance = [
        addr for (addr, i) in tx_frame.balance_changes.keys() if i == idx
    ]
    for addr in addresses_to_check_balance:
        assert addr in tx_frame.pre_balances
        pre_balance = tx_frame.pre_balances[addr]
        post_balance = tx_frame.balance_changes[(addr, idx)]
        if pre_balance == post_balance:
            del tx_frame.balance_changes[(addr, idx)]

    # Filter code: remove if pre == post
    addresses_to_check_code = [
        addr for (addr, i) in tx_frame.code_changes.keys() if i == idx
    ]
    for addr in addresses_to_check_code:
        assert addr in tx_frame.pre_code
        pre_code = tx_frame.pre_code[addr]
        post_code = tx_frame.code_changes[(addr, idx)]
        if pre_code == post_code:
            del tx_frame.code_changes[(addr, idx)]

    # Nonces: no filtering (only increment, never net-zero)</code></pre>

<strong>Net-zero filtering logic</strong>:

<table><tr><th>Field</th><th>If pre == post</th><th>Result</th></tr>
<tr><td>Storage</td><td>Write → Read</td><td>Slot still appears in BAL (as read)</td></tr>
<tr><td>Balance</td><td>Removed</td><td>Address may still appear (if touched)</td></tr>
<tr><td>Code</td><td>Removed</td><td>Address may still appear (if touched)</td></tr>
<tr><td>Nonce</td><td>N/A</td><td>Nonces only increment, never return to original</td></tr></table>
<strong>Assertions</strong>: Every pre-value must have been captured. If assertion fails, there's a bug in the tracking logic (capture_pre_<em> wasn't called).

<hr>

<h2>Net-Zero Example</h2>

<pre><code class="language-solidity">// Pre-tx: slot[0] = 100
function foo() {
    slot[0] = 200;  // track_storage_write(addr, 0, 200)
    slot[0] = 300;  // track_storage_write(addr, 0, 300) - overwrites
    slot[0] = 100;  // track_storage_write(addr, 0, 100) - overwrites
}
// Post-tx: slot[0] = 100</code></pre>

<p>At <code>filter_net_zero_frame_changes</code>: <pre><code class="language-text">pre_storage[(addr, 0)] = 100
storage_writes[(addr, 0, idx)] = 100
pre == post → delete from storage_writes, add to storage_reads</code></pre></p>

<p>Result: Slot 0 appears in <code>storage_reads</code>, not <code>storage_changes</code>.</p>

<hr>

<h2>Full Transaction Lifecycle</h2>

<pre><code class="language-text">begin_transaction():
    tx_frame = create_child_frame(block_frame)

execute_transaction():
    for each call:
        call_frame = create_child_frame(parent)
        execute_call()
        if success:
            merge_on_success(call_frame)
        else:
            merge_on_failure(call_frame)

end_transaction():
    if success:
        commit_transaction_frame(tx_frame)  # includes net-zero filter
    else:
        merge_on_failure(tx_frame)  # discards value changes
        commit_transaction_frame(tx_frame)  # commits reads only</code></pre>

<hr>

<h2>Cross-References</h2>

<ul><li><strong>Section 03</strong>: StateChanges dataclass</li>
<li><strong>Section 04</strong>: track_</em> functions that populate frames</li>
<li><strong>Section 06-07</strong>: Builder consumes block_frame after all txs</li>
<li><strong>Section 08</strong>: blocks.py orchestrates this lifecycle</li>
</ul>
</section>

<section id="section-06-bal-builder---construction">
<h1>Section 06: BAL Builder - Construction</h1>

<h2>Source Files</h2>
<ul><li><code>specs/execution-specs/src/ethereum/forks/amsterdam/block_access_lists/builder.py</code> (lines 1-290)</li>
</ul>
<h2>Overview</h2>

<p>The BAL builder sits between the state tracker (Sections 03-05) and the final <code>BlockAccessList</code> output. During block execution, the state tracker records every state access. After execution completes, those recorded changes are fed to the builder, which:</p>

<ul><li><strong>Organizes</strong> changes by address, then by field type</li>
<li><strong>Deduplicates</strong> within-transaction writes (only final value matters)</li>
<li><strong>Prepares</strong> the data structure for sorting and finalization (Section 07)</li>
</ul>
This section covers the construction phase: the data structures and recording functions. The finalization phase (sorting, encoding) is in Section 07.

<hr>

<h2>Module Docstring (lines 1-14)</h2>

<pre><code class="language-python">&quot;&quot;&quot;
Implements the Block Access List builder that tracks all account
and storage accesses during block execution and constructs the final
[`BlockAccessList`].

The builder follows a two-phase approach:

1. **Collection Phase**: During transaction execution, all state accesses are
   recorded via the tracking functions.
2. **Build Phase**: After block execution, the accumulated data is sorted
   and encoded into the final deterministic format.

[`BlockAccessList`]: ref:ethereum.forks.amsterdam.block_access_lists.rlp_types.BlockAccessList
&quot;&quot;&quot;</code></pre>

<strong>Key insight</strong>: The two-phase design separates concerns:
<ul><li><strong>Collection phase</strong> (this section): Fast, append-mostly operations during hot execution</li>
<li><strong>Build phase</strong> (Section 07): One-time sorting and encoding after execution</li>
</ul>
This matters because block execution is latency-sensitive. Recording should be O(1) or O(log n), not O(n log n). The expensive sorting happens once, after all transactions complete.

<hr>

<h2>Imports (lines 15-31)</h2>

<pre><code class="language-python">from dataclasses import dataclass, field
from typing import TYPE_CHECKING, Dict, List, Set

from ethereum_types.bytes import Bytes
from ethereum_types.numeric import U64, U256

from ..fork_types import Address
from .rlp_types import (
    AccountChanges,
    BalanceChange,
    BlockAccessIndex,
    BlockAccessList,
    CodeChange,
    NonceChange,
    SlotChanges,
    StorageChange,
)

if TYPE_CHECKING:
    from ..state_tracker import StateChanges</code></pre>

<strong><code>TYPE_CHECKING</code> guard</strong>: The <code>StateChanges</code> import is only for type hints. At runtime, we avoid importing <code>state_tracker</code> to prevent circular dependencies (state_tracker imports builder types for recording).

<strong>Import topology</strong>:
<pre><code class="language-text">rlp_types.py (pure data)
     ↑
builder.py (construction)
     ↑
state_tracker.py (recording during execution)</code></pre>

<p>The builder can import from <code>rlp_types</code> but only type-check against <code>state_tracker</code>.</p>

<hr>

<h2>AccountData Dataclass (lines 33-62)</h2>

<pre><code class="language-python">@dataclass
class AccountData:
    &quot;&quot;&quot;
    Account data stored in the builder during block execution.

    This dataclass tracks all changes made to a single account throughout
    the execution of a block, organized by the type of change and the
    transaction index where it occurred.
    &quot;&quot;&quot;

    storage_changes: Dict[U256, List[StorageChange]] = field(
        default_factory=dict
    )
    &quot;&quot;&quot;
    Mapping from storage slot to list of changes made to that slot.
    Each change includes the transaction index and new value.
    &quot;&quot;&quot;

    storage_reads: Set[U256] = field(default_factory=set)
    &quot;&quot;&quot;
    Set of storage slots that were read but not modified.
    &quot;&quot;&quot;

    balance_changes: List[BalanceChange] = field(default_factory=list)
    &quot;&quot;&quot;
    List of balance changes for this account, ordered by transaction index.
    &quot;&quot;&quot;

    nonce_changes: List[NonceChange] = field(default_factory=list)
    &quot;&quot;&quot;
    List of nonce changes for this account, ordered by transaction index.
    &quot;&quot;&quot;

    code_changes: List[CodeChange] = field(default_factory=list)
    &quot;&quot;&quot;
    List of code changes (contract deployments) for this account,
    ordered by transaction index.
    &quot;&quot;&quot;</code></pre>

<h3>Design Rationale</h3>

<strong>Why <code>Dict[U256, List[StorageChange]]</code> for storage?</strong>

<p>Storage changes need two levels of grouping: <ul><li>By slot (outer dict key)</li> <li>By transaction (inner list elements)</li> </ul> A single slot can be modified multiple times in a block (different transactions). Each modification needs its own <code>StorageChange</code> with the transaction's <code>block_access_index</code>.</p>

<strong>Why <code>List</code> for changes, not <code>Dict</code>?</strong>

<p>Lists preserve insertion order and allow append operations. Changes are typically added in transaction order. The final sorting happens in the build phase, not during collection.</p>

<strong>Why <code>Set[U256]</code> for storage reads?</strong>

<p>Read tracking only cares about "was this slot read?" — the transaction index doesn't matter for reads. A set provides: <ul><li>O(1) membership testing</li> <li>Automatic deduplication</li> <li>Simpler data structure</li> </ul> <strong>Data structure comparison</strong>:</p>

<table><tr><th>Field</th><th>Structure</th><th>Why</th></tr>
<tr><td><code>storage_changes</code></td><td><code>Dict[slot, List[change]]</code></td><td>Group by slot, track per-tx values</td></tr>
<tr><td><code>storage_reads</code></td><td><code>Set[slot]</code></td><td>Just need "was read" flag</td></tr>
<tr><td><code>balance_changes</code></td><td><code>List[change]</code></td><td>Track each tx's final balance</td></tr>
<tr><td><code>nonce_changes</code></td><td><code>List[change]</code></td><td>Track each tx's nonce increment</td></tr>
<tr><td><code>code_changes</code></td><td><code>List[change]</code></td><td>Rare (typically 0-1 per account)</td></tr></table>
<h3>Memory Layout</h3>

<p>Each <code>AccountData</code> instance contains: <ul><li>1 dict (storage_changes)</li> <li>1 set (storage_reads)</li> <li>3 lists (balance, nonce, code)</li> </ul> For a typical account touched by 1-2 transactions: <ul><li>Dict overhead: ~232 bytes (empty Python dict)</li> <li>Set overhead: ~216 bytes (empty Python set)</li> <li>List overhead: ~56 bytes × 3 = 168 bytes</li> <li>Total base: ~616 bytes per touched account</li> </ul> This adds up in blocks with many touched accounts (10,000+ addresses is common in busy blocks).</p>

<hr>

<h2>BlockAccessListBuilder Dataclass (lines 64-79)</h2>

<pre><code class="language-python">@dataclass
class BlockAccessListBuilder:
    &quot;&quot;&quot;
    Builder for constructing [`BlockAccessList`] efficiently during transaction
    execution.

    The builder accumulates all account and storage accesses during block
    execution and constructs a deterministic access list. Changes are tracked
    by address, field type, and transaction index to enable efficient
    reconstruction of state changes.

    [`BlockAccessList`]: ref:ethereum.forks.amsterdam.block_access_lists.rlp_types.BlockAccessList
    &quot;&quot;&quot;

    accounts: Dict[Address, AccountData] = field(default_factory=dict)
    &quot;&quot;&quot;
    Mapping from account address to its tracked changes during block execution.
    &quot;&quot;&quot;</code></pre>

<strong>Minimal structure</strong>: The builder is just a dict from address to account data. Everything else is in the functions that manipulate it.

<strong>Why not a class with methods?</strong>

<p>EELS follows a functional style. Functions operating on dataclasses are: <ul><li>Easier to test (pure functions)</li> <li>Easier to reason about (no hidden state)</li> <li>Consistent with the rest of the spec</li> </ul> <strong>Thread safety</strong>: The builder is NOT thread-safe. Block execution is single-threaded in EELS. Parallel execution (future work) would need per-thread builders with a merge step.</p>

<hr>

<h2>ensure_account (lines 81-99)</h2>

<pre><code class="language-python">def ensure_account(builder: BlockAccessListBuilder, address: Address) -&gt; None:
    &quot;&quot;&quot;
    Ensure an account exists in the builder's tracking structure.

    Creates an empty [`AccountData`] entry for the given address if it
    doesn't already exist. This function is idempotent and safe to call
    multiple times for the same address.

    Parameters
    ----------
    builder :
        The block access list builder instance.
    address :
        The account address to ensure exists.

    [`AccountData`] :
        ref:ethereum.forks.amsterdam.block_access_lists.builder.AccountData

    &quot;&quot;&quot;
    if address not in builder.accounts:
        builder.accounts[address] = AccountData()</code></pre>

<strong>Idempotency</strong>: Calling <code>ensure_account</code> multiple times for the same address is safe—it only creates the entry once.

<strong>Why a separate function?</strong>

<p>Every recording function needs this check. Factoring it out: <ul><li>Reduces code duplication</li> <li>Makes the intent clear ("ensure exists, then operate")</li> <li>Allows future changes (e.g., logging, metrics) in one place</li> </ul> <strong>Alternative: defaultdict</strong></p>

<pre><code class="language-python"># Could use defaultdict instead:
accounts: Dict[Address, AccountData] = field(
    default_factory=lambda: defaultdict(AccountData)
)</code></pre>

<p>EELS prefers explicit checks over implicit defaultdict behavior. Explicit is clearer for spec-reading.</p>

<hr>

<h2>add_storage_write (lines 101-148)</h2>

<pre><code class="language-python">def add_storage_write(
    builder: BlockAccessListBuilder,
    address: Address,
    slot: U256,
    block_access_index: BlockAccessIndex,
    new_value: U256,
) -&gt; None:
    &quot;&quot;&quot;
    Add a storage write operation to the block access list.

    Records a storage slot modification for a given address at a specific
    transaction index. If multiple writes occur to the same slot within the
    same transaction (same block_access_index), only the final value is kept.

    Parameters
    ----------
    builder :
        The block access list builder instance.
    address :
        The account address whose storage is being modified.
    slot :
        The storage slot being written to.
    block_access_index :
        The block access index for this change (0 for pre-execution,
        1..n for transactions, n+1 for post-execution).
    new_value :
        The new value being written to the storage slot.

    &quot;&quot;&quot;
    ensure_account(builder, address)

    if slot not in builder.accounts[address].storage_changes:
        builder.accounts[address].storage_changes[slot] = []

    # Check if there's already an entry with the same block_access_index
    # If so, update it with the new value, keeping only the final write
    changes = builder.accounts[address].storage_changes[slot]
    for i, existing_change in enumerate(changes):
        if existing_change.block_access_index == block_access_index:
            # Update the existing entry with the new value
            changes[i] = StorageChange(
                block_access_index=block_access_index, new_value=new_value
            )
            return

    # No existing entry found, append new change
    change = StorageChange(
        block_access_index=block_access_index, new_value=new_value
    )
    builder.accounts[address].storage_changes[slot].append(change)</code></pre>

<h3>Same-Transaction Deduplication</h3>

<strong>Critical behavior</strong>: Multiple writes to the same slot <em>within the same transaction</em> keep only the final value.

<p>Example: <pre><code class="language-python"># TX 3 writes slot 0x01 three times
add_storage_write(builder, addr, slot=0x01, index=3, value=0x100)
add_storage_write(builder, addr, slot=0x01, index=3, value=0x200)
add_storage_write(builder, addr, slot=0x01, index=3, value=0x300)
# Result: only StorageChange(index=3, value=0x300) stored</code></pre></p>

<strong>Why?</strong> The BAL records <em>post-transaction state</em>, not the trace. Intermediate values within a transaction don't matter for state reconstruction.

<h3>Cross-Transaction Preservation</h3>

<p>Different transactions create separate entries: <pre><code class="language-python"># TX 2 and TX 5 both write slot 0x01
add_storage_write(builder, addr, slot=0x01, index=2, value=0xAAA)
add_storage_write(builder, addr, slot=0x01, index=5, value=0xBBB)
# Result: two entries
#   StorageChange(index=2, value=0xAAA)
#   StorageChange(index=5, value=0xBBB)</code></pre></p>

<p>Both are preserved because they represent different states at different block heights (post-TX2, post-TX5).</p>

<h3>Complexity Analysis</h3>

<strong>Worst case</strong>: O(n) where n = number of transactions that touched this slot

<p>The linear scan <code>for i, existing_change in enumerate(changes)</code> looks slow, but: <ul><li>Most slots are written by 1-2 transactions per block</li> <li>Hot slots (like AMM pool reserves) might see ~10-50 writes</li> <li>At 50 writes per slot, linear scan is still fast enough</li> </ul> If this became a bottleneck, the fix would be a dict keyed by <code>block_access_index</code>: <pre><code class="language-python"># Alternative structure (not used)
storage_changes: Dict[U256, Dict[BlockAccessIndex, U256]]</code></pre></p>

<p>EELS prefers the simpler List for readability.</p>

<hr>

<h2>add_storage_read (lines 150-173)</h2>

<pre><code class="language-python">def add_storage_read(
    builder: BlockAccessListBuilder, address: Address, slot: U256
) -&gt; None:
    &quot;&quot;&quot;
    Add a storage read operation to the block access list.

    Records that a storage slot was read during execution. Storage slots
    that are both read and written will only appear in the storage changes
    list, not in the storage reads list, as per [EIP-7928].

    Parameters
    ----------
    builder :
        The block access list builder instance.
    address :
        The account address whose storage is being read.
    slot :
        The storage slot being read.

    [EIP-7928]: https://eips.ethereum.org/EIPS/eip-7928

    &quot;&quot;&quot;
    ensure_account(builder, address)
    builder.accounts[address].storage_reads.add(slot)</code></pre>

<strong>Simplicity</strong>: Just add to a set. No deduplication needed (sets handle it). No transaction index needed (reads don't have per-tx granularity in the BAL).

<h3>Read vs Write Exclusivity</h3>

<p>The docstring notes: "Storage slots that are both read and written will only appear in the storage changes list."</p>

<p>This filtering happens in the <em>build phase</em> (Section 07), not here. During collection, we record both reads and writes. The build phase excludes reads for slots that also have writes.</p>

<strong>Why not filter here?</strong>

<p>Because writes might be reverted. A slot that was written in a failed call still needs to be tracked as a read (the read happened, even though the write didn't persist).</p>

<p>Example: <pre><code class="language-text">SLOAD(slot)    → recorded as read
CALL(...)      → nested call writes slot, then REVERTs
SLOAD(slot)    → slot appears in reads (write was discarded)</code></pre></p>

<hr>

<h2>add_balance_change (lines 175-218)</h2>

<pre><code class="language-python">def add_balance_change(
    builder: BlockAccessListBuilder,
    address: Address,
    block_access_index: BlockAccessIndex,
    post_balance: U256,
) -&gt; None:
    &quot;&quot;&quot;
    Add a balance change to the block access list.

    Records the post-transaction balance for an account after it has been
    modified. This includes changes from transfers, gas fees, block rewards,
    and any other balance-affecting operations.

    Parameters
    ----------
    builder :
        The block access list builder instance.
    address :
        The account address whose balance changed.
    block_access_index :
        The block access index for this change (0 for pre-execution,
        1..n for transactions, n+1 for post-execution).
    post_balance :
        The account balance after the change as U256.

    &quot;&quot;&quot;
    ensure_account(builder, address)

    # Balance value is already U256
    balance_value = post_balance

    # Check if we already have a balance change for this tx_index and update it
    # This ensures we only track the final balance per transaction
    existing_changes = builder.accounts[address].balance_changes
    for i, existing in enumerate(existing_changes):
        if existing.block_access_index == block_access_index:
            # Update the existing balance change with the new balance
            existing_changes[i] = BalanceChange(
                block_access_index=block_access_index,
                post_balance=balance_value,
            )
            return

    # No existing change for this tx_index, add a new one
    change = BalanceChange(
        block_access_index=block_access_index, post_balance=balance_value
    )
    builder.accounts[address].balance_changes.append(change)</code></pre>

<h3>Same-Transaction Deduplication (Again)</h3>

<p>Same pattern as storage writes: multiple balance changes within one transaction → keep only the final value.</p>

<strong>Why does this happen?</strong>

<p>A transaction can modify an account's balance multiple times: <ul><li>Gas deduction at start</li> <li>Value transfer (msg.value)</li> <li>Internal transfers via CALL</li> <li>Gas refund at end</li> <li>Priority fee payment to COINBASE</li> </ul> All of these are "the same transaction" with the same <code>block_access_index</code>. Only the final balance matters.</p>

<h3>Example: COINBASE Balance Tracking</h3>

<p>The block builder (COINBASE) receives fees from every transaction:</p>

<pre><code class="language-python"># TX 1: COINBASE balance → 1.0 ETH
add_balance_change(builder, COINBASE, index=1, post_balance=1e18)
# TX 2: COINBASE balance → 1.5 ETH
add_balance_change(builder, COINBASE, index=2, post_balance=1.5e18)
# TX 3: COINBASE balance → 2.2 ETH
add_balance_change(builder, COINBASE, index=3, post_balance=2.2e18)</code></pre>

<p>Result: 3 separate <code>BalanceChange</code> entries (different indices).</p>

<h3>No Pre-Balance Capture Here</h3>

<p>Note that this function records <em>post-balance</em>, not the delta. Pre-balance capture happens in the state tracker (Section 04) via <code>capture_pre_balance</code>. The builder doesn't need to know the pre-state—it just records what the state tracker tells it.</p>

<hr>

<h2>add_nonce_change (lines 220-262)</h2>

<pre><code class="language-python">def add_nonce_change(
    builder: BlockAccessListBuilder,
    address: Address,
    block_access_index: BlockAccessIndex,
    new_nonce: U64,
) -&gt; None:
    &quot;&quot;&quot;
    Add a nonce change to the block access list.

    Records a nonce increment for an account. This occurs when an EOA sends
    a transaction or when a contract performs [`CREATE`] or [`CREATE2`]
    operations.

    Parameters
    ----------
    builder :
        The block access list builder instance.
    address :
        The account address whose nonce changed.
    block_access_index :
        The block access index for this change (0 for pre-execution,
        1..n for transactions, n+1 for post-execution).
    new_nonce :
        The new nonce value after the change.

    [`CREATE`]: ref:ethereum.forks.amsterdam.vm.instructions.system.create
    [`CREATE2`]: ref:ethereum.forks.amsterdam.vm.instructions.system.create2

    &quot;&quot;&quot;
    ensure_account(builder, address)

    # Check if we already have a nonce change for this tx_index and update it
    # This ensures we only track the final (highest) nonce per transaction
    existing_changes = builder.accounts[address].nonce_changes
    for i, existing in enumerate(existing_changes):
        if existing.block_access_index == block_access_index:
            # Keep the highest nonce value
            if new_nonce &gt; existing.new_nonce:
                existing_changes[i] = NonceChange(
                    block_access_index=block_access_index, new_nonce=new_nonce
                )
            return

    # No existing change for this tx_index, add a new one
    change = NonceChange(
        block_access_index=block_access_index, new_nonce=new_nonce
    )
    builder.accounts[address].nonce_changes.append(change)</code></pre>

<h3>Highest-Nonce-Wins Semantics</h3>

<p>Unlike balance and storage (which keep the <em>last</em> value), nonce keeps the <em>highest</em> value:</p>

<pre><code class="language-python">if new_nonce &gt; existing.new_nonce:
    # Update only if new nonce is higher</code></pre>

<strong>Why?</strong>

<p>Nonces only ever increase. If we see nonce=5 then nonce=3 for the same transaction, something is wrong. By keeping the highest, we're effectively keeping the final state (since nonce can only go up).</p>

<strong>When does a single transaction increment nonce multiple times?</strong>

<p>A factory contract deploying multiple contracts: <pre><code class="language-solidity">contract Factory {
    function deploy() external {
        new Child();  // nonce++ → 1
        new Child();  // nonce++ → 2
        new Child();  // nonce++ → 3
    }
}</code></pre></p>

<p>All three increments happen in the same transaction. We want to record <code>nonce=3</code>, not <code>nonce=1</code>.</p>

<hr>

<h2>add_code_change (lines 264-306)</h2>

<pre><code class="language-python">def add_code_change(
    builder: BlockAccessListBuilder,
    address: Address,
    block_access_index: BlockAccessIndex,
    new_code: Bytes,
) -&gt; None:
    &quot;&quot;&quot;
    Add a code change to the block access list.

    Records contract code deployment or modification. This typically occurs
    during contract creation via [`CREATE`], [`CREATE2`], or [`SETCODE`]
    operations.

    Parameters
    ----------
    builder :
        The block access list builder instance.
    address :
        The account address receiving new code.
    block_access_index :
        The block access index for this change (0 for pre-execution,
        1..n for transactions, n+1 for post-execution).
    new_code :
        The deployed contract bytecode.

    [`CREATE`]: ref:ethereum.forks.amsterdam.vm.instructions.system.create
    [`CREATE2`]: ref:ethereum.forks.amsterdam.vm.instructions.system.create2

    &quot;&quot;&quot;
    ensure_account(builder, address)

    # Check if we already have a code change for this block_access_index
    # This handles the case of in-transaction selfdestructs where code is
    # first deployed and then cleared in the same transaction
    existing_changes = builder.accounts[address].code_changes
    for i, existing in enumerate(existing_changes):
        if existing.block_access_index == block_access_index:
            # Replace the existing code change with the new one
            # For selfdestructs, this ensures we only record the final state (empty code)
            existing_changes[i] = CodeChange(
                block_access_index=block_access_index, new_code=new_code
            )
            return

    # No existing change for this block_access_index, add a new one
    change = CodeChange(
        block_access_index=block_access_index, new_code=new_code
    )
    builder.accounts[address].code_changes.append(change)</code></pre>

<h3>The SELFDESTRUCT Edge Case</h3>

<p>The comment is explicit: <pre><code class="language-python"># This handles the case of in-transaction selfdestructs where code is
# first deployed and then cleared in the same transaction</code></pre></p>

<p>Scenario: <pre><code class="language-solidity">// In the same TX:
// 1. Deploy contract at address X → code = 0x6080...
// 2. Call X.selfdestruct() → code = 0x (empty)</code></pre></p>

<p>Both operations have the same <code>block_access_index</code>. The BAL should record <code>code = 0x</code> (the final state), not <code>code = 0x6080...</code>.</p>

<strong>Last-Write-Wins</strong>: Unlike nonce (highest-wins), code uses last-write-wins. The final code state is what matters.

<h3>SETCODE (EIP-7702)</h3>

<p>The docstring mentions <code>SETCODE</code>. This is the EIP-7702 delegation operation that allows EOAs to temporarily set code. The code change format is:</p>

<pre><code class="language-python"># EIP-7702 delegation code
new_code = b'\xef\x01\x00' + delegate_address  # 23 bytes total</code></pre>

<p>The builder doesn't care about the format—it just records whatever <code>new_code</code> it receives.</p>

<hr>

<h2>add_touched_account (lines 308-334)</h2>

<pre><code class="language-python">def add_touched_account(
    builder: BlockAccessListBuilder, address: Address
) -&gt; None:
    &quot;&quot;&quot;
    Add an account that was accessed but not modified.

    Records that an account was accessed during execution without any state
    changes. This is used for operations like [`EXTCODEHASH`], [`BALANCE`],
    [`EXTCODESIZE`], and [`EXTCODECOPY`] that read account data without
    modifying it.

    Parameters
    ----------
    builder :
        The block access list builder instance.
    address :
        The account address that was accessed.

    [`EXTCODEHASH`] :
        ref:ethereum.forks.amsterdam.vm.instructions.environment.extcodehash
    [`BALANCE`] :
        ref:ethereum.forks.amsterdam.vm.instructions.environment.balance
    [`EXTCODESIZE`] :
        ref:ethereum.forks.amsterdam.vm.instructions.environment.extcodesize
    [`EXTCODECOPY`] :
        ref:ethereum.forks.amsterdam.vm.instructions.environment.extcodecopy

    &quot;&quot;&quot;
    ensure_account(builder, address)</code></pre>

<strong>Simplest function</strong>: Just ensure the account exists. No data to record.

<strong>Why track touched accounts?</strong>

<p>An account that was accessed but not modified still appears in the BAL. This enables: <ul><li><strong>Prefetching</strong>: Clients can load the account's state ahead of execution</li> <li><strong>Proof generation</strong>: State proofs need to include accessed accounts</li> <li><strong>Witness completeness</strong>: Stateless execution needs ALL accessed data</li> </ul> <strong>What operations touch without modifying?</strong></p>

<table><tr><th>Opcode</th><th>Effect</th></tr>
<tr><td><code>BALANCE</code></td><td>Reads balance only</td></tr>
<tr><td><code>EXTCODESIZE</code></td><td>Reads code size only</td></tr>
<tr><td><code>EXTCODEHASH</code></td><td>Reads code hash only</td></tr>
<tr><td><code>EXTCODECOPY</code></td><td>Reads code only</td></tr>
<tr><td><code>CALL</code> (value=0, no storage)</td><td>Touches callee but may not modify</td></tr></table>
<hr>

<h2>Cross-References</h2>

<ul><li><strong>Section 01 (RLP Types)</strong>: The <code>StorageChange</code>, <code>BalanceChange</code>, <code>NonceChange</code>, <code>CodeChange</code> types used here</li>
<li><strong>Section 03-05 (State Tracker)</strong>: The frame-based recording that feeds <code>StateChanges</code> to the builder</li>
<li><strong>Section 07 (Builder Finalization)</strong>: The <code>_build_from_builder</code> and <code>build_block_access_list</code> functions that consume the builder</li>
<li><strong>Section 09 (VM Integration)</strong>: Where the EVM calls these recording functions</li>
</ul>
<hr>

<h2>Gotchas</h2>

<h3>1. Same-Transaction Semantics Vary by Field</h3>

<table><tr><th>Field</th><th>Same-TX Behavior</th><th>Why</th></tr>
<tr><td>Storage</td><td>Last-write-wins</td><td>Final value matters</td></tr>
<tr><td>Balance</td><td>Last-write-wins</td><td>Final value matters</td></tr>
<tr><td>Nonce</td><td>Highest-wins</td><td>Nonces only increase</td></tr>
<tr><td>Code</td><td>Last-write-wins</td><td>Final code matters</td></tr></table>
<h3>2. Reads Are Not Per-Transaction</h3>

<p>Storage reads go into a <code>Set[U256]</code>, not a list of <code>(index, slot)</code> pairs. The BAL doesn't track <em>which</em> transaction read a slot—just that it was read.</p>

<h3>3. Read/Write Filtering Is Deferred</h3>

<p>A slot can be in BOTH <code>storage_reads</code> and <code>storage_changes</code> during collection. The filtering (exclude reads for written slots) happens in the build phase.</p>

<h3>4. AccountData Is Mutable</h3>

<p>Unlike the final <code>AccountChanges</code> (which uses tuples), <code>AccountData</code> uses mutable lists and dicts. This is intentional—collection needs mutation; finalization produces immutable output.</p>

<h3>5. No Validation Here</h3>

<p>The builder doesn't validate: <ul><li>Whether <code>block_access_index</code> is in range</li> <li>Whether <code>new_code</code> fits in MAX_CODE_SIZE</li> <li>Whether the slot/balance/nonce values are valid</li> </ul> Validation happens at higher levels (block processing, RLP encoding).</p>

<h3>6. Empty Accounts Are Still Tracked</h3>

<p>An account touched but never modified results in an <code>AccountData</code> with all-empty collections. This is correct—the address still appears in the final BAL.</p>

<hr>

<h2>Complexity Summary</h2>

<table><tr><th>Function</th><th>Time Complexity</th><th>Space</th></tr>
<tr><td><code>ensure_account</code></td><td>O(1) amortized</td><td>O(1) per new account</td></tr>
<tr><td><code>add_storage_write</code></td><td>O(k) where k = writes to slot</td><td>O(1) per new write</td></tr>
<tr><td><code>add_storage_read</code></td><td>O(1) amortized</td><td>O(1) per new slot</td></tr>
<tr><td><code>add_balance_change</code></td><td>O(t) where t = txs touching account</td><td>O(1) per new tx</td></tr>
<tr><td><code>add_nonce_change</code></td><td>O(t)</td><td>O(1) per new tx</td></tr>
<tr><td><code>add_code_change</code></td><td>O(t)</td><td>O(1) per new tx</td></tr>
<tr><td><code>add_touched_account</code></td><td>O(1) amortized</td><td>O(1) per new account</td></tr></table>
All operations are effectively O(1) for typical blocks (few repeated accesses). The worst case (hot contract accessed by many transactions) is still linear in the number of accessing transactions, which is bounded by MAX_TXS.
</section>

<section id="section-07-bal-builder---finalization">
<h1>Section 07: BAL Builder - Finalization</h1>

<h2>Source Files</h2>
<ul><li><code>specs/execution-specs/src/ethereum/forks/amsterdam/block_access_lists/builder.py</code> (lines 336-475)</li>
</ul>
<h2>Overview</h2>

<p>After block execution completes, the accumulated changes in the builder must be transformed into a deterministic <code>BlockAccessList</code>. This section covers the finalization phase:</p>

<ul><li><strong>Sorting</strong>: All entries are sorted to ensure consensus-critical determinism</li>
<li><strong>Read/Write Filtering</strong>: Slots that were both read and written appear only in writes</li>
<li><strong>Flattening</strong>: The nested <code>AccountData</code> structure becomes flat <code>AccountChanges</code> tuples</li>
<li><strong>Integration</strong>: How <code>StateChanges</code> from the state tracker flows into the builder</li>
</ul>
The finalization is intentionally deferred until after all execution completes. This amortizes the O(n log n) sorting cost over the entire block rather than paying it per-transaction.

<hr>

<h2><code>add_touched_account</code> (lines 336-369)</h2>

<pre><code class="language-python">def add_touched_account(
    builder: BlockAccessListBuilder, address: Address
) -&gt; None:
    &quot;&quot;&quot;
    Add an account that was accessed but not modified.

    Records that an account was accessed during execution without any state
    changes. This is used for operations like [`EXTCODEHASH`], [`BALANCE`],
    [`EXTCODESIZE`], and [`EXTCODECOPY`] that read account data without
    modifying it.

    Parameters
    ----------
    builder :
        The block access list builder instance.
    address :
        The account address that was accessed.

    [`EXTCODEHASH`] :
        ref:ethereum.forks.amsterdam.vm.instructions.environment.extcodehash
    [`BALANCE`] :
        ref:ethereum.forks.amsterdam.vm.instructions.environment.balance
    [`EXTCODESIZE`] :
        ref:ethereum.forks.amsterdam.vm.instructions.environment.extcodesize
    [`EXTCODECOPY`] :
        ref:ethereum.forks.amsterdam.vm.instructions.environment.extcodecopy

    &quot;&quot;&quot;
    ensure_account(builder, address)</code></pre>

<strong>Purpose</strong>: Records address access without any state modification. The simplest recording function—it just ensures the account exists in the builder.

<strong>Why track touched-but-unmodified accounts?</strong>

<p>An account that was accessed but not modified still appears in the BAL. Consider:</p>

<pre><code class="language-python"># TX reads BALANCE of address X
# X's balance doesn't change
# But X must appear in BAL so stateless clients can prefetch X's state</code></pre>

<p>Use cases for touched accounts: <ul><li><strong>Witness generation</strong>: Stateless execution needs all accessed data</li> <li><strong>State prefetching</strong>: Clients can load accounts before replay</li> <li><strong>Access pattern analysis</strong>: Understanding hot accounts without modifying them</li> </ul> <strong>Operations that touch without modifying</strong>:</p>

<table><tr><th>Opcode</th><th>Behavior</th></tr>
<tr><td><code>BALANCE</code></td><td>Reads balance, no write</td></tr>
<tr><td><code>EXTCODESIZE</code></td><td>Reads code length</td></tr>
<tr><td><code>EXTCODEHASH</code></td><td>Reads code hash</td></tr>
<tr><td><code>EXTCODECOPY</code></td><td>Copies code to memory</td></tr>
<tr><td><code>CALL</code> (no effect)</td><td>May touch callee without state change</td></tr></table>
<hr>

<h2><code>_build_from_builder</code> (lines 371-433)</h2>

<p>This is the core finalization function. It transforms the mutable <code>BlockAccessListBuilder</code> into the immutable, sorted <code>BlockAccessList</code>.</p>

<pre><code class="language-python">def _build_from_builder(
    builder: BlockAccessListBuilder,
) -&gt; BlockAccessList:
    &quot;&quot;&quot;
    Build the final [`BlockAccessList`] from a builder (internal helper).

    Constructs a deterministic block access list by sorting all accumulated
    changes. The resulting list is ordered by:

    1. Account addresses (lexicographically)
    2. Within each account:
       - Storage slots (lexicographically)
       - Transaction indices (numerically) for each change type

    Parameters
    ----------
    builder :
        The block access list builder containing all tracked changes.

    Returns
    -------
    block_access_list :
        The final sorted and encoded block access list.

    [`BlockAccessList`]: ref:ethereum.forks.amsterdam.block_access_lists.rlp_types.BlockAccessList

    &quot;&quot;&quot;</code></pre>

<h3>The Sorting Contract</h3>

<p>The docstring specifies a three-level sorting hierarchy:</p>

<pre><code class="language-text">Level 1: Addresses (lexicographic)
    └── Level 2: Storage slots (lexicographic)
            └── Level 3: Transaction indices (numeric)</code></pre>

<p>This ordering is <strong>consensus-critical</strong>. Every client must produce the exact same byte sequence. Different sort orders → different RLP encoding → different hash → consensus failure.</p>

<h3>Implementation Walkthrough</h3>

<h4>Phase 1: Initialize and Iterate</h4>

<pre><code class="language-python">block_access_list: BlockAccessList = []

    for address, changes in builder.accounts.items():</code></pre>

<p>Iteration order of <code>dict.items()</code> is insertion order in Python 3.7+. But insertion order is execution order, which varies by transaction. We can't rely on it—hence the explicit sorting later.</p>

<h4>Phase 2: Process Storage Changes</h4>

<pre><code class="language-python">storage_changes = []
        for slot, slot_changes in changes.storage_changes.items():
            sorted_changes = tuple(
                sorted(slot_changes, key=lambda x: x.block_access_index)
            )
            storage_changes.append(
                SlotChanges(slot=slot, changes=sorted_changes)
            )</code></pre>

<p>For each slot, sort changes by <code>block_access_index</code> (transaction number). This produces entries like:</p>

<pre><code class="language-text">Slot 0x01:
  - TX 2: value = 0xAAA
  - TX 5: value = 0xBBB
  - TX 8: value = 0xCCC</code></pre>

<strong>Why sort by index within each slot?</strong>

<p>The BAL records state evolution. For witness verification, a client needs to: <ul><li>Start with pre-block state</li> <li>Apply TX 2's change</li> <li>Apply TX 5's change</li> <li>Apply TX 8's change</li> <li>Verify post-block state</li> </ul> The order matters for correctness of incremental state proofs.</p>

<h4>Phase 3: Filter and Sort Reads</h4>

<pre><code class="language-python">storage_reads = []
        for slot in changes.storage_reads:
            if slot not in changes.storage_changes:
                storage_reads.append(slot)</code></pre>

<strong>Critical filtering</strong>: A slot that was BOTH read and written appears ONLY in <code>storage_changes</code>, not in <code>storage_reads</code>.

<strong>Why?</strong>

<ul><li><strong>Non-redundancy</strong>: If you have the write history, you implicitly know the slot was accessed</li>
<li><strong>Smaller encoding</strong>: No need to list the slot twice</li>
<li><strong>Spec requirement</strong>: EIP-7928 mandates this behavior</li>
</ul>
Example:
<pre><code class="language-python"># TX flow:
SLOAD(slot)   # recorded as read
SSTORE(slot)  # recorded as write
SLOAD(slot)   # redundant read (already have write)

# Result: slot appears in storage_changes only
# storage_reads does NOT include this slot</code></pre>

<strong>Edge case: Failed inner call</strong>

<pre><code class="language-python"># TX flow:
SLOAD(slot)           # recorded as read
CALL(target) →
    SSTORE(slot)      # recorded as write in child frame
    REVERT            # write discarded, converted to read
# Result: slot appears in storage_reads (write was reverted)</code></pre>

<p>The state tracker (Section 05) handles this via <code>merge_on_failure</code>, converting writes to reads. By the time data reaches the builder, this conversion already happened.</p>

<h4>Phase 4: Sort All Change Lists</h4>

<pre><code class="language-python">balance_changes = tuple(
            sorted(changes.balance_changes, key=lambda x: x.block_access_index)
        )
        nonce_changes = tuple(
            sorted(changes.nonce_changes, key=lambda x: x.block_access_index)
        )
        code_changes = tuple(
            sorted(changes.code_changes, key=lambda x: x.block_access_index)
        )

        storage_changes.sort(key=lambda x: x.slot)
        storage_reads.sort()</code></pre>

<p>Each change type is sorted by its respective ordering key: <ul><li>Changes within a field type: by <code>block_access_index</code> (numeric)</li> <li>Slots: by slot value (lexicographic on U256)</li> <li>Reads: by slot value (lexicographic)</li> </ul> <strong>Why <code>tuple()</code> for inner changes but <code>list.sort()</code> for slots?</strong></p>

<ul><li>Inner changes are small (typically 1-5 entries per slot/field)</li>
<li>Slots can be numerous (DeFi contract might touch 100+ slots)</li>
<li><code>list.sort()</code> is in-place, avoiding allocation</li>
</ul>
<h4>Phase 5: Assemble AccountChanges</h4>

<pre><code class="language-python">account_change = AccountChanges(
            address=address,
            storage_changes=tuple(storage_changes),
            storage_reads=tuple(storage_reads),
            balance_changes=balance_changes,
            nonce_changes=nonce_changes,
            code_changes=code_changes,
        )

        block_access_list.append(account_change)</code></pre>

<p>Everything is converted to <code>tuple</code> for immutability. The <code>AccountChanges</code> dataclass (from <code>rlp_types.py</code>) uses tuples for all collection fields.</p>

<h4>Phase 6: Sort by Address</h4>

<pre><code class="language-python">block_access_list.sort(key=lambda x: x.address)

    return block_access_list</code></pre>

<p>Final sort: order all accounts lexicographically by address. This is the top-level determinism guarantee.</p>

<strong>Address sorting is byte-lexicographic</strong>: Address <code>0x0000...0001</code> comes before <code>0x0000...0002</code>. This is natural Python bytes comparison.

<h3>Complexity Analysis</h3>

<table><tr><th>Operation</th><th>Complexity</th></tr>
<tr><td>Iterate accounts</td><td>O(A) where A = unique addresses</td></tr>
<tr><td>Sort slot changes</td><td>O(S × T log T) where S = slots, T = txs per slot</td></tr>
<tr><td>Filter reads</td><td>O(R) where R = read slots</td></tr>
<tr><td>Sort storage_changes</td><td>O(S log S)</td></tr>
<tr><td>Sort storage_reads</td><td>O(R log R)</td></tr>
<tr><td>Sort balance/nonce/code</td><td>O(T log T) each</td></tr>
<tr><td>Final address sort</td><td>O(A log A)</td></tr></table>
<strong>Total</strong>: O(A × (S log S + T log T)) for typical blocks

<p>For a worst-case block (many accounts, many slots): <ul><li>A = 10,000 addresses</li> <li>S = 10 slots per address average</li> <li>T = 2 txs per slot average</li> </ul> This is ~10,000 × (10 log 10 + 2 log 2) ≈ 350,000 comparisons. Trivial for modern hardware.</p>

<hr>

<h2><code>build_block_access_list</code> (lines 435-475)</h2>

<p>The public entry point. Converts <code>StateChanges</code> from the state tracker into a <code>BlockAccessList</code>.</p>

<pre><code class="language-python">def build_block_access_list(
    state_changes: &quot;StateChanges&quot;,
) -&gt; BlockAccessList:
    &quot;&quot;&quot;
    Build a [`BlockAccessList`] from a StateChanges frame.

    Converts the accumulated state changes from the frame-based architecture
    into the final deterministic BlockAccessList format.

    Parameters
    ----------
    state_changes :
        The block-level StateChanges frame containing all changes from the block.

    Returns
    -------
    block_access_list :
        The final sorted and encoded block access list.

    [`BlockAccessList`]: ref:ethereum.forks.amsterdam.block_access_lists.rlp_types.BlockAccessList
    [`StateChanges`]: ref:ethereum.forks.amsterdam.state_tracker.StateChanges

    &quot;&quot;&quot;</code></pre>

<h3>StateChanges Structure (from state_tracker.py)</h3>

<p>The input <code>StateChanges</code> has this shape after block execution:</p>

<pre><code class="language-python">@dataclass
class StateChanges:
    touched_addresses: Set[Address]
    storage_reads: Set[Tuple[Address, Bytes32]]
    storage_writes: Dict[Tuple[Address, Bytes32, BlockAccessIndex], U256]
    balance_changes: Dict[Tuple[Address, BlockAccessIndex], U256]
    nonce_changes: Set[Tuple[Address, BlockAccessIndex, U64]]
    code_changes: Dict[Tuple[Address, BlockAccessIndex], Bytes]
    # ... pre-state captures (not used in build)</code></pre>

<p>Key observations: <ul><li><strong>Composite keys</strong>: Writes are keyed by <code>(address, slot/field, tx_index)</code></li> <li><strong>Already filtered</strong>: Net-zero changes were removed by <code>filter_net_zero_frame_changes</code> (Section 05)</li> <li><strong>Flat structure</strong>: Frame hierarchy collapsed; this is block-level accumulation</li> </ul> <h3>Implementation Walkthrough</h3></p>

<h4>Step 1: Initialize Builder</h4>

<pre><code class="language-python">builder = BlockAccessListBuilder()</code></pre>

<p>Fresh builder. We don't reuse builders across blocks.</p>

<h4>Step 2: Add Touched Addresses</h4>

<pre><code class="language-python"># Add all touched addresses
    for address in state_changes.touched_addresses:
        add_touched_account(builder, address)</code></pre>

<p>Every address that was accessed (even without modification) gets an entry.</p>

<strong>Order of operations matters</strong>: We add touched addresses first because subsequent <code>add_*</code> calls use <code>ensure_account</code>, which is idempotent. But if we add specific changes first, those addresses would already exist. Either order works; this is just cleaner.

<h4>Step 3: Add Storage Reads</h4>

<pre><code class="language-python"># Add all storage reads
    for address, slot in state_changes.storage_reads:
        add_storage_read(builder, address, U256(int.from_bytes(slot)))</code></pre>

<strong>Type conversion</strong>: <code>slot</code> is <code>Bytes32</code> in the state tracker but <code>U256</code> in the builder. The conversion <code>U256(int.from_bytes(slot))</code> handles this.

<strong>Why different types?</strong>

<ul><li>State tracker uses <code>Bytes32</code> because storage keys are 32-byte hashes</li>
<li>Builder uses <code>U256</code> because that's how slots are encoded in RLP</li>
<li>Both represent the same value, different representations</li>
</ul>
<h4>Step 4: Add Storage Writes</h4>

<pre><code class="language-python"># Add all storage writes
    # Net-zero filtering happens at transaction commit time, not here.
    # At block level, we track ALL writes at their respective indices.
    for (
        address,
        slot,
        block_access_index,
    ), value in state_changes.storage_writes.items():
        u256_slot = U256(int.from_bytes(slot))
        add_storage_write(
            builder, address, u256_slot, block_access_index, value
        )</code></pre>

<strong>Critical comment</strong>: "Net-zero filtering happens at transaction commit time, not here."

<p>The state tracker's <code>filter_net_zero_frame_changes</code> (Section 05) already removed writes where <code>pre_value == post_value</code>. By the time we're here, all remaining writes are actual state changes.</p>

<strong>Why not filter here?</strong>

<ul><li><strong>Separation of concerns</strong>: State tracker knows pre-state; builder doesn't</li>
<li><strong>Performance</strong>: Filter once at commit, not multiple times</li>
<li><strong>Correctness</strong>: Pre-state must be compared at transaction boundary, not block boundary</li>
</ul>
Example of why transaction-level matters:

<pre><code class="language-text">TX 1: slot 0x01: 0 → 5
TX 2: slot 0x01: 5 → 0</code></pre>

<p>Net result: 0 → 0 (no change at block level). But we DO want to record both changes because: <ul><li>Intermediate state (after TX 1) was <code>slot = 5</code></li> <li>This matters for state proofs at different block heights</li> <li>Filtering at block level would incorrectly eliminate both</li> </ul> So we filter at transaction level (TX 1: keep, TX 2: keep because 5 ≠ 0), not block level.</p>

<h4>Step 5: Add Balance Changes</h4>

<pre><code class="language-python"># Add all balance changes (balance_changes is keyed by (address, index))
    for (
        address,
        block_access_index,
    ), new_balance in state_changes.balance_changes.items():
        add_balance_change(builder, address, block_access_index, new_balance)</code></pre>

<p>Balance changes are keyed by <code>(address, block_access_index)</code>. Each transaction that modifies an account's balance gets one entry per transaction.</p>

<strong>Common pattern</strong>: COINBASE has a balance change entry for every transaction (receives priority fees).

<h4>Step 6: Add Nonce Changes</h4>

<pre><code class="language-python"># Add all nonce changes
    for address, block_access_index, new_nonce in state_changes.nonce_changes:
        add_nonce_change(builder, address, block_access_index, new_nonce)</code></pre>

<p>Nonces are stored as a Set of tuples <code>(address, index, new_nonce)</code> rather than a Dict. This is because <code>add_nonce_change</code> uses highest-wins semantics internally.</p>

<strong>Why a Set?</strong>

<p>Multiple nonce changes within a transaction (e.g., CREATE → CREATE → CREATE) would overwrite in a Dict. A Set preserves all observations, letting <code>add_nonce_change</code> pick the highest.</p>

<p>Actually, looking at the code more carefully: the Set design allows multiple <code>(address, index, nonce)</code> tuples where <code>nonce</code> differs. The <code>add_nonce_change</code> function handles deduplication by keeping the highest nonce per <code>(address, index)</code>.</p>

<h4>Step 7: Add Code Changes</h4>

<pre><code class="language-python"># Add all code changes
    # Filtering happens at transaction level in eoa_delegation.py
    for (
        address,
        block_access_index,
    ), new_code in state_changes.code_changes.items():
        add_code_change(builder, address, block_access_index, new_code)</code></pre>

<strong>Comment note</strong>: "Filtering happens at transaction level in eoa_delegation.py"

<p>This refers to EIP-7702 delegation code. When an EOA sets delegation code, certain filtering rules apply: <ul><li>Temporary delegation shouldn't persist</li> <li>Same-transaction removal shouldn't appear in BAL</li> </ul> The <code>eoa_delegation.py</code> module handles these rules before data reaches the state tracker.</p>

<h4>Step 8: Build and Return</h4>

<pre><code class="language-python">return _build_from_builder(builder)</code></pre>

<p>Delegate to the internal helper for sorting and finalization.</p>

<hr>

<h2>Data Flow Summary</h2>

<pre><code class="language-text">┌─────────────────────────────────────────────────────────────────────┐
│                        Block Execution                               │
├─────────────────────────────────────────────────────────────────────┤
│  TX 1 Frame                                                          │
│    ├── SLOAD, SSTORE, CALL...                                       │
│    ├── track_storage_read, track_storage_write                      │
│    └── filter_net_zero_frame_changes → commit_transaction_frame     │
│                                                                      │
│  TX 2 Frame                                                          │
│    ├── ...                                                          │
│    └── filter_net_zero_frame_changes → commit_transaction_frame     │
│                                                                      │
│  ... more transactions ...                                          │
│                                                                      │
│  Block Frame (accumulated StateChanges)                              │
│    ├── touched_addresses: {0xA, 0xB, 0xC}                           │
│    ├── storage_writes: {(0xA, slot, 1): val, (0xB, slot, 2): val}  │
│    └── balance_changes: {(0xA, 1): 100, (0xA, 2): 150}             │
└─────────────────────────────────────────────────────────────────────┘
                                │
                                ▼
┌─────────────────────────────────────────────────────────────────────┐
│                    build_block_access_list                           │
├─────────────────────────────────────────────────────────────────────┤
│  1. Create BlockAccessListBuilder                                    │
│  2. add_touched_account for each address                            │
│  3. add_storage_read for each (addr, slot)                          │
│  4. add_storage_write for each (addr, slot, idx) → value            │
│  5. add_balance_change for each (addr, idx) → balance               │
│  6. add_nonce_change for each (addr, idx, nonce)                    │
│  7. add_code_change for each (addr, idx) → code                     │
└─────────────────────────────────────────────────────────────────────┘
                                │
                                ▼
┌─────────────────────────────────────────────────────────────────────┐
│                      _build_from_builder                             │
├─────────────────────────────────────────────────────────────────────┤
│  For each address in builder.accounts:                               │
│    1. Sort storage changes by slot, then by index                   │
│    2. Filter reads (exclude slots with writes)                       │
│    3. Sort balance/nonce/code changes by index                      │
│    4. Create AccountChanges tuple                                    │
│                                                                      │
│  Sort all AccountChanges by address                                  │
│  Return BlockAccessList                                              │
└─────────────────────────────────────────────────────────────────────┘
                                │
                                ▼
┌─────────────────────────────────────────────────────────────────────┐
│                         BlockAccessList                              │
│   [AccountChanges(0xA, ...), AccountChanges(0xB, ...), ...]         │
│   Deterministically sorted, ready for RLP encoding                   │
└─────────────────────────────────────────────────────────────────────┘</code></pre>

<hr>

<h2>Cross-References</h2>

<table><tr><th>Section</th><th>Relevance</th></tr>
<tr><td><strong>Section 01 (RLP Types)</strong></td><td><code>AccountChanges</code>, <code>SlotChanges</code>, <code>StorageChange</code> types used in output</td></tr>
<tr><td><strong>Section 02 (RLP Utils)</strong></td><td>Encoding functions that consume the <code>BlockAccessList</code></td></tr>
<tr><td><strong>Section 05 (State Tracker Frames)</strong></td><td><code>filter_net_zero_frame_changes</code> that cleans data before build</td></tr>
<tr><td><strong>Section 06 (Builder Construction)</strong></td><td>Recording functions that populate the builder</td></tr>
<tr><td><strong>Section 08 (Block Processing)</strong></td><td>Where <code>build_block_access_list</code> is called and hash is computed</td></tr></table>
<hr>

<h2>Gotchas</h2>

<h3>1. Net-Zero Filtering Already Happened</h3>

<p>Don't expect <code>build_block_access_list</code> to filter net-zero changes. That happened in <code>filter_net_zero_frame_changes</code> at transaction commit time. All data arriving here represents actual state modifications.</p>

<h3>2. Read/Write Filtering Happens in <code>_build_from_builder</code></h3>

<p>The exclusion of reads for written slots is NOT done during recording. It's done during finalization:</p>

<pre><code class="language-python">if slot not in changes.storage_changes:
    storage_reads.append(slot)</code></pre>

<p>This is correct because: <ul><li>Recording doesn't know what will be written later</li> <li>Filtering during finalization sees the complete picture</li> </ul> <h3>3. Type Conversions (Bytes32 ↔ U256)</h3></p>

<p>Storage slots are <code>Bytes32</code> in the state tracker but <code>U256</code> in the builder. The conversion happens in <code>build_block_access_list</code>:</p>

<pre><code class="language-python">u256_slot = U256(int.from_bytes(slot))</code></pre>

<p>Both represent the same 256-bit value. The RLP encoding uses U256's numeric representation.</p>

<h3>4. Sorting Is Consensus-Critical</h3>

<p>Every client MUST produce the exact same sorted order. The sort keys are: <ul><li>Addresses: lexicographic (Python bytes comparison)</li> <li>Slots: numeric (U256 comparison)</li> <li>Indices: numeric (BlockAccessIndex comparison)</li> </ul> Python's <code>sorted()</code> and <code>list.sort()</code> are stable, but stability doesn't matter here—keys are unique at each level.</p>

<h3>5. Empty Accounts Are Preserved</h3>

<p>An account that was touched but has no changes still appears in the BAL:</p>

<pre><code class="language-python">AccountChanges(
    address=0xDEAD...,
    storage_changes=(),
    storage_reads=(),
    balance_changes=(),
    nonce_changes=(),
    code_changes=(),
)</code></pre>

<p>This is intentional—the address was accessed, so it's part of the witness.</p>

<h3>6. BlockAccessIndex 0 Is Pre-Execution</h3>

<p>System calls before transaction execution (e.g., beacon root update) use index 0. Regular transactions use indices 1..n. Post-execution calls use n+1.</p>

<p>The builder doesn't care about this—it just records whatever indices it receives. But the sorting ensures pre-execution changes come first.</p>

<h3>7. Nonce Changes Use Set, Not Dict</h3>

<p>Unlike other changes, <code>nonce_changes</code> is a <code>Set[Tuple[Address, BlockAccessIndex, U64]]</code> not a <code>Dict</code>. This preserves multiple observations of nonce changes within a transaction, allowing <code>add_nonce_change</code> to select the highest.</p>

<hr>

<h2>Performance Considerations</h2>

<h3>Why Defer Sorting?</h3>

<p>Recording during execution is hot path—every SLOAD, SSTORE, balance transfer triggers it. Sorting is expensive (O(n log n)). Deferring sorting to finalization means:</p>

<ul><li>Recording: O(1) amortized (append/set-add)</li>
<li>Finalization: O(n log n) once, after all execution</li>
</ul>
Alternative (sort on insert) would be O(log n) per insert × millions of inserts = much slower.

<h3>Memory Profile</h3>

<p>For a block with: <ul><li>10,000 touched accounts</li> <li>50,000 total storage accesses</li> <li>15,000 balance changes (including COINBASE)</li> </ul> Memory usage: <ul><li>Builder dict overhead: ~1-2 MB</li> <li>AccountData per account: ~600 bytes × 10,000 = ~6 MB</li> <li>Total: ~10-15 MB</li> </ul> This is acceptable for modern clients. The finalization step doesn't allocate additional large structures—it creates tuples from existing data.</p>

<h3>Parallelization Opportunity</h3>

<p>The current implementation is single-threaded. A future optimization could: <ul><li>Shard accounts by address prefix</li> <li>Sort each shard in parallel</li> <li>Merge sorted shards</li> </ul> This would help for blocks with 100k+ touched accounts (extreme DeFi activity).</p>

<hr>

<h2>Testing Considerations</h2>

<h3>Determinism Tests</h3>

<p>The sorting must be deterministic. Test cases should: <ul><li>Build BAL from scrambled input</li> <li>Verify output matches expected sorted order</li> <li>Verify RLP encoding matches expected bytes</li> </ul> <h3>Read/Write Exclusivity Tests</h3></p>

<pre><code class="language-python"># Test: slot written → not in reads
builder.add_storage_read(addr, slot)
builder.add_storage_write(addr, slot, idx, value)
bal = _build_from_builder(builder)
assert slot not in bal[0].storage_reads
assert any(sc.slot == slot for sc in bal[0].storage_changes)</code></pre>

<h3>Empty Account Tests</h3>

<pre><code class="language-python"># Test: touched-only account appears with empty changes
builder.add_touched_account(addr)
bal = _build_from_builder(builder)
assert len(bal) == 1
assert bal[0].address == addr
assert bal[0].storage_changes == ()</code></pre>

<h3>Multi-Transaction Tests</h3>

<pre><code class="language-python"># Test: changes from different TXs are preserved and sorted
builder.add_storage_write(addr, slot, idx=3, value=100)
builder.add_storage_write(addr, slot, idx=1, value=50)
bal = _build_from_builder(builder)
changes = bal[0].storage_changes[0].changes
assert changes[0].block_access_index == 1  # sorted
assert changes[1].block_access_index == 3</code></pre>
</section>

<section id="section-08-block-processing">
<h1>Section 08: Block Processing</h1>

<h2>Source Files</h2>
<ul><li><code>specs/execution-specs/src/ethereum/forks/amsterdam/blocks.py</code> (lines 1-417)</li>
<li><code>specs/execution-specs/src/ethereum/forks/amsterdam/fork.py</code> (lines 207-1180)</li>
<li><code>specs/execution-specs/src/ethereum/forks/amsterdam/vm/__init__.py</code> (lines 36-97)</li>
</ul>
<h2>Overview</h2>

<p>Block processing is where EIP-7928 becomes consensus-critical. This section covers:</p>

<ul><li><strong>Header Extension</strong>: The new <code>block_access_list_hash</code> field in the block header</li>
<li><strong>State Transition</strong>: How blocks are validated, including BAL hash verification</li>
<li><strong>Block Execution</strong>: The <code>apply_body</code> function orchestrating BAL construction</li>
<li><strong>Transaction Processing</strong>: How each transaction contributes to the BAL</li>
<li><strong>Post-Execution Operations</strong>: Withdrawals and system transactions</li>
</ul>
The key insight: the BAL is a <strong>commitment</strong>, not an input. It's computed deterministically from execution and then validated against the header. Any mismatch invalidates the entire block.

<hr>

<h2>Block Header Extension</h2>

<h3><code>Header.block_access_list_hash</code> (blocks.py, lines 234-254)</h3>

<pre><code class="language-python">@slotted_freezable
@dataclass
class Header:
    &quot;&quot;&quot;
    Header portion of a block on the chain, containing metadata and
    cryptographic commitments to the block's contents.
    &quot;&quot;&quot;
    # ... 17 existing fields ...
    
    parent_beacon_block_root: Root
    &quot;&quot;&quot;
    Root hash of the corresponding beacon chain block.
    &quot;&quot;&quot;

    requests_hash: Hash32
    &quot;&quot;&quot;
    [SHA2-256] hash of all the collected requests in this block. Introduced in
    [EIP-7685]. See [`compute_requests_hash`][crh] for more details.
    &quot;&quot;&quot;

    block_access_list_hash: Hash32
    &quot;&quot;&quot;
    [`keccak256`] hash of the Block Access List containing all accounts and
    storage locations accessed during block execution. Introduced in
    [EIP-7928]. See [`compute_block_access_list_hash`][cbalh] for more
    details.

    [`keccak256`]: ref:ethereum.crypto.hash.keccak256
    [EIP-7928]: https://eips.ethereum.org/EIPS/eip-7928
    [cbalh]: ref:ethereum.forks.amsterdam.block_access_lists.rlp_utils.compute_block_access_list_hash
    &quot;&quot;&quot;</code></pre>

<strong>Purpose</strong>: Commits the block to a specific access pattern.

<strong>Why keccak256?</strong>

<p>The BAL hash uses <code>keccak256</code> (not SHA2-256 like <code>requests_hash</code>). This is intentional: <ul><li><strong>Consistency</strong>: keccak256 is the primary hash function in the EL</li> <li><strong>EVM compatibility</strong>: Solidity's <code>keccak256</code> can verify proofs on-chain</li> <li><strong>Legacy alignment</strong>: State roots, transaction roots, receipts root all use keccak256</li> </ul> <strong>Position in Header</strong></p>

<p>The field is added after <code>requests_hash</code> (the EIP-7685 field), maintaining chronological ordering of EIP additions: <ul><li>Pre-merge fields (parent_hash through nonce)</li> <li>EIP-1559: <code>base_fee_per_gas</code></li> <li>EIP-4895: <code>withdrawals_root</code></li> <li>EIP-4844: <code>blob_gas_used</code>, <code>excess_blob_gas</code></li> <li>EIP-4788: <code>parent_beacon_block_root</code></li> <li>EIP-7685: <code>requests_hash</code></li> <li><strong>EIP-7928</strong>: <code>block_access_list_hash</code></li> </ul> <strong>RLP Encoding Implications</strong></p>

<p>Adding a field to the header changes: <ul><li>RLP encoding of headers</li> <li>Block hash computation (<code>keccak256(rlp.encode(header))</code>)</li> <li>All existing tooling that parses headers</li> </ul> This is why the change requires a hard fork—older clients reject blocks with extra header fields.</p>

<hr>

<h2>Block Output Structure</h2>

<h3><code>BlockOutput</code> (vm/__init__.py, lines 56-97)</h3>

<pre><code class="language-python">@dataclass
class BlockOutput:
    &quot;&quot;&quot;
    Output from applying the block body to the present state.

    Contains the following:
    # ... documentation ...
    block_access_list: `BlockAccessList`
        The block access list for the block.
    &quot;&quot;&quot;

    block_gas_used: Uint = Uint(0)
    transactions_trie: Trie[Bytes, Optional[Bytes | LegacyTransaction]] = (
        field(default_factory=lambda: Trie(secured=False, default=None))
    )
    receipts_trie: Trie[Bytes, Optional[Bytes | Receipt]] = field(
        default_factory=lambda: Trie(secured=False, default=None)
    )
    receipt_keys: Tuple[Bytes, ...] = field(default_factory=tuple)
    block_logs: Tuple[Log, ...] = field(default_factory=tuple)
    withdrawals_trie: Trie[Bytes, Optional[Bytes | Withdrawal]] = field(
        default_factory=lambda: Trie(secured=False, default=None)
    )
    blob_gas_used: U64 = U64(0)
    requests: List[Bytes] = field(default_factory=list)
    block_access_list: BlockAccessList = field(default_factory=list)</code></pre>

<strong>Purpose</strong>: Accumulates all outputs from block execution.

<strong>Why <code>BlockAccessList</code> is in <code>BlockOutput</code></strong>:

<p>The BAL is a <strong>derived artifact</strong>, not an input. It's computed as a side effect of execution and then validated. This differs from transaction-level access lists (EIP-2930), which are inputs to execution.</p>

<table><tr><th>Comparison</th><th>TX Access List (EIP-2930)</th><th>Block Access List (EIP-7928)</th></tr>
<tr><td>Direction</td><td>Input</td><td>Output</td></tr>
<tr><td>Purpose</td><td>Warm addresses before execution</td><td>Record all accessed state</td></tr>
<tr><td>Validation</td><td>Pre-execution gas check</td><td>Post-execution hash match</td></tr>
<tr><td>Completeness</td><td>Optional (optimization)</td><td>Complete (all accesses)</td></tr></table>
<hr>

<h2>BlockEnvironment with State Tracking</h2>

<h3><code>BlockEnvironment</code> (vm/__init__.py, lines 36-52)</h3>

<pre><code class="language-python">@dataclass
class BlockEnvironment:
    &quot;&quot;&quot;
    Items external to the virtual machine itself, provided by the environment.
    &quot;&quot;&quot;

    chain_id: U64
    state: State
    block_gas_limit: Uint
    block_hashes: List[Hash32]
    coinbase: Address
    number: Uint
    base_fee_per_gas: Uint
    time: U256
    prev_randao: Bytes32
    excess_blob_gas: U64
    parent_beacon_block_root: Hash32
    state_changes: StateChanges</code></pre>

<strong>Purpose</strong>: Provides block-scoped context for execution.

<strong>The <code>state_changes</code> field</strong>:

<p>This is the <strong>block-level frame</strong> for state tracking. It's initialized in <code>state_transition</code> and passed through all execution:</p>

<pre><code class="language-python"># In state_transition (fork.py line 244)
block_env = vm.BlockEnvironment(
    # ... other fields ...
    state_changes=StateChanges(),  # Fresh block frame
)</code></pre>

<p>Every transaction, system call, and withdrawal operation creates child frames from this root. At the end of execution, <code>build_block_access_list</code> aggregates all recorded changes from this hierarchy.</p>

<hr>

<h2>State Transition Function</h2>

<h3><code>state_transition</code> (fork.py, lines 207-290)</h3>

<p>This is the main entry point for block validation and application.</p>

<pre><code class="language-python">def state_transition(chain: BlockChain, block: Block) -&gt; None:
    &quot;&quot;&quot;
    Attempts to apply a block to an existing block chain.

    All parts of the block's contents need to be verified before being added
    to the chain. Blocks are verified by ensuring that the contents of the
    block make logical sense with the contents of the parent block. The
    information in the block's header must also match the corresponding
    information in the block.
    &quot;&quot;&quot;
    if len(rlp.encode(block)) &gt; MAX_RLP_BLOCK_SIZE:
        raise InvalidBlock(&quot;Block rlp size exceeds MAX_RLP_BLOCK_SIZE&quot;)

    validate_header(chain, block.header)
    if block.ommers != ():
        raise InvalidBlock</code></pre>

<strong>Early Validation</strong>: Before executing anything:
<ul><li>Check RLP size limit (DoS protection)</li>
<li>Validate header consistency (parent hash, timestamps, gas limits)</li>
<li>Reject ommer blocks (post-merge)</li>
</ul>
<pre><code class="language-python">block_env = vm.BlockEnvironment(
        chain_id=chain.chain_id,
        state=chain.state,
        block_gas_limit=block.header.gas_limit,
        block_hashes=get_last_256_block_hashes(chain),
        coinbase=block.header.coinbase,
        number=block.header.number,
        base_fee_per_gas=block.header.base_fee_per_gas,
        time=block.header.timestamp,
        prev_randao=block.header.prev_randao,
        excess_blob_gas=block.header.excess_blob_gas,
        parent_beacon_block_root=block.header.parent_beacon_block_root,
        state_changes=StateChanges(),
    )</code></pre>

<strong>Block Environment Setup</strong>: The fresh <code>StateChanges()</code> is the root of the frame hierarchy for this block. All state changes will be tracked here.

<pre><code class="language-python">block_output = apply_body(
        block_env=block_env,
        transactions=block.transactions,
        withdrawals=block.withdrawals,
    )</code></pre>

<strong>Execute Block Body</strong>: This is where all the actual execution happens. The BAL is constructed as a side effect.

<pre><code class="language-python"># ... compute various roots and hashes ...
    
    computed_block_access_list_hash = compute_block_access_list_hash(
        block_output.block_access_list
    )</code></pre>

<strong>Compute BAL Hash</strong>: After execution, serialize the BAL and hash it.

<pre><code class="language-python"># ... validate gas_used, transactions_root, state_root, etc. ...
    
    if computed_block_access_list_hash != block.header.block_access_list_hash:
        raise InvalidBlock(&quot;Invalid block access list hash&quot;)</code></pre>

<strong>The Critical Check</strong>: If the computed BAL hash doesn't match the header, the block is invalid. This makes the BAL consensus-critical.

<strong>Why this ordering matters</strong>:

<p>The BAL hash is checked <em>after</em> state root and other validations. This isn't arbitrary: <ul><li>If state root is wrong, the block is invalid regardless of BAL</li> <li>If BAL is wrong but state root is correct, it's a commitment failure</li> <li>Checking BAL after state root makes debugging easier</li> </ul> <strong>Cross-reference</strong>: See Section 02 (<code>compute_block_access_list_hash</code>) for hash computation details.</p>

<hr>

<h2>Block Body Execution</h2>

<h3><code>apply_body</code> (fork.py, lines 770-838)</h3>

<p>This function orchestrates the entire block execution.</p>

<pre><code class="language-python">def apply_body(
    block_env: vm.BlockEnvironment,
    transactions: Tuple[LegacyTransaction | Bytes, ...],
    withdrawals: Tuple[Withdrawal, ...],
) -&gt; vm.BlockOutput:
    &quot;&quot;&quot;
    Executes a block.

    Many of the contents of a block are stored in data structures called
    tries. There is a transactions trie which is similar to a ledger of the
    transactions stored in the current block. There is also a receipts trie
    which stores the results of executing a transaction, like the post state
    and gas used. This function creates and executes the block that is to be
    added to the chain.
    &quot;&quot;&quot;
    block_output = vm.BlockOutput()

    # EIP-7928: System contracts use block_access_index 0
    # The block frame already starts at index 0, so system transactions
    # naturally use that index through the block frame</code></pre>

<strong>Index 0 for System Transactions</strong>: Pre-execution system calls (beacon roots, history storage) run at <code>block_access_index = 0</code>. This is before any user transactions.

<pre><code class="language-python">process_unchecked_system_transaction(
        block_env=block_env,
        target_address=BEACON_ROOTS_ADDRESS,
        data=block_env.parent_beacon_block_root,
    )

    process_unchecked_system_transaction(
        block_env=block_env,
        target_address=HISTORY_STORAGE_ADDRESS,
        data=block_env.block_hashes[-1],  # The parent hash
    )</code></pre>

<strong>Pre-Execution System Calls</strong>: These are required by:
<ul><li>EIP-4788: Beacon block roots in the EVM</li>
<li>EIP-2935: Historical block hashes</li>
</ul>
Both modify state and contribute to the BAL at index 0.

<pre><code class="language-python">for i, tx in enumerate(map(decode_transaction, transactions)):
        process_transaction(block_env, block_output, tx, Uint(i))</code></pre>

<strong>User Transactions</strong>: Each transaction gets its own frame. The index passed here becomes the <code>block_access_index</code> via <code>increment_block_access_index</code>.

<pre><code class="language-python"># EIP-7928: Increment block frame to post-execution index
    # After N transactions, block frame is at index N
    # Post-execution operations (withdrawals, etc.) use index N+1
    increment_block_access_index(block_env.state_changes)</code></pre>

<strong>Post-Execution Index</strong>: After all N transactions, the index is incremented to N+1 for withdrawals and other post-tx operations. This ensures proper attribution.

<table><tr><th>Phase</th><th>Index</th><th>Operations</th></tr>
<tr><td>Pre-execution</td><td>0</td><td>Beacon roots, history storage</td></tr>
<tr><td>Transaction i</td><td>i+1</td><td>User transaction (0-indexed → 1-indexed in BAL)</td></tr>
<tr><td>Post-execution</td><td>N+1</td><td>Withdrawals, consolidation requests</td></tr></table>
<strong>Wait, there's an offset?</strong> Yes! System transactions run at index 0, but user transaction indices are 0-based in the block. So transaction 0 runs at <code>block_access_index = 1</code>. This is handled by <code>increment_block_access_index</code> being called at the <em>start</em> of <code>process_transaction</code>.

<pre><code class="language-python">process_withdrawals(block_env, block_output, withdrawals)

    process_general_purpose_requests(
        block_env=block_env,
        block_output=block_output,
    )</code></pre>

<strong>Post-Transaction Operations</strong>: Both withdrawals and requests (EIP-7685) run at index N+1.

<pre><code class="language-python"># Build block access list from block_env.state_changes
    block_output.block_access_list = build_block_access_list(
        block_env.state_changes
    )

    return block_output</code></pre>

<strong>Finalization</strong>: Call the builder to convert <code>StateChanges</code> into the final <code>BlockAccessList</code>.

<strong>Cross-reference</strong>: See Section 06-07 for <code>build_block_access_list</code> implementation.

<hr>

<h2>Transaction Processing</h2>

<h3><code>process_transaction</code> (fork.py, lines 880-1080)</h3>

<p>This is where most BAL entries originate.</p>

<pre><code class="language-python">def process_transaction(
    block_env: vm.BlockEnvironment,
    block_output: vm.BlockOutput,
    tx: Transaction,
    index: Uint,
) -&gt; None:
    &quot;&quot;&quot;
    Execute a transaction against the provided environment.

    This function processes the actions needed to execute a transaction.
    It decrements the sender's account balance after calculating the gas fee
    and refunds them the proper amount after execution.
    &quot;&quot;&quot;
    # EIP-7928: Create a transaction-level StateChanges frame
    # The frame will read the current block_access_index from the block frame
    increment_block_access_index(block_env.state_changes)
    tx_state_changes = create_child_frame(block_env.state_changes)</code></pre>

<strong>Frame Creation</strong>:
<ul><li>Increment the block's access index (for attribution)</li>
<li>Create a child frame that inherits the current index</li>
</ul>
<strong>Why increment first?</strong> Consider transaction 0:
<ul><li><code>increment_block_access_index</code> moves from 0 → 1</li>
<li>Child frame inherits index 1</li>
<li>Transaction 0's changes are attributed to index 1</li>
</ul>
This leaves index 0 for system transactions.

<pre><code class="language-python"># Capture coinbase pre-balance for net-zero filtering
    coinbase_pre_balance = get_account(
        block_env.state, block_env.coinbase
    ).balance
    track_address(tx_state_changes, block_env.coinbase)
    capture_pre_balance(
        tx_state_changes, block_env.coinbase, coinbase_pre_balance
    )</code></pre>

<strong>Pre-State Capture for Coinbase</strong>:

<p>The coinbase receives priority fees. To detect net-zero changes (e.g., coinbase sends a transaction and pays fees equal to what it receives), we must capture pre-balance.</p>

<strong>Example scenario</strong>:
<pre><code class="language-text">Coinbase balance: 10 ETH
Coinbase sends TX, pays 1 ETH in gas
TX tips coinbase 1 ETH
Final balance: 10 ETH (net-zero!)</code></pre>

<p>Without pre-balance capture, we'd record coinbase as modified. With it, the net-zero filter removes coinbase from BAL.</p>

<pre><code class="language-python"># ... transaction validation and gas accounting ...
    
    # Track sender nonce increment
    increment_nonce(block_env.state, sender)
    sender_nonce_after = get_account(block_env.state, sender).nonce
    track_nonce_change(tx_state_changes, sender, U64(sender_nonce_after))</code></pre>

<strong>Nonce Tracking</strong>: Every transaction increments sender nonce. This is recorded explicitly.

<pre><code class="language-python"># Track sender balance deduction for gas fee
    sender_balance_before = get_account(block_env.state, sender).balance
    track_address(tx_state_changes, sender)
    capture_pre_balance(tx_state_changes, sender, sender_balance_before)

    sender_balance_after_gas_fee = (
        Uint(sender_account.balance) - effective_gas_fee - blob_gas_fee
    )
    set_account_balance(
        block_env.state, sender, U256(sender_balance_after_gas_fee)
    )
    track_balance_change(
        tx_state_changes,
        sender,
        U256(sender_balance_after_gas_fee),
    )</code></pre>

<strong>Gas Fee Deduction</strong>:
<ul><li>Capture sender's pre-balance</li>
<li>Deduct gas fee from balance</li>
<li>Track the new balance</li>
</ul>
The pre-balance capture enables net-zero detection for self-pays (sender pays gas but receives value equal to gas).

<pre><code class="language-python"># ... create tx_env and message, execute ...
    
    tx_output = process_message_call(message)</code></pre>

<strong>EVM Execution</strong>: This is where the bulk of state changes happen. The <code>message</code> carries a call-level frame that's a child of <code>tx_state_changes</code>.

<strong>Cross-reference</strong>: See Section 09 for VM integration details.

<pre><code class="language-python"># ... gas refund calculation ...
    
    # refund gas
    sender_balance_after_refund = get_account(
        block_env.state, sender
    ).balance + U256(gas_refund_amount)
    set_account_balance(block_env.state, sender, sender_balance_after_refund)
    track_balance_change(
        tx_env.state_changes,
        sender,
        sender_balance_after_refund,
    )

    coinbase_balance_after_mining_fee = get_account(
        block_env.state, block_env.coinbase
    ).balance + U256(transaction_fee)

    set_account_balance(
        block_env.state, block_env.coinbase, coinbase_balance_after_mining_fee
    )
    track_balance_change(
        tx_env.state_changes,
        block_env.coinbase,
        coinbase_balance_after_mining_fee,
    )</code></pre>

<strong>Post-Execution Tracking</strong>:
<ul><li>Track gas refund to sender</li>
<li>Track priority fee to coinbase</li>
</ul>
These are explicit balance changes outside the EVM proper.

<pre><code class="language-python">for address in tx_output.accounts_to_delete:
        destroy_account(block_env.state, address)
        track_selfdestruct(tx_env.state_changes, address)

    # EIP-7928: Commit transaction frame (includes net-zero filtering).
    # Must happen AFTER destroy_account so filtering sees correct state.
    commit_transaction_frame(tx_env.state_changes)</code></pre>

<strong>Frame Commit</strong>:
<ul><li>Process <code>SELFDESTRUCT</code> accounts (deprecated but still tracked)</li>
<li>Commit the transaction frame to the block frame</li>
</ul>
<strong>Order matters</strong>: <code>commit_transaction_frame</code> includes net-zero filtering. If we committed before <code>destroy_account</code>, we'd see the pre-destruction balance as "unchanged" and filter it out incorrectly.

<hr>

<h2>Withdrawal Processing</h2>

<h3><code>process_withdrawals</code> (fork.py, lines 1083-1122)</h3>

<p>Withdrawals are post-transaction balance credits from the consensus layer.</p>

<pre><code class="language-python">def process_withdrawals(
    block_env: vm.BlockEnvironment,
    block_output: vm.BlockOutput,
    withdrawals: Tuple[Withdrawal, ...],
) -&gt; None:
    &quot;&quot;&quot;
    Increase the balance of the withdrawing account.
    &quot;&quot;&quot;
    # Capture pre-state for withdrawal balance filtering
    withdrawal_addresses = {wd.address for wd in withdrawals}
    for address in withdrawal_addresses:
        pre_balance = get_account(block_env.state, address).balance
        track_address(block_env.state_changes, address)
        capture_pre_balance(block_env.state_changes, address, pre_balance)</code></pre>

<strong>Pre-State Capture</strong>:

<p>Why capture all addresses before processing any? Consider: <pre><code class="language-text">Withdrawal 1: 1 ETH to address A
Withdrawal 2: 1 ETH to address A</code></pre></p>

<p>If we captured A's balance before withdrawal 1, then processed it, then captured before withdrawal 2, we'd capture the <em>intermediate</em> balance, not the <em>pre-block</em> balance. By gathering all addresses first, we capture true pre-state.</p>

<pre><code class="language-python">def increase_recipient_balance(recipient: Account) -&gt; None:
        recipient.balance += wd.amount * U256(10**9)

    for i, wd in enumerate(withdrawals):
        trie_set(
            block_output.withdrawals_trie,
            rlp.encode(Uint(i)),
            rlp.encode(wd),
        )

        modify_state(block_env.state, wd.address, increase_recipient_balance)

        new_balance = get_account(block_env.state, wd.address).balance
        track_balance_change(
            block_env.state_changes,
            wd.address,
            new_balance,
        )</code></pre>

<strong>Balance Credit</strong>: Withdrawal amounts are in Gwei; multiply by 10^9 for Wei.

<pre><code class="language-python">if account_exists_and_is_empty(block_env.state, wd.address):
            destroy_account(block_env.state, wd.address)

    # EIP-7928: Filter net-zero balance changes for withdrawals
    filter_net_zero_frame_changes(block_env.state_changes)</code></pre>

<strong>Net-Zero Filtering</strong>: Called on the <em>block</em> frame directly (not a child frame). This handles the case where withdrawals net to zero, though this is rare in practice.

<strong>Difference from transaction commits</strong>: Transactions use <code>commit_transaction_frame</code> which merges and filters. Withdrawals use <code>filter_net_zero_frame_changes</code> directly because they operate on the block frame.

<hr>

<h2>System Transaction Processing</h2>

<h3><code>process_system_transaction</code> (fork.py, lines 610-680)</h3>

<p>System transactions are internal calls that don't originate from a user signature.</p>

<pre><code class="language-python">def process_system_transaction(
    block_env: vm.BlockEnvironment,
    target_address: Address,
    system_contract_code: Bytes,
    data: Bytes,
) -&gt; MessageCallOutput:
    &quot;&quot;&quot;
    Process a system transaction with the given code.
    &quot;&quot;&quot;
    # EIP-7928: Create a child frame for system transaction
    # This allows proper pre-state capture for net-zero filtering
    system_tx_state_changes = create_child_frame(block_env.state_changes)</code></pre>

<strong>Child Frame for System TX</strong>: Even system transactions get their own frame. This ensures:
<ul><li>Changes are attributed to the correct index (0 for pre-execution)</li>
<li>Net-zero filtering works within each system call</li>
</ul>
<pre><code class="language-python">tx_env = vm.TransactionEnvironment(
        origin=SYSTEM_ADDRESS,
        gas_price=block_env.base_fee_per_gas,
        gas=SYSTEM_TRANSACTION_GAS,
        access_list_addresses=set(),
        access_list_storage_keys=set(),
        transient_storage=TransientStorage(),
        blob_versioned_hashes=(),
        authorizations=(),
        index_in_block=None,
        tx_hash=None,
        state_changes=system_tx_state_changes,
    )</code></pre>

<strong>System Address</strong>: <code>0xfffffffffffffffffffffffffffffffffffffffe</code> — a special address that cannot have a private key (reserved address space).

<strong>Unlimited Gas</strong>: <code>SYSTEM_TRANSACTION_GAS = 30_000_000</code> — enough for any system call.

<strong>No index or hash</strong>: System transactions aren't user-visible transactions; they have <code>None</code> for index and hash.

<pre><code class="language-python"># Create call frame as child of tx frame
    call_frame = create_child_frame(tx_env.state_changes)

    system_tx_message = Message(
        # ... populate message fields ...
        state_changes=call_frame,
    )

    system_tx_output = process_message_call(system_tx_message)

    # Commit system transaction changes to block frame
    # System transactions always succeed (or block is invalid)
    commit_transaction_frame(tx_env.state_changes)

    return system_tx_output</code></pre>

<strong>Always Commit</strong>: System transactions always commit (unchecked) or raise <code>InvalidBlock</code> (checked). There's no rollback path within a single system call.

<hr>

<h2>Validation Sequence Summary</h2>

<p>The complete validation flow:</p>

<pre><code class="language-text">1. validate_header(chain, block.header)
   ├── Check parent hash
   ├── Check timestamps
   ├── Check gas limits
   ├── Check excess_blob_gas
   └── Check base_fee_per_gas

2. apply_body(block_env, transactions, withdrawals)
   ├── System transactions (index 0)
   │   ├── Beacon roots contract
   │   └── History storage contract
   ├── User transactions (indices 1..N)
   │   └── Each creates/commits transaction frame
   ├── Withdrawals (index N+1)
   └── Requests (index N+1)

3. Compute derived values
   ├── block_state_root
   ├── transactions_root
   ├── receipt_root
   ├── withdrawals_root
   ├── requests_hash
   └── computed_block_access_list_hash ← NEW

4. Validate commitments
   ├── gas_used == header.gas_used
   ├── transactions_root == header.transactions_root
   ├── state_root == header.state_root
   ├── receipt_root == header.receipt_root
   ├── bloom == header.bloom
   ├── withdrawals_root == header.withdrawals_root
   ├── blob_gas_used == header.blob_gas_used
   ├── requests_hash == header.requests_hash
   └── block_access_list_hash == header.block_access_list_hash ← NEW

5. If all valid: chain.blocks.append(block)</code></pre>

<hr>

<h2>Gotchas and Edge Cases</h2>

<h3>Index Attribution</h3>

<strong>Gotcha</strong>: User transaction 0 uses <code>block_access_index = 1</code>, not 0.

<p>The <code>increment_block_access_index</code> call at the start of <code>process_transaction</code> increments from 0 to 1 before the first user transaction. Index 0 is reserved for system transactions.</p>

<h3>Coinbase Edge Cases</h3>

<strong>Edge Case 1</strong>: Coinbase is the sender.
<ul><li>Pre-balance captured for gas deduction</li>
<li>Priority fee added back to coinbase</li>
<li>Net effect may be zero (no BAL entry)</li>
</ul>
<strong>Edge Case 2</strong>: Coinbase doesn't exist.
<ul><li>If coinbase receives zero fees and is empty, it's destroyed</li>
<li><code>account_exists_and_is_empty</code> check handles this</li>
</ul>
<h3>Withdrawal Batching</h3>

<strong>Gotcha</strong>: Multiple withdrawals to same address use single pre-balance capture.

<pre><code class="language-python">withdrawal_addresses = {wd.address for wd in withdrawals}
for address in withdrawal_addresses:
    pre_balance = get_account(...)</code></pre>

<p>The set deduplication ensures we capture pre-state once, not per-withdrawal.</p>

<h3>System Transaction Failures</h3>

<strong>Checked vs. Unchecked</strong>:
<ul><li><code>process_unchecked_system_transaction</code>: Returns output even if execution fails</li>
<li><code>process_checked_system_transaction</code>: Raises <code>InvalidBlock</code> on failure</li>
</ul>
Beacon roots and history storage are unchecked (empty code is OK early in the chain). Withdrawal and consolidation requests are checked.

<hr>

<h2>Cross-References</h2>

<table><tr><th>Topic</th><th>Section</th></tr>
<tr><td>StateChanges data structure</td><td>Section 03</td></tr>
<tr><td>Frame management (create/commit)</td><td>Section 05</td></tr>
<tr><td>Builder construction</td><td>Section 06</td></tr>
<tr><td>Builder finalization</td><td>Section 07</td></tr>
<tr><td>VM integration</td><td>Section 09</td></tr>
<tr><td>Hash computation</td><td>Section 02</td></tr></table>
<hr>

<h2>Implementation Notes</h2>

<h3>Why the BAL is Validated Last</h3>

<p>The <code>InvalidBlock</code> exception for BAL mismatch is thrown after all other validations. This ordering: <ul><li>Ensures state root correctness before BAL check</li> <li>Makes debugging easier (wrong state → wrong BAL)</li> <li>Matches logical dependency (BAL depends on execution)</li> </ul> <h3>Performance Characteristics</h3></p>

<p>BAL construction happens during execution (amortized). The final hash is O(n) where n is BAL size. For a 30M gas block with typical transactions: <ul><li>~100-200 accounts modified</li> <li>~500-1000 storage slots modified</li> <li>BAL size: 10-50 KB typically</li> <li>Hash time: <1ms</li> </ul> <h3>Determinism Requirements</h3></p>

<p>Every operation must produce identical results across clients: <ul><li><strong>Sorting</strong>: Lexicographic by bytes (not numeric interpretation)</li> <li><strong>RLP encoding</strong>: Canonical form (no leading zeros except required)</li> <li><strong>Hash function</strong>: keccak256 (as implemented in every client)</li> </ul> Non-determinism in any step would cause consensus failures.</p>
</section>

<section id="section-09-vm-integration">
<h1>Section 09: VM Integration</h1>

<h2>Source Files</h2>
<ul><li><code>specs/execution-specs/src/ethereum/forks/amsterdam/vm/__init__.py</code> (lines 1-201)</li>
<li><code>specs/execution-specs/src/ethereum/forks/amsterdam/vm/interpreter.py</code> (lines 1-370)</li>
<li><code>specs/execution-specs/src/ethereum/forks/amsterdam/vm/instructions/storage.py</code> (lines 1-166)</li>
<li><code>specs/execution-specs/src/ethereum/forks/amsterdam/vm/instructions/environment.py</code> (lines 1-451)</li>
<li><code>specs/execution-specs/src/ethereum/forks/amsterdam/vm/instructions/system.py</code> (lines 1-670)</li>
<li><code>specs/execution-specs/src/ethereum/forks/amsterdam/state_tracker.py</code> (frame management functions)</li>
</ul>
<h2>Overview</h2>

<p>VM integration is where EIP-7928's state tracking actually happens. This section covers:</p>

<ul><li><strong>State Changes Threading</strong>: How <code>StateChanges</code> flows through Message → Evm → Instructions</li>
<li><strong>Evm Class Extension</strong>: The new <code>state_changes</code> field in the EVM dataclass</li>
<li><strong>Instruction-Level Hooks</strong>: Which opcodes trigger which tracking functions</li>
<li><strong>Child Frame Management</strong>: How CALL/CREATE spawn child frames and merge results</li>
<li><strong>Interpreter Hooks</strong>: Where the interpreter calls tracking functions for value transfers</li>
</ul>
The key architectural decision: tracking happens at the <strong>instruction level</strong>, not the state layer. This ensures all accesses are captured regardless of whether they modify state.

<hr>

<h2>State Changes Threading</h2>

<h3>Architecture Overview</h3>

<p>State tracking flows through three layers:</p>

<pre><code class="language-text">BlockEnvironment.state_changes (block frame)
         ↓
TransactionEnvironment.state_changes (tx frame)
         ↓
Message.state_changes → Evm.state_changes (call frames)</code></pre>

<p>Each layer holds a <code>StateChanges</code> instance linked to its parent. This mirrors EVM execution semantics: a CALL can revert without affecting the parent's state changes.</p>

<h3><code>BlockEnvironment.state_changes</code> (vm/__init__.py, lines 36-52)</h3>

<pre><code class="language-python">@dataclass
class BlockEnvironment:
    &quot;&quot;&quot;
    Items external to the virtual machine itself, provided by the environment.
    &quot;&quot;&quot;

    chain_id: U64
    state: State
    block_gas_limit: Uint
    block_hashes: List[Hash32]
    coinbase: Address
    number: Uint
    base_fee_per_gas: Uint
    time: U256
    prev_randao: Bytes32
    excess_blob_gas: U64
    parent_beacon_block_root: Hash32
    state_changes: StateChanges</code></pre>

<strong>Purpose</strong>: The block-level frame. Created in <code>apply_body()</code> before any transactions execute.

<strong>Why here, not State?</strong>

<code>State</code> is the canonical trie—it shouldn't know about access tracking. <code>BlockEnvironment</code> is the execution context, making it the natural home for execution-scoped metadata.

<h3><code>TransactionEnvironment.state_changes</code> (vm/__init__.py, lines 92-107)</h3>

<pre><code class="language-python">@dataclass
class TransactionEnvironment:
    &quot;&quot;&quot;
    Items that are used by contract creation or message call.
    &quot;&quot;&quot;

    origin: Address
    gas_price: Uint
    gas: Uint
    access_list_addresses: Set[Address]
    access_list_storage_keys: Set[Tuple[Address, Bytes32]]
    transient_storage: TransientStorage
    blob_versioned_hashes: Tuple[VersionedHash, ...]
    authorizations: Tuple[Authorization, ...]
    index_in_block: Optional[Uint]
    tx_hash: Optional[Hash32]
    state_changes: &quot;StateChanges&quot; = field(default_factory=StateChanges)</code></pre>

<strong>Purpose</strong>: The transaction-level frame. This is where pre-state captures happen (see Section 04).

<strong>Key insight</strong>: Pre-values (<code>pre_balances</code>, <code>pre_storage</code>, <code>pre_code</code>) are stored at the tx frame level, not deeper. This ensures first-write-wins semantics across the entire transaction.

<h3><code>Message.state_changes</code> (vm/__init__.py, lines 110-134)</h3>

<pre><code class="language-python">@dataclass
class Message:
    &quot;&quot;&quot;
    Items that are used by contract creation or message call.
    &quot;&quot;&quot;

    block_env: BlockEnvironment
    tx_env: TransactionEnvironment
    caller: Address
    target: Bytes0 | Address
    current_target: Address
    gas: Uint
    value: U256
    data: Bytes
    code_address: Optional[Address]
    code: Bytes
    depth: Uint
    should_transfer_value: bool
    is_static: bool
    accessed_addresses: Set[Address]
    accessed_storage_keys: Set[Tuple[Address, Bytes32]]
    disable_precompiles: bool
    parent_evm: Optional[&quot;Evm&quot;]
    is_create: bool
    state_changes: &quot;StateChanges&quot; = field(default_factory=StateChanges)</code></pre>

<strong>Purpose</strong>: Carries the state changes frame into the EVM. For the top-level call, this is the tx frame. For nested calls, it's a child frame created via <code>create_child_frame()</code>.

<strong>Three state_changes references in Message</strong>:

<ul><li><code>message.state_changes</code> — the current call's frame</li>
<li><code>message.tx_env.state_changes</code> — the transaction frame (for pre-captures)</li>
<li><code>message.block_env.state_changes</code> — the block frame (root)</li>
</ul>
Instructions use <code>evm.state_changes</code> for tracking, but pre-capture functions need access to <code>tx_env.state_changes</code> because pre-values are tx-scoped.

<hr>

<h2>Evm Class Extension</h2>

<h3><code>Evm.state_changes</code> (vm/__init__.py, lines 137-157)</h3>

<pre><code class="language-python">@dataclass
class Evm:
    &quot;&quot;&quot;The internal state of the virtual machine.&quot;&quot;&quot;

    pc: Uint
    stack: List[U256]
    memory: bytearray
    code: Bytes
    gas_left: Uint
    valid_jump_destinations: Set[Uint]
    logs: Tuple[Log, ...]
    refund_counter: int
    running: bool
    message: Message
    output: Bytes
    accounts_to_delete: Set[Address]
    return_data: Bytes
    error: Optional[EthereumException]
    accessed_addresses: Set[Address]
    accessed_storage_keys: Set[Tuple[Address, Bytes32]]
    state_changes: StateChanges</code></pre>

<strong>Purpose</strong>: The EVM frame's state changes tracker. Instructions read from and write to this.

<strong>Why separate from Message?</strong>

<p>The <code>Evm</code> is the execution state; <code>Message</code> is the input parameters. By copying <code>state_changes</code> to <code>Evm</code>, instructions don't need to traverse <code>evm.message.state_changes</code> on every access.</p>

<strong>Initialization in <code>process_message()</code></strong> (interpreter.py, lines 243-273):

<pre><code class="language-python">def process_message(message: Message) -&gt; Evm:
    &quot;&quot;&quot;
    Move ether and execute the relevant code.
    &quot;&quot;&quot;
    state = message.block_env.state
    transient_storage = message.tx_env.transient_storage
    if message.depth &gt; STACK_DEPTH_LIMIT:
        raise StackDepthLimitError(&quot;Stack depth limit reached&quot;)

    code = message.code
    valid_jump_destinations = get_valid_jump_destinations(code)
    evm = Evm(
        pc=Uint(0),
        stack=[],
        memory=bytearray(),
        code=code,
        gas_left=message.gas,
        valid_jump_destinations=valid_jump_destinations,
        logs=(),
        refund_counter=0,
        running=True,
        message=message,
        output=b&quot;&quot;,
        accounts_to_delete=set(),
        return_data=b&quot;&quot;,
        error=None,
        accessed_addresses=message.accessed_addresses,
        accessed_storage_keys=message.accessed_storage_keys,
        state_changes=message.state_changes,  # &lt;-- Copy from message
    )</code></pre>

<p>The <code>state_changes</code> is copied from the message, establishing the frame hierarchy.</p>

<hr>

<h2>Instruction-Level Tracking</h2>

<h3>Storage Instructions (storage.py)</h3>

<h4><code>sload</code> (lines 24-54)</h4>

<pre><code class="language-python">def sload(evm: Evm) -&gt; None:
    &quot;&quot;&quot;
    Loads to the stack, the value corresponding to a certain key from the
    storage of the current account.
    &quot;&quot;&quot;
    # STACK
    key = pop(evm.stack).to_be_bytes32()

    # GAS
    if (evm.message.current_target, key) in evm.accessed_storage_keys:
        charge_gas(evm, GAS_WARM_ACCESS)
    else:
        evm.accessed_storage_keys.add((evm.message.current_target, key))
        charge_gas(evm, GAS_COLD_SLOAD)

    # OPERATION
    value = get_storage(
        evm.message.block_env.state, evm.message.current_target, key
    )
    track_storage_read(
        evm.state_changes,
        evm.message.current_target,
        key,
    )

    push(evm.stack, value)

    # PROGRAM COUNTER
    evm.pc += Uint(1)</code></pre>

<strong>Tracking point</strong>: After gas charging, before stack push. The <code>track_storage_read()</code> call records the slot access.

<strong>Why track reads?</strong>

<p>Reads prove which slots existed in pre-state. For stateless execution, the witness must include values for all read slots, even if unchanged.</p>

<h4><code>sstore</code> (lines 57-133)</h4>

<pre><code class="language-python">def sstore(evm: Evm) -&gt; None:
    &quot;&quot;&quot;
    Stores a value at a certain key in the current context's storage.
    &quot;&quot;&quot;
    if evm.message.is_static:
        raise WriteInStaticContext

    # STACK
    key = pop(evm.stack).to_be_bytes32()
    new_value = pop(evm.stack)

    # check we have at least the stipend gas
    check_gas(evm, GAS_CALL_STIPEND + Uint(1))

    state = evm.message.block_env.state
    original_value = get_storage_original(
        state, evm.message.current_target, key
    )
    current_value = get_storage(state, evm.message.current_target, key)

    gas_cost = Uint(0)

    if (evm.message.current_target, key) not in evm.accessed_storage_keys:
        evm.accessed_storage_keys.add((evm.message.current_target, key))
        gas_cost += GAS_COLD_SLOAD

    capture_pre_storage(
        evm.message.tx_env.state_changes,
        evm.message.current_target,
        key,
        current_value,
    )
    track_storage_read(
        evm.state_changes,
        evm.message.current_target,
        key,
    )

    # ... gas calculation using original_value and current_value ...

    charge_gas(evm, gas_cost)
    set_storage(state, evm.message.current_target, key, new_value)
    track_storage_write(
        evm.state_changes,
        evm.message.current_target,
        key,
        new_value,
    )

    # PROGRAM COUNTER
    evm.pc += Uint(1)</code></pre>

<strong>Critical sequence</strong>:

<ul><li><code>capture_pre_storage()</code> — Records pre-value at <strong>tx frame</strong> (first-write-wins)</li>
<li><code>track_storage_read()</code> — Records the read at <strong>call frame</strong> (SSTORE reads before writing)</li>
<li><code>set_storage()</code> — Actually modifies state</li>
<li><code>track_storage_write()</code> — Records the write at <strong>call frame</strong></li>
</ul>
<strong>Why both read and write?</strong>

<p>SSTORE semantically reads the current value (for gas calculation) before writing. If the call reverts, the write is discarded but the read persists. This is why <code>merge_on_failure()</code> converts writes to reads.</p>

<strong>Pre-capture goes to tx_env.state_changes</strong>:

<pre><code class="language-python">capture_pre_storage(
    evm.message.tx_env.state_changes,  # &lt;-- tx frame, not call frame
    ...
)</code></pre>

<p>Pre-values must survive nested call reversions. If a child CALL writes slot X, reverts, then the parent writes slot X, the pre-value captured by the child must still be available.</p>

<h4><code>tload</code> / <code>tstore</code> (lines 136-166)</h4>

<pre><code class="language-python">def tload(evm: Evm) -&gt; None:
    &quot;&quot;&quot;
    Loads to the stack, the value corresponding to a certain key from the
    transient storage of the current account.
    &quot;&quot;&quot;
    # STACK
    key = pop(evm.stack).to_be_bytes32()

    # GAS
    charge_gas(evm, GAS_WARM_ACCESS)

    # OPERATION
    value = get_transient_storage(
        evm.message.tx_env.transient_storage, evm.message.current_target, key
    )
    push(evm.stack, value)

    # PROGRAM COUNTER
    evm.pc += Uint(1)</code></pre>

<strong>No tracking</strong>: Transient storage (EIP-1153) is not tracked in the BAL. It's cleared after each transaction and has no cross-block implications.

<hr>

<h3>Environment Instructions (environment.py)</h3>

<h4><code>balance</code> (lines 47-73)</h4>

<pre><code class="language-python">def balance(evm: Evm) -&gt; None:
    &quot;&quot;&quot;
    Pushes the balance of the given account onto the stack.
    &quot;&quot;&quot;
    # STACK
    address = to_address_masked(pop(evm.stack))

    # GAS
    is_cold_access = address not in evm.accessed_addresses
    gas_cost = GAS_COLD_ACCOUNT_ACCESS if is_cold_access else GAS_WARM_ACCESS
    if is_cold_access:
        evm.accessed_addresses.add(address)

    charge_gas(evm, gas_cost)

    # OPERATION
    state = evm.message.block_env.state
    balance = get_account(state, address).balance
    track_address(evm.state_changes, address)

    push(evm.stack, balance)

    # PROGRAM COUNTER
    evm.pc += Uint(1)</code></pre>

<strong>Tracking point</strong>: <code>track_address()</code> adds the address to <code>touched_addresses</code>.

<strong>Why track BALANCE targets?</strong>

<p>For stateless execution, the prover must include account data for any address whose balance is read. This includes non-existent accounts (returns 0).</p>

<h4><code>extcodesize</code> / <code>extcodecopy</code> / <code>extcodehash</code> (lines 286-362)</h4>

<pre><code class="language-python">def extcodesize(evm: Evm) -&gt; None:
    &quot;&quot;&quot;
    Push the code size of a given account onto the stack.
    &quot;&quot;&quot;
    # STACK
    address = to_address_masked(pop(evm.stack))

    # GAS
    is_cold_access = address not in evm.accessed_addresses
    access_gas_cost = (
        GAS_COLD_ACCOUNT_ACCESS if is_cold_access else GAS_WARM_ACCESS
    )
    if is_cold_access:
        evm.accessed_addresses.add(address)

    charge_gas(evm, access_gas_cost)

    # OPERATION
    state = evm.message.block_env.state
    code = get_account(state, address).code
    track_address(evm.state_changes, address)

    codesize = U256(len(code))
    push(evm.stack, codesize)</code></pre>

<p>All three EXTCODE<em> opcodes follow the same pattern: track the address after gas charging.</p>

<h4><code>self_balance</code> (lines 395-418)</h4>

<pre><code class="language-python">def self_balance(evm: Evm) -&gt; None:
    &quot;&quot;&quot;
    Pushes the balance of the current address to the stack.
    &quot;&quot;&quot;
    # STACK
    pass

    # GAS
    charge_gas(evm, GAS_FAST_STEP)

    # OPERATION
    balance = get_account(
        evm.message.block_env.state, evm.message.current_target
    ).balance

    push(evm.stack, balance)

    # PROGRAM COUNTER
    evm.pc += Uint(1)</code></pre>

<strong>No tracking!</strong> <code>SELFBALANCE</code> doesn't call <code>track_address()</code>.

<strong>Why not?</strong>

<p>The current contract address is already tracked when execution enters the contract (in <code>process_message()</code>). SELFBALANCE is a cheap introspection—no external address access occurs.</p>

<hr>

<h3>System Instructions (system.py)</h3>

<h4><code>generic_create</code> (lines 27-115)</h4>

<pre><code class="language-python">def generic_create(
    evm: Evm,
    endowment: U256,
    contract_address: Address,
    memory_start_position: U256,
    memory_size: U256,
) -&gt; None:
    &quot;&quot;&quot;
    Core logic used by the `CREATE*` family of opcodes.
    &quot;&quot;&quot;
    from ...vm.interpreter import (
        MAX_INIT_CODE_SIZE,
        STACK_DEPTH_LIMIT,
        process_create_message,
    )

    # Check static context first
    if evm.message.is_static:
        raise WriteInStaticContext

    # ... validation ...

    evm.accessed_addresses.add(contract_address)

    track_address(evm.state_changes, contract_address)
    if account_has_code_or_nonce(
        state, contract_address
    ) or account_has_storage(state, contract_address):
        increment_nonce(state, evm.message.current_target)
        nonce_after = get_account(state, evm.message.current_target).nonce
        track_nonce_change(
            evm.state_changes,
            evm.message.current_target,
            U64(nonce_after),
        )
        push(evm.stack, U256(0))
        return

    # Track nonce increment for CREATE
    increment_nonce(state, evm.message.current_target)
    nonce_after = get_account(state, evm.message.current_target).nonce
    track_nonce_change(
        evm.state_changes,
        evm.message.current_target,
        U64(nonce_after),
    )

    # Create call frame as child of parent EVM's frame
    child_state_changes = create_child_frame(evm.state_changes)

    child_message = Message(
        # ... other fields ...
        is_create=True,
        state_changes=child_state_changes,
    )
    child_evm = process_create_message(child_message)

    if child_evm.error:
        incorporate_child_on_error(evm, child_evm)
        evm.return_data = child_evm.output
        push(evm.stack, U256(0))
    else:
        incorporate_child_on_success(evm, child_evm)
        evm.return_data = b&quot;&quot;
        push(evm.stack, U256.from_be_bytes(child_evm.message.current_target))</code></pre>

<strong>Critical tracking points</strong>:

<ul><li><code>track_address(contract_address)</code> — Contract address is touched even if creation fails</li>
<li><code>track_nonce_change()</code> — Sender's nonce increments regardless of outcome</li>
<li><code>create_child_frame()</code> — Child gets its own state changes frame</li>
</ul>
<strong>The <code>is_create=True</code> flag</strong>:

<p>This affects merge behavior. In <code>process_create_message()</code>, the merge happens after code deployment validation, not in <code>generic_create()</code>.</p>

<h4><code>generic_call</code> (lines 234-297)</h4>

<pre><code class="language-python">def generic_call(
    evm: Evm,
    gas: Uint,
    value: U256,
    caller: Address,
    to: Address,
    code_address: Address,
    should_transfer_value: bool,
    is_staticcall: bool,
    memory_input_start_position: U256,
    memory_input_size: U256,
    memory_output_start_position: U256,
    memory_output_size: U256,
    code: Bytes,
    disable_precompiles: bool,
) -&gt; None:
    &quot;&quot;&quot;
    Perform the core logic of the `CALL*` family of opcodes.
    &quot;&quot;&quot;
    from ...vm.interpreter import STACK_DEPTH_LIMIT, process_message

    evm.return_data = b&quot;&quot;

    if evm.message.depth + Uint(1) &gt; STACK_DEPTH_LIMIT:
        evm.gas_left += gas
        push(evm.stack, U256(0))
        return

    call_data = memory_read_bytes(
        evm.memory, memory_input_start_position, memory_input_size
    )

    # Create call frame as child of parent EVM's frame
    child_state_changes = create_child_frame(evm.state_changes)

    child_message = Message(
        # ... other fields ...
        is_create=False,
        state_changes=child_state_changes,
    )

    child_evm = process_message(child_message)

    if child_evm.error:
        incorporate_child_on_error(evm, child_evm)
        evm.return_data = child_evm.output
        push(evm.stack, U256(0))
    else:
        incorporate_child_on_success(evm, child_evm)
        evm.return_data = child_evm.output
        push(evm.stack, U256(1))</code></pre>

<strong>Frame hierarchy in action</strong>:

<pre><code class="language-text">parent.state_changes (tx frame or call frame)
         ↓ create_child_frame()
child.state_changes
         ↓ process_message()
    ... execution ...
         ↓ incorporate_child_on_success/error()
parent.state_changes (merged)</code></pre>

<h4><code>selfdestruct</code> (lines 396-463)</h4>

<pre><code class="language-python">def selfdestruct(evm: Evm) -&gt; None:
    &quot;&quot;&quot;
    Halt execution and register account for later deletion.
    &quot;&quot;&quot;
    if evm.message.is_static:
        raise WriteInStaticContext

    # STACK
    beneficiary = to_address_masked(pop(evm.stack))

    # ... gas handling ...

    track_address(evm.state_changes, beneficiary)

    # ... more gas ...

    state = evm.message.block_env.state
    originator = evm.message.current_target
    originator_balance = get_account(state, originator).balance
    beneficiary_balance = get_account(state, beneficiary).balance

    # Get tracking context
    tx_frame = evm.message.tx_env.state_changes

    # Capture pre-balances for net-zero filtering
    track_address(evm.state_changes, originator)
    capture_pre_balance(tx_frame, originator, originator_balance)
    capture_pre_balance(tx_frame, beneficiary, beneficiary_balance)

    # Transfer balance
    move_ether(state, originator, beneficiary, originator_balance)

    # Track balance changes
    originator_new_balance = get_account(state, originator).balance
    beneficiary_new_balance = get_account(state, beneficiary).balance
    track_balance_change(
        evm.state_changes,
        originator,
        originator_new_balance,
    )
    track_balance_change(
        evm.state_changes,
        beneficiary,
        beneficiary_new_balance,
    )

    # register account for deletion only if it was created
    # in the same transaction
    if originator in state.created_accounts:
        set_account_balance(state, originator, U256(0))
        track_balance_change(evm.state_changes, originator, U256(0))
        evm.accounts_to_delete.add(originator)

    evm.running = False</code></pre>

<strong>Complex tracking sequence</strong>:

<ul><li>Track beneficiary address (may be new account)</li>
<li>Track originator address</li>
<li>Capture pre-balances for both (at tx frame)</li>
<li>Execute balance transfer</li>
<li>Track post-balances for both</li>
<li>If same-tx creation: additional balance zeroing</li>
</ul>
<strong>EIP-6780 interaction</strong>: Per EIP-6780, SELFDESTRUCT only deletes storage if the contract was created in the same transaction. The tracking handles this via <code>track_selfdestruct()</code> in state_tracker.py (see Section 04).

<hr>

<h2>Interpreter-Level Tracking</h2>

<h3>Value Transfers in <code>process_message</code> (interpreter.py, lines 278-323)</h3>

<pre><code class="language-python">def process_message(message: Message) -&gt; Evm:
    &quot;&quot;&quot;
    Move ether and execute the relevant code.
    &quot;&quot;&quot;
    # ... evm initialization ...

    # take snapshot of state before processing the message
    begin_transaction(state, transient_storage)

    track_address(message.state_changes, message.current_target)

    if message.should_transfer_value and message.value != 0:
        # Track value transfer
        sender_balance = get_account(state, message.caller).balance
        recipient_balance = get_account(state, message.current_target).balance

        track_address(message.state_changes, message.caller)
        capture_pre_balance(
            message.tx_env.state_changes, message.caller, sender_balance
        )
        capture_pre_balance(
            message.tx_env.state_changes,
            message.current_target,
            recipient_balance,
        )

        move_ether(
            state, message.caller, message.current_target, message.value
        )

        sender_new_balance = get_account(state, message.caller).balance
        recipient_new_balance = get_account(
            state, message.current_target
        ).balance

        track_balance_change(
            message.state_changes,
            message.caller,
            U256(sender_new_balance),
        )
        track_balance_change(
            message.state_changes,
            message.current_target,
            U256(recipient_new_balance),
        )</code></pre>

<strong>This is the CALL value transfer</strong>, not an opcode. It happens before code execution begins.

<strong>Tracking sequence</strong>:

<ul><li><code>track_address(current_target)</code> — Always track the call recipient</li>
<li>If transferring value:</li>
</ul>   <ul><li><code>track_address(caller)</code> — Track the sender</li>
</ul>   <ul><li><code>capture_pre_balance</code> for both (tx frame)</li>
</ul>   <ul><li><code>move_ether</code> — Actual balance modification</li>
</ul>   <ul><li><code>track_balance_change</code> for both (call frame)</li>
</ul>
<h3>Contract Creation in <code>process_create_message</code> (interpreter.py, lines 154-222)</h3>

<pre><code class="language-python">def process_create_message(message: Message) -&gt; Evm:
    &quot;&quot;&quot;
    Executes a call to create a smart contract.
    &quot;&quot;&quot;
    state = message.block_env.state
    transient_storage = message.tx_env.transient_storage
    begin_transaction(state, transient_storage)

    destroy_storage(state, message.current_target)
    mark_account_created(state, message.current_target)

    increment_nonce(state, message.current_target)
    nonce_after = get_account(state, message.current_target).nonce
    track_nonce_change(
        message.state_changes,
        message.current_target,
        U64(nonce_after),
    )

    capture_pre_code(message.tx_env.state_changes, message.current_target, b&quot;&quot;)

    evm = process_message(message)
    if not evm.error:
        contract_code = evm.output
        # ... code size validation ...
        try:
            # ... validation ...
            set_code(state, message.current_target, contract_code)
            if contract_code != b&quot;&quot;:
                track_code_change(
                    message.state_changes,
                    message.current_target,
                    contract_code,
                )
            commit_transaction(state, transient_storage)
            merge_on_success(message.state_changes)
        except ExceptionalHalt as error:
            rollback_transaction(state, transient_storage)
            merge_on_failure(message.state_changes)
            # ... error handling ...
    else:
        rollback_transaction(state, transient_storage)
        merge_on_failure(message.state_changes)
    return evm</code></pre>

<strong>Creation-specific tracking</strong>:

<ul><li><code>track_nonce_change()</code> — New contract gets nonce 1</li>
<li><code>capture_pre_code(b"")</code> — Pre-code is always empty for creation</li>
<li><code>track_code_change()</code> — Only if code is non-empty after deployment</li>
</ul>
<strong>Note</strong>: <code>capture_pre_code</code> uses <code>b""</code> because the address has no code before creation. This enables net-zero filtering if creation reverts.

<hr>

<h2>Child Frame Lifecycle</h2>

<h3><code>incorporate_child_on_success</code> (vm/__init__.py, lines 172-189)</h3>

<pre><code class="language-python">def incorporate_child_on_success(evm: Evm, child_evm: Evm) -&gt; None:
    &quot;&quot;&quot;
    Incorporate the state of a successful `child_evm` into the parent `evm`.
    &quot;&quot;&quot;
    evm.gas_left += child_evm.gas_left
    evm.logs += child_evm.logs
    evm.refund_counter += child_evm.refund_counter
    evm.accounts_to_delete.update(child_evm.accounts_to_delete)
    evm.accessed_addresses.update(child_evm.accessed_addresses)
    evm.accessed_storage_keys.update(child_evm.accessed_storage_keys)

    merge_on_success(child_evm.state_changes)</code></pre>

<strong>What merges</strong>:

<table><tr><th>Field</th><th>Behavior</th></tr>
<tr><td><code>gas_left</code></td><td>Added to parent</td></tr>
<tr><td><code>logs</code></td><td>Appended to parent</td></tr>
<tr><td><code>refund_counter</code></td><td>Added to parent</td></tr>
<tr><td><code>accounts_to_delete</code></td><td>Union with parent</td></tr>
<tr><td><code>accessed_addresses</code></td><td>Union with parent</td></tr>
<tr><td><code>accessed_storage_keys</code></td><td>Union with parent</td></tr>
<tr><td><code>state_changes</code></td><td>Via <code>merge_on_success()</code></td></tr></table>
<strong>The <code>merge_on_success()</code> call</strong> propagates all tracking data up the frame hierarchy.

<h3><code>incorporate_child_on_error</code> (vm/__init__.py, lines 192-201)</h3>

<pre><code class="language-python">def incorporate_child_on_error(evm: Evm, child_evm: Evm) -&gt; None:
    &quot;&quot;&quot;
    Incorporate the state of an unsuccessful `child_evm` into the parent `evm`.
    &quot;&quot;&quot;
    evm.gas_left += child_evm.gas_left

    merge_on_failure(child_evm.state_changes)</code></pre>

<strong>What merges</strong>:

<table><tr><th>Field</th><th>Behavior</th></tr>
<tr><td><code>gas_left</code></td><td>Added to parent</td></tr>
<tr><td>Everything else</td><td><strong>Discarded</strong></td></tr></table>
<strong>The <code>merge_on_failure()</code> call</strong> only propagates reads and address touches; writes are converted to reads.

<hr>

<h2>Opcode-to-Tracking Matrix</h2>

<table><tr><th>Opcode</th><th><code>track_address</code></th><th><code>track_storage_read</code></th><th><code>track_storage_write</code></th><th><code>capture_pre_</em></code></th><th><code>track_*_change</code></th></tr>
<tr><td>SLOAD</td><td>—</td><td>✓</td><td>—</td><td>—</td><td>—</td></tr>
<tr><td>SSTORE</td><td>—</td><td>✓</td><td>✓</td><td>pre_storage (tx)</td><td>—</td></tr>
<tr><td>TLOAD</td><td>—</td><td>—</td><td>—</td><td>—</td><td>—</td></tr>
<tr><td>TSTORE</td><td>—</td><td>—</td><td>—</td><td>—</td><td>—</td></tr>
<tr><td>BALANCE</td><td>✓</td><td>—</td><td>—</td><td>—</td><td>—</td></tr>
<tr><td>SELFBALANCE</td><td>—</td><td>—</td><td>—</td><td>—</td><td>—</td></tr>
<tr><td>EXTCODESIZE</td><td>✓</td><td>—</td><td>—</td><td>—</td><td>—</td></tr>
<tr><td>EXTCODECOPY</td><td>✓</td><td>—</td><td>—</td><td>—</td><td>—</td></tr>
<tr><td>EXTCODEHASH</td><td>✓</td><td>—</td><td>—</td><td>—</td><td>—</td></tr>
<tr><td>CALL</td><td>✓ (target)</td><td>—</td><td>—</td><td>pre_balance (if value)</td><td>balance_change (if value)</td></tr>
<tr><td>STATICCALL</td><td>✓ (target)</td><td>—</td><td>—</td><td>—</td><td>—</td></tr>
<tr><td>DELEGATECALL</td><td>✓ (code addr)</td><td>—</td><td>—</td><td>—</td><td>—</td></tr>
<tr><td>CALLCODE</td><td>✓ (code addr)</td><td>—</td><td>—</td><td>pre_balance (if value)</td><td>—</td></tr>
<tr><td>CREATE/CREATE2</td><td>✓ (new addr)</td><td>—</td><td>—</td><td>pre_code</td><td>nonce_change, code_change</td></tr>
<tr><td>SELFDESTRUCT</td><td>✓ (beneficiary)</td><td>—</td><td>—</td><td>pre_balance (both)</td><td>balance_change (both)</td></tr></table>
<strong>Key observations</strong>:

<ul><li><strong>TLOAD/TSTORE</strong>: Not tracked (transient storage is tx-local)</li>
<li><strong>SELFBALANCE</strong>: Not tracked (self address already tracked)</li>
<li><strong>Pre-captures</strong>: Always go to tx_env.state_changes</li>
<li><strong>Post-changes</strong>: Go to evm.state_changes (current frame)</li>
</ul>
<hr>

<h2>Gotchas and Edge Cases</h2>

<h3>1. Reverted Writes Become Reads</h3>

<p>When a call reverts, its writes are converted to reads via <code>merge_on_failure()</code>:</p>

<pre><code class="language-python">def merge_on_failure(child_frame: StateChanges) -&gt; None:
    # ...
    # Convert writes to reads (failed writes still accessed the slots)
    for address, key, _idx in child_frame.storage_writes.keys():
        parent_frame.storage_reads.add((address, key))</code></pre>

<strong>Why?</strong> The slot was accessed, even if the write didn't persist. Witnesses must include the pre-value.

<h3>2. Multiple Writes to Same Slot</h3>

<p>Within a call frame, multiple SSTORE operations to the same slot:</p>

<pre><code class="language-solidity">SSTORE(slot, 1)  // write (slot, 1) at index X
SSTORE(slot, 2)  // write (slot, 2) at index X (overwrites)</code></pre>

<p>Only the final value is recorded because writes use <code>block_access_index</code> as part of the key:</p>

<pre><code class="language-python">state_changes.storage_writes[(address, key, idx)] = value</code></pre>

<p>Same <code>(address, key, idx)</code> → last write wins.</p>

<h3>3. CREATE Collision</h3>

<p>If CREATE targets an address with existing code/nonce:</p>

<pre><code class="language-python">track_address(evm.state_changes, contract_address)
if account_has_code_or_nonce(state, contract_address) or account_has_storage(...):
    track_nonce_change(...)  # Still track the sender nonce bump
    push(evm.stack, U256(0))
    return  # Early exit, no child frame</code></pre>

<p>The address is tracked even though creation fails.</p>

<h3>4. CALLCODE Value Transfer</h3>

<p>CALLCODE transfers value but keeps the same storage context:</p>

<pre><code class="language-python"># EIP-7928: For CALLCODE with value transfer, capture pre-balance
# in transaction frame. CALLCODE transfers value from/to current_target
# (same address), affecting current storage context, not child frame
if value != 0 and sender_balance &gt;= value:
    capture_pre_balance(
        evm.message.tx_env.state_changes,
        evm.message.current_target,
        sender_balance,
    )</code></pre>

<p>This is a subtle case: the balance changes but the storage context doesn't change.</p>

<h3>5. Precompiles</h3>

<p>Precompiles don't execute EVM code, so tracking happens only for: <ul><li>Address access (via CALL)</li> <li>Value transfer (if applicable)</li> </ul> No storage tracking occurs for precompile calls.</p>

<hr>

<h2>Cross-References</h2>

<ul><li><strong>Section 03-04</strong>: StateChanges dataclass and recording functions used here</li>
<li><strong>Section 05</strong>: Frame management (create_child_frame, merge_on_success/failure)</li>
<li><strong>Section 08</strong>: Block processing that initializes the top-level state_changes</li>
<li><strong>Section 10</strong>: Fork definition where apply_body creates BlockEnvironment</li>
</ul>
</section>

<section id="section-10-fork-definition">
<h1>Section 10: Fork Definition</h1>

<h2>Source Files</h2>
<ul><li><code>specs/execution-specs/src/ethereum/forks/amsterdam/fork.py</code> (1179 lines)</li>
<li><code>specs/execution-specs/src/ethereum/forks/amsterdam/vm/__init__.py</code> (206 lines)</li>
<li><code>specs/execution-specs/src/ethereum/forks/amsterdam/blocks.py</code> (417 lines)</li>
</ul>
<hr>

<h2>Overview</h2>

<p>The fork definition is where EIP-7928 comes together at the block level. This section covers: <ul><li><strong>Header changes</strong>: The new <code>block_access_list_hash</code> field</li> <li><strong>Environment changes</strong>: <code>StateChanges</code> threading through block/tx/call execution</li> <li><strong>Validation changes</strong>: Computing and verifying the BAL hash</li> <li><strong>System transaction handling</strong>: Pre-execution calls with proper frame management</li> <li><strong>Transaction processing</strong>: Frame lifecycle, pre-value capture, commit timing</li> <li><strong>Withdrawal processing</strong>: Balance tracking for validator withdrawals</li> </ul> <hr></p>

<h2>Data Structure Changes</h2>

<h3>Header: <code>block_access_list_hash</code> (blocks.py lines 245-254)</h3>

<pre><code class="language-python">@slotted_freezable
@dataclass
class Header:
    # ... existing fields ...
    
    block_access_list_hash: Hash32
    &quot;&quot;&quot;
    [`keccak256`] hash of the Block Access List containing all accounts and
    storage locations accessed during block execution. Introduced in
    [EIP-7928]. See [`compute_block_access_list_hash`][cbalh] for more
    details.
    &quot;&quot;&quot;</code></pre>

<strong>Position in RLP</strong>: This field follows <code>requests_hash</code> in the header encoding. The exact position matters for consensus — all clients must encode headers identically.

<strong>Why hash instead of full BAL?</strong>:
<ul><li>Block headers must be small for light clients</li>
<li>Hash commits to the full BAL without bloating headers</li>
<li>Full BAL is available in the block body (and via P2P)</li>
</ul>
<hr>

<h3>BlockEnvironment: <code>state_changes</code> (vm/__init__.py lines 36-53)</h3>

<pre><code class="language-python">@dataclass
class BlockEnvironment:
    &quot;&quot;&quot;
    Items external to the virtual machine itself, provided by the environment.
    &quot;&quot;&quot;
    chain_id: U64
    state: State
    block_gas_limit: Uint
    block_hashes: List[Hash32]
    coinbase: Address
    number: Uint
    base_fee_per_gas: Uint
    time: U256
    prev_randao: Bytes32
    excess_blob_gas: U64
    parent_beacon_block_root: Hash32
    state_changes: StateChanges  # NEW: EIP-7928</code></pre>

<strong>Purpose</strong>: The <code>state_changes</code> field holds the <strong>block-level frame</strong> that accumulates all state accesses across system transactions, user transactions, and withdrawals.

<strong>Initialization</strong>: Created fresh in <code>state_transition()</code> before any execution begins:

<pre><code class="language-python">block_env = vm.BlockEnvironment(
    # ... other fields ...
    state_changes=StateChanges(),  # Empty block frame
)</code></pre>

<strong>Lifetime</strong>: Lives for the entire block execution. After all transactions and withdrawals, this frame contains the complete state access record.

<hr>

<h3>TransactionEnvironment: <code>state_changes</code> (vm/__init__.py lines 97-117)</h3>

<pre><code class="language-python">@dataclass
class TransactionEnvironment:
    origin: Address
    gas_price: Uint
    gas: Uint
    access_list_addresses: Set[Address]
    access_list_storage_keys: Set[Tuple[Address, Bytes32]]
    transient_storage: TransientStorage
    blob_versioned_hashes: Tuple[VersionedHash, ...]
    authorizations: Tuple[Authorization, ...]
    index_in_block: Optional[Uint]
    tx_hash: Optional[Hash32]
    state_changes: &quot;StateChanges&quot; = field(default_factory=StateChanges)  # NEW</code></pre>

<strong>Parent relationship</strong>: Transaction frames link to the block frame via <code>StateChanges.parent</code>. This is established when calling <code>create_child_frame(block_env.state_changes)</code>.

<hr>

<h3>Message: <code>state_changes</code> (vm/__init__.py lines 120-143)</h3>

<pre><code class="language-python">@dataclass
class Message:
    block_env: BlockEnvironment
    tx_env: TransactionEnvironment
    caller: Address
    target: Bytes0 | Address
    # ... other fields ...
    state_changes: &quot;StateChanges&quot; = field(default_factory=StateChanges)  # NEW</code></pre>

<strong>Call frame hierarchy</strong>: Each CALL/CREATE creates a child frame. On RETURN, <code>merge_on_success</code> or <code>merge_on_failure</code> propagates state accesses up.

<hr>

<h3>BlockOutput: <code>block_access_list</code> (vm/__init__.py lines 56-93)</h3>

<pre><code class="language-python">@dataclass
class BlockOutput:
    block_gas_used: Uint = Uint(0)
    transactions_trie: Trie[...] = field(default_factory=...)
    receipts_trie: Trie[...] = field(default_factory=...)
    receipt_keys: Tuple[Bytes, ...] = field(default_factory=tuple)
    block_logs: Tuple[Log, ...] = field(default_factory=tuple)
    withdrawals_trie: Trie[...] = field(default_factory=...)
    blob_gas_used: U64 = U64(0)
    requests: List[Bytes] = field(default_factory=list)
    block_access_list: BlockAccessList = field(default_factory=list)  # NEW</code></pre>

<strong>Populated by</strong>: <code>build_block_access_list()</code> at the end of <code>apply_body()</code>.

<hr>

<h2>State Transition: Entry Point</h2>

<h3><code>state_transition()</code> (fork.py lines 199-262)</h3>

<pre><code class="language-python">def state_transition(chain: BlockChain, block: Block) -&gt; None:
    if len(rlp.encode(block)) &gt; MAX_RLP_BLOCK_SIZE:
        raise InvalidBlock(&quot;Block rlp size exceeds MAX_RLP_BLOCK_SIZE&quot;)

    validate_header(chain, block.header)
    if block.ommers != ():
        raise InvalidBlock

    block_env = vm.BlockEnvironment(
        chain_id=chain.chain_id,
        state=chain.state,
        block_gas_limit=block.header.gas_limit,
        block_hashes=get_last_256_block_hashes(chain),
        coinbase=block.header.coinbase,
        number=block.header.number,
        base_fee_per_gas=block.header.base_fee_per_gas,
        time=block.header.timestamp,
        prev_randao=block.header.prev_randao,
        excess_blob_gas=block.header.excess_blob_gas,
        parent_beacon_block_root=block.header.parent_beacon_block_root,
        state_changes=StateChanges(),  # EIP-7928: Fresh block frame
    )

    block_output = apply_body(
        block_env=block_env,
        transactions=block.transactions,
        withdrawals=block.withdrawals,
    )
    
    # ... compute roots and hashes ...
    
    computed_block_access_list_hash = compute_block_access_list_hash(
        block_output.block_access_list
    )
    
    # ... validation checks ...
    
    if computed_block_access_list_hash != block.header.block_access_list_hash:
        raise InvalidBlock(&quot;Invalid block access list hash&quot;)

    chain.blocks.append(block)</code></pre>

<strong>EIP-7928 changes</strong>:
<ul><li><code>StateChanges()</code> initialized as block frame</li>
<li><code>block_output.block_access_list</code> computed during <code>apply_body()</code></li>
<li>Hash computed and validated against header</li>
</ul>
<strong>Why validate the hash?</strong>: The BAL is consensus-critical. If a block proposes an incorrect BAL, validators must reject it. The hash provides a compact commitment that can be verified efficiently.

<hr>

<h2>System Transaction Processing</h2>

<h3><code>process_system_transaction()</code> (fork.py lines 520-582)</h3>

<pre><code class="language-python">def process_system_transaction(
    block_env: vm.BlockEnvironment,
    target_address: Address,
    system_contract_code: Bytes,
    data: Bytes,
) -&gt; MessageCallOutput:
    # EIP-7928: Create a child frame for system transaction
    # This allows proper pre-state capture for net-zero filtering
    system_tx_state_changes = create_child_frame(block_env.state_changes)

    tx_env = vm.TransactionEnvironment(
        origin=SYSTEM_ADDRESS,
        gas_price=block_env.base_fee_per_gas,
        gas=SYSTEM_TRANSACTION_GAS,
        access_list_addresses=set(),
        access_list_storage_keys=set(),
        transient_storage=TransientStorage(),
        blob_versioned_hashes=(),
        authorizations=(),
        index_in_block=None,  # System txs have no index
        tx_hash=None,
        state_changes=system_tx_state_changes,
    )

    # Create call frame as child of tx frame
    call_frame = create_child_frame(tx_env.state_changes)

    system_tx_message = Message(
        block_env=block_env,
        tx_env=tx_env,
        caller=SYSTEM_ADDRESS,
        target=target_address,
        gas=SYSTEM_TRANSACTION_GAS,
        value=U256(0),
        data=data,
        code=system_contract_code,
        depth=Uint(0),
        current_target=target_address,
        code_address=target_address,
        should_transfer_value=False,
        is_static=False,
        accessed_addresses=set(),
        accessed_storage_keys=set(),
        disable_precompiles=False,
        parent_evm=None,
        is_create=False,
        state_changes=call_frame,
    )

    system_tx_output = process_message_call(system_tx_message)

    # Commit system transaction changes to block frame
    # System transactions always succeed (or block is invalid)
    commit_transaction_frame(tx_env.state_changes)

    return system_tx_output</code></pre>

<strong>System transactions in EIP-7928</strong>:
<ul><li>Beacon roots contract (EIP-4788)</li>
<li>History storage contract (EIP-2935)</li>
<li>Withdrawal request contract (EIP-7002)</li>
<li>Consolidation request contract (EIP-7251)</li>
</ul>
<strong>Block access index</strong>: System transactions use <code>block_access_index = 0</code>. They execute before user transactions, so their state accesses are grouped at index 0.

<strong>Frame hierarchy</strong>:
<pre><code class="language-text">block_frame (index 0)
└── system_tx_frame
    └── call_frame</code></pre>

<strong>Why create frames for system txs?</strong>: Even though system txs "always succeed" (checked variant raises InvalidBlock on failure), we still need:
<ul><li>Proper pre-value capture for net-zero filtering</li>
<li>Frame-based state change accumulation</li>
<li>Consistent frame semantics across all execution types</li>
</ul>
<hr>

<h2>Block Body Execution</h2>

<h3><code>apply_body()</code> (fork.py lines 680-755)</h3>

<pre><code class="language-python">def apply_body(
    block_env: vm.BlockEnvironment,
    transactions: Tuple[LegacyTransaction | Bytes, ...],
    withdrawals: Tuple[Withdrawal, ...],
) -&gt; vm.BlockOutput:
    block_output = vm.BlockOutput()

    # EIP-7928: System contracts use block_access_index 0
    # The block frame already starts at index 0, so system transactions
    # naturally use that index through the block frame

    process_unchecked_system_transaction(
        block_env=block_env,
        target_address=BEACON_ROOTS_ADDRESS,
        data=block_env.parent_beacon_block_root,
    )

    process_unchecked_system_transaction(
        block_env=block_env,
        target_address=HISTORY_STORAGE_ADDRESS,
        data=block_env.block_hashes[-1],  # The parent hash
    )

    for i, tx in enumerate(map(decode_transaction, transactions)):
        process_transaction(block_env, block_output, tx, Uint(i))

    # EIP-7928: Increment block frame to post-execution index
    # After N transactions, block frame is at index N
    # Post-execution operations (withdrawals, etc.) use index N+1
    increment_block_access_index(block_env.state_changes)

    process_withdrawals(block_env, block_output, withdrawals)

    process_general_purpose_requests(
        block_env=block_env,
        block_output=block_output,
    )
    
    # Build block access list from block_env.state_changes
    block_output.block_access_list = build_block_access_list(
        block_env.state_changes
    )

    return block_output</code></pre>

<strong>Execution order and indices</strong>:

<table><tr><th>Phase</th><th>Block Access Index</th><th>Contents</th></tr>
<tr><td>System transactions</td><td>0</td><td>Beacon roots, history storage</td></tr>
<tr><td>Transaction 0</td><td>1</td><td>First user transaction</td></tr>
<tr><td>Transaction 1</td><td>2</td><td>Second user transaction</td></tr>
<tr><td>...</td><td>...</td><td>...</td></tr>
<tr><td>Transaction N-1</td><td>N</td><td>Last user transaction</td></tr>
<tr><td>Post-execution</td><td>N+1</td><td>Withdrawals, request contracts</td></tr></table>
<strong>Why increment after transactions?</strong>: Withdrawals and post-execution system calls (withdrawal/consolidation requests) must have a distinct index from the last user transaction. Without this increment, their state accesses would be indistinguishable from the last tx.

<strong>BAL construction timing</strong>: <code>build_block_access_list()</code> is called AFTER all state changes are recorded. The block frame at this point contains the complete, merged, filtered record of all state accesses.

<hr>

<h2>Transaction Processing</h2>

<h3><code>process_transaction()</code> (fork.py lines 770-930)</h3>

<p>This is the heart of EIP-7928's transaction-level integration. Let's examine it section by section.</p>

<h4>Frame Creation (lines 809-821)</h4>

<pre><code class="language-python">def process_transaction(
    block_env: vm.BlockEnvironment,
    block_output: vm.BlockOutput,
    tx: Transaction,
    index: Uint,
) -&gt; None:
    # EIP-7928: Create a transaction-level StateChanges frame
    # The frame will read the current block_access_index from the block frame
    increment_block_access_index(block_env.state_changes)
    tx_state_changes = create_child_frame(block_env.state_changes)</code></pre>

<strong>Key insight</strong>: <code>increment_block_access_index</code> happens BEFORE <code>create_child_frame</code>. This ensures the new transaction frame inherits the correct index.

<strong>Index inheritance</strong>: When <code>create_child_frame(parent)</code> is called, the child copies <code>parent.block_access_index</code>. All track functions in the child use this index without needing to walk up the parent chain.

<h4>Coinbase Pre-Balance Capture (lines 823-829)</h4>

<pre><code class="language-python"># Capture coinbase pre-balance for net-zero filtering
    coinbase_pre_balance = get_account(
        block_env.state, block_env.coinbase
    ).balance
    track_address(tx_state_changes, block_env.coinbase)
    capture_pre_balance(
        tx_state_changes, block_env.coinbase, coinbase_pre_balance
    )</code></pre>

<strong>Why track coinbase explicitly?</strong>: The coinbase receives the priority fee at the end of transaction execution. If coinbase doesn't appear elsewhere in the tx, we'd miss the pre-balance and couldn't do net-zero filtering.

<strong>Net-zero scenario</strong>: Consider a transaction where:
<ul><li>Priority fee = 1 gwei</li>
<li>Coinbase also receives exactly 1 gwei from a SELFDESTRUCT</li>
</ul>
Without pre-balance capture, we couldn't detect if the net change is zero.

<h4>Sender Processing (lines 860-880)</h4>

<pre><code class="language-python"># Track sender nonce increment
    increment_nonce(block_env.state, sender)
    sender_nonce_after = get_account(block_env.state, sender).nonce
    track_nonce_change(tx_state_changes, sender, U64(sender_nonce_after))

    # Track sender balance deduction for gas fee
    sender_balance_before = get_account(block_env.state, sender).balance
    track_address(tx_state_changes, sender)
    capture_pre_balance(tx_state_changes, sender, sender_balance_before)

    sender_balance_after_gas_fee = (
        Uint(sender_account.balance) - effective_gas_fee - blob_gas_fee
    )
    set_account_balance(
        block_env.state, sender, U256(sender_balance_after_gas_fee)
    )
    track_balance_change(
        tx_state_changes,
        sender,
        U256(sender_balance_after_gas_fee),
    )</code></pre>

<strong>Nonce tracking</strong>: Unlike balances, nonces only increment. There's no net-zero filtering for nonces — if a nonce was incremented, it always appears in the BAL.

<strong>Pre-balance capture timing</strong>: Must happen BEFORE the balance is modified. The pattern is:
<ul><li>Read current balance from state</li>
<li><code>capture_pre_balance()</code> to record it</li>
<li>Modify balance in state</li>
<li><code>track_balance_change()</code> to record new value</li>
</ul>
<h4>Gas Refund and Coinbase Payment (lines 918-940)</h4>

<pre><code class="language-python"># refund gas
    sender_balance_after_refund = get_account(
        block_env.state, sender
    ).balance + U256(gas_refund_amount)
    set_account_balance(block_env.state, sender, sender_balance_after_refund)
    track_balance_change(
        tx_env.state_changes,
        sender,
        sender_balance_after_refund,
    )

    coinbase_balance_after_mining_fee = get_account(
        block_env.state, block_env.coinbase
    ).balance + U256(transaction_fee)

    set_account_balance(
        block_env.state, block_env.coinbase, coinbase_balance_after_mining_fee
    )
    track_balance_change(
        tx_env.state_changes,
        block_env.coinbase,
        coinbase_balance_after_mining_fee,
    )</code></pre>

<strong>Why track refund?</strong>: The sender's balance changes twice:
<ul><li>Gas deduction (before execution)</li>
<li>Gas refund (after execution)</li>
</ul>
Both are tracked, but net-zero filtering will use the final value.

<h4>Frame Commit (lines 960-965)</h4>

<pre><code class="language-python">for address in tx_output.accounts_to_delete:
        destroy_account(block_env.state, address)
        track_selfdestruct(tx_env.state_changes, address)

    # EIP-7928: Commit transaction frame (includes net-zero filtering).
    # Must happen AFTER destroy_account so filtering sees correct state.
    commit_transaction_frame(tx_env.state_changes)</code></pre>

<strong>Critical ordering</strong>: <code>commit_transaction_frame</code> must be called AFTER:
<ul><li>All state modifications (including SELFDESTRUCT)</li>
<li>All track_<em> calls</li>
</ul>
The commit:
<ul><li>Runs <code>filter_net_zero_frame_changes()</code> on the tx frame</li>
<li>Merges the filtered frame into the block frame</li>
</ul>
<hr>

<h2>Withdrawal Processing</h2>

<h3><code>process_withdrawals()</code> (fork.py lines 968-1005)</h3>

<pre><code class="language-python">def process_withdrawals(
    block_env: vm.BlockEnvironment,
    block_output: vm.BlockOutput,
    withdrawals: Tuple[Withdrawal, ...],
) -&gt; None:
    &quot;&quot;&quot;
    Increase the balance of the withdrawing account.
    &quot;&quot;&quot;
    # Capture pre-state for withdrawal balance filtering
    withdrawal_addresses = {wd.address for wd in withdrawals}
    for address in withdrawal_addresses:
        pre_balance = get_account(block_env.state, address).balance
        track_address(block_env.state_changes, address)
        capture_pre_balance(block_env.state_changes, address, pre_balance)

    def increase_recipient_balance(recipient: Account) -&gt; None:
        recipient.balance += wd.amount * U256(10**9)

    for i, wd in enumerate(withdrawals):
        trie_set(
            block_output.withdrawals_trie,
            rlp.encode(Uint(i)),
            rlp.encode(wd),
        )

        modify_state(block_env.state, wd.address, increase_recipient_balance)

        new_balance = get_account(block_env.state, wd.address).balance
        track_balance_change(
            block_env.state_changes,
            wd.address,
            new_balance,
        )

        if account_exists_and_is_empty(block_env.state, wd.address):
            destroy_account(block_env.state, wd.address)

    # EIP-7928: Filter net-zero balance changes for withdrawals
    filter_net_zero_frame_changes(block_env.state_changes)</code></pre>

<strong>Unique characteristics of withdrawal tracking</strong>:

<ul><li><strong>No transaction frame</strong>: Withdrawals operate directly on the block frame</li>
<li><strong>Batch pre-capture</strong>: All addresses are captured before any balances change</li>
<li><strong>Explicit filter call</strong>: Since there's no <code>commit_transaction_frame</code>, filtering is called explicitly</li>
</ul>
<strong>Why deduplicate addresses?</strong>: Multiple withdrawals can go to the same address. We only need one pre-balance capture per address, not per withdrawal.

<strong>Net-zero scenario</strong>: A withdrawal of 0 ETH would result in pre == post, and the balance change would be filtered out. The address would still appear in <code>touched_addresses</code>.

<hr>

<h2>EVM Integration Points</h2>

<h3><code>incorporate_child_on_success()</code> (vm/__init__.py lines 182-194)</h3>

<pre><code class="language-python">def incorporate_child_on_success(evm: Evm, child_evm: Evm) -&gt; None:
    evm.gas_left += child_evm.gas_left
    evm.logs += child_evm.logs
    evm.refund_counter += child_evm.refund_counter
    evm.accounts_to_delete.update(child_evm.accounts_to_delete)
    evm.accessed_addresses.update(child_evm.accessed_addresses)
    evm.accessed_storage_keys.update(child_evm.accessed_storage_keys)

    merge_on_success(child_evm.state_changes)  # EIP-7928</code></pre>

<strong>When called</strong>: After a CALL/DELEGATECALL/STATICCALL/CREATE/CREATE2 returns successfully.

<strong>State change propagation</strong>: <code>merge_on_success</code> propagates all state accesses from child to parent. Writes overwrite, reads union.

<h3><code>incorporate_child_on_error()</code> (vm/__init__.py lines 197-206)</h3>

<pre><code class="language-python">def incorporate_child_on_error(evm: Evm, child_evm: Evm) -&gt; None:
    evm.gas_left += child_evm.gas_left

    merge_on_failure(child_evm.state_changes)  # EIP-7928</code></pre>

<strong>When called</strong>: After a CALL/etc. reverts.

<strong>State change propagation</strong>: <code>merge_on_failure</code> converts writes to reads and discards value changes. The slots were still accessed (useful for prefetching), even though the final values didn't change.

<hr>

<h2>Imports: EIP-7928 Dependencies</h2>

<h3>State Tracker Imports (fork.py lines 56-70)</h3>

<pre><code class="language-python">from .state_tracker import (
    StateChanges,
    capture_pre_balance,
    commit_transaction_frame,
    create_child_frame,
    filter_net_zero_frame_changes,
    increment_block_access_index,
    track_address,
    track_balance_change,
    track_nonce_change,
    track_selfdestruct,
)</code></pre>

<h3>Builder Imports (fork.py lines 25-27)</h3>

<pre><code class="language-python">from .block_access_lists.builder import build_block_access_list
from .block_access_lists.rlp_utils import compute_block_access_list_hash</code></pre>

<hr>

<h2>Gotchas and Edge Cases</h2>

<h3>1. Index Timing</h3>

<p>The <code>block_access_index</code> must be incremented BEFORE creating the child frame, not after:</p>

<pre><code class="language-python"># CORRECT
increment_block_access_index(block_env.state_changes)
tx_state_changes = create_child_frame(block_env.state_changes)

# WRONG - child would inherit old index
tx_state_changes = create_child_frame(block_env.state_changes)
increment_block_access_index(block_env.state_changes)</code></pre>

<h3>2. Pre-Balance Capture Ordering</h3>

<p>Pre-balance must be captured before ANY modification to that balance:</p>

<pre><code class="language-python"># CORRECT
pre = get_account(state, addr).balance
capture_pre_balance(frame, addr, pre)
modify_balance(state, addr, new_value)
track_balance_change(frame, addr, new_value)

# WRONG - pre-value already changed
modify_balance(state, addr, new_value)
pre = get_account(state, addr).balance  # This is the new value!
capture_pre_balance(frame, addr, pre)</code></pre>

<h3>3. Commit After SELFDESTRUCT</h3>

<p>The frame commit must happen AFTER <code>track_selfdestruct</code>:</p>

<pre><code class="language-python">for address in tx_output.accounts_to_delete:
    destroy_account(block_env.state, address)
    track_selfdestruct(tx_env.state_changes, address)

# Now commit - selfdestruct is recorded
commit_transaction_frame(tx_env.state_changes)</code></pre>

<h3>4. System Transaction Index</h3>

<p>System transactions all share <code>block_access_index = 0</code>. This means: <ul><li>Beacon roots and history storage accesses are grouped together</li> <li>Post-execution system calls (withdrawal/consolidation requests) use index N+1</li> </ul> <h3>5. Empty Withdrawals</h3></p>

<p>An empty withdrawals list still triggers <code>filter_net_zero_frame_changes</code>. This is harmless but worth noting — the filter will find nothing to filter.</p>

<hr>

<h2>Cross-References</h2>

<table><tr><th>Section</th><th>Relationship</th></tr>
<tr><td><strong>Section 03</strong></td><td>StateChanges dataclass definition</td></tr>
<tr><td><strong>Section 04</strong></td><td>track_</em> functions that record state accesses</td></tr>
<tr><td><strong>Section 05</strong></td><td>Frame management (create, merge, commit)</td></tr>
<tr><td><strong>Section 06-07</strong></td><td>Builder that consumes block frame</td></tr>
<tr><td><strong>Section 08</strong></td><td>Block validation (header hash check)</td></tr>
<tr><td><strong>Section 09</strong></td><td>VM interpreter hooks into state_changes</td></tr>
<tr><td><strong>Section 11</strong></td><td>Engine API exposes BAL to CL</td></tr></table>
<hr>

<h2>Summary</h2>

<p>The fork definition is where EIP-7928's state tracking integrates with Ethereum's execution flow:</p>

<ul><li><strong>Block frame</strong> created in <code>state_transition()</code> with <code>StateChanges()</code></li>
<li><strong>System transactions</strong> create child frames, commit back to block frame</li>
<li><strong>User transactions</strong> create child frames with incremented indices</li>
<li><strong>Withdrawals</strong> operate on block frame with explicit net-zero filtering</li>
<li><strong>BAL construction</strong> happens after all execution, from the complete block frame</li>
<li><strong>Hash validation</strong> ensures consensus on the access list</li>
</ul>
The design is conservative: all existing execution logic remains, with state tracking woven through via frame creation, tracking calls, and commit points.
</section>

<section id="section-11-engine-api">
<h1>Section 11: Engine API</h1>

<h2>Source Files</h2>
<ul><li><code>specs/execution-apis/src/engine/amsterdam.md</code> (237 lines)</li>
</ul>
<h2>Overview</h2>

<p>The Engine API is the critical interface between the Consensus Layer (CL) and Execution Layer (EL). EIP-7928 introduces Block Access Lists (BALs) that must flow through this interface in both directions: from EL to CL during block building (<code>engine_getPayloadV6</code>), and from CL to EL during block validation (<code>engine_newPayloadV5</code>). This section annotates every change Amsterdam makes to the Engine API.</p>

<h2>Architecture Context</h2>

<p>The Engine API follows a versioned pattern: each hard fork bumps the version numbers of methods that change. Amsterdam introduces:</p>

<table><tr><th>Method</th><th>Version</th><th>Change</th></tr>
<tr><td><code>engine_newPayloadV5</code></td><td>V4 → V5</td><td>Validates BAL in ExecutionPayloadV4</td></tr>
<tr><td><code>engine_getPayloadV6</code></td><td>V5 → V6</td><td>Returns BAL in ExecutionPayloadV4</td></tr>
<tr><td><code>engine_getPayloadBodiesByHashV2</code></td><td>V1 → V2</td><td>Returns BAL in ExecutionPayloadBodyV2</td></tr>
<tr><td><code>engine_getPayloadBodiesByRangeV2</code></td><td>V1 → V2</td><td>Returns BAL in ExecutionPayloadBodyV2</td></tr>
<tr><td><code>engine_forkchoiceUpdatedV4</code></td><td>V3 → V4</td><td>Uses PayloadAttributesV4 with slotNumber</td></tr></table>
The version bumps are NOT arbitrary—they signal breaking changes that require coordinated client updates.

<hr>

<h2>Structures</h2>

<h3><code>ExecutionPayloadV4</code> (lines 23-38)</h3>

<pre><code class="language-markdown">This structure has the syntax of [`ExecutionPayloadV3`](./cancun.md#executionpayloadv3) 
and appends the new field: `blockAccessList`.

- `parentHash`: `DATA`, 32 Bytes
- `feeRecipient`:  `DATA`, 20 Bytes
- `stateRoot`: `DATA`, 32 Bytes
- `receiptsRoot`: `DATA`, 32 Bytes
- `logsBloom`: `DATA`, 256 Bytes
- `prevRandao`: `DATA`, 32 Bytes
- `blockNumber`: `QUANTITY`, 64 Bits
- `gasLimit`: `QUANTITY`, 64 Bits
- `gasUsed`: `QUANTITY`, 64 Bits
- `timestamp`: `QUANTITY`, 64 Bits
- `extraData`: `DATA`, 0 to 32 Bytes
- `baseFeePerGas`: `QUANTITY`, 256 Bits
- `blockHash`: `DATA`, 32 Bytes
- `transactions`: `Array of DATA` - Array of transaction objects...
- `withdrawals`: `Array of WithdrawalV1` - Array of withdrawals...
- `blobGasUsed`: `QUANTITY`, 64 Bits
- `excessBlobGas`: `QUANTITY`, 64 Bits
- `blockAccessList`: `DATA` - RLP-encoded block access list as defined in [EIP-7928]
- `slotNumber`: `QUANTITY`, 64 Bits</code></pre>

<strong>Purpose</strong>: The canonical representation of an execution payload for Amsterdam blocks.

<strong>New fields</strong>:
<ul><li><code>blockAccessList</code> — RLP-encoded BAL (see Section 01: RLP Types)</li>
<li><code>slotNumber</code> — Beacon chain slot for this block</li>
</ul>
<strong>Why RLP, not SSZ?</strong>

<p>The <code>blockAccessList</code> is transmitted as raw RLP bytes (<code>DATA</code>), not as structured JSON. This is intentional:</p>

<ul><li><strong>Efficiency</strong>: BALs can be large (hundreds of KB). RLP is more compact than JSON.</li>
<li><strong>Hash consistency</strong>: The EL computes <code>block_access_list_hash = keccak256(rlp_encoded_bal)</code>. Sending raw bytes ensures CL and EL agree on the hash input.</li>
<li><strong>Layering</strong>: The CL treats the BAL as opaque bytes—it doesn't need to parse the RLP structure.</li>
</ul>
<strong>Why <code>slotNumber</code>?</strong>

<p>This field enables the EL to know which beacon slot the block is for, which is useful for: <ul><li>MEV-related timing games (knowing how much of the slot has elapsed)</li> <li>Cross-referencing EL blocks with CL attestations</li> <li>Future slot-aware execution features</li> </ul> <strong>Gotchas</strong>: <ul><li><code>blockAccessList</code> is NOT nullable in V4. Pre-Amsterdam blocks use older payload versions.</li> <li>The <code>blockHash</code> includes the <code>block_access_list_hash</code> in the header—if the BAL is wrong, the hash won't match.</li> </ul> <strong>Cross-references</strong>: <ul><li>Section 01: RLP Types — BAL encoding format</li> <li>Section 12: Consensus Layer — how CL wraps this payload</li> </ul> <hr></p>

<h3><code>ExecutionPayloadBodyV2</code> (lines 40-46)</h3>

<pre><code class="language-markdown">This structure has the syntax of [`ExecutionPayloadBodyV1`](./shanghai.md#executionpayloadbodyv1) 
and appends the new field: `blockAccessList`.

- `transactions`: `Array of DATA` - Array of transaction objects...
- `withdrawals`: `Array of WithdrawalV1` - Array of withdrawals...
- `blockAccessList`: `DATA|null` - RLP-encoded block access list...</code></pre>

<strong>Purpose</strong>: A "body-only" view of the payload, used for historical block retrieval.

<strong>Why nullable?</strong>

<pre><code class="language-markdown">Value is `null` for blocks produced before Amsterdam or if the data has been pruned.</code></pre>

<p>Unlike <code>ExecutionPayloadV4</code>, the body structure is used retrospectively to fetch old blocks. This creates two null cases:</p>

<ul><li><strong>Pre-fork blocks</strong>: Blocks before Amsterdam activation have no BAL.</li>
<li><strong>Pruned data</strong>: Clients may discard BALs after some retention period.</li>
</ul>
<strong>Why separate from full payload?</strong>

<p>The "body" methods (<code>getPayloadBodiesByHash</code>, <code>getPayloadBodiesByRange</code>) are designed for sync and historical queries. They don't include header fields like <code>stateRoot</code> or <code>parentHash</code> because: <ul><li>Callers typically already have the header</li> <li>Omitting duplicated data saves bandwidth</li> </ul> <strong>Gotchas</strong>: <ul><li>Null handling is mandatory—clients must not crash on missing BALs.</li> <li>Pruning behavior is implementation-defined. The spec doesn't mandate retention periods.</li> </ul> <hr></p>

<h2>Methods</h2>

<h3><code>engine_newPayloadV5</code> (lines 50-71)</h3>

<pre><code class="language-markdown">This method is updated to support the new `ExecutionPayloadV4` structure.

#### Request

* method: `engine_newPayloadV5`
* params:
  1. `executionPayload`: [`ExecutionPayloadV4`](#executionpayloadv4).
  2. `expectedBlobVersionedHashes`: `Array of DATA`, 32 Bytes
  3. `parentBeaconBlockRoot`: `DATA`, 32 Bytes
  4. `executionRequests`: `Array of DATA` - List of execution layer triggered requests.</code></pre>

<strong>Purpose</strong>: The CL sends a complete payload to the EL for validation and potential import.

<strong>Flow</strong>:
<pre><code class="language-text">CL receives block from network
    → CL extracts ExecutionPayload
    → CL calls engine_newPayloadV5(payload, blobs, parentRoot, requests)
    → EL validates payload (including BAL)
    → EL returns VALID/INVALID/SYNCING</code></pre>

<h4>Specification (lines 64-71)</h4>

<pre><code class="language-markdown">1. Client software **MUST** return `-38005: Unsupported fork` error if the 
   `timestamp` of the payload does not fall within the time frame of the 
   Amsterdam activation.

2. Client software **MUST** return `-32602: Invalid params` error if the 
   `blockAccessList` field is missing.

3. Client software **MUST** validate the `blockAccessList` field by executing 
   the payload's transactions and verifying that the computed access list 
   matches the provided one. If this validation fails, the call **MUST** return 
   `{status: INVALID, latestValidHash: null, validationError: errorMessage | null}`.</code></pre>

<strong>Rule 1: Fork enforcement</strong>

<p>Error code <code>-38005</code> means "you're using the wrong API version for this fork." The EL uses the payload's <code>timestamp</code> to determine which fork rules apply.</p>

<pre><code class="language-text">if timestamp &lt; AMSTERDAM_TIMESTAMP:
    return error(-38005, &quot;Unsupported fork&quot;)</code></pre>

<p>This ensures: <ul><li>CL can't accidentally send V5 requests for pre-Amsterdam blocks</li> <li>Prevents confusion during fork transition</li> </ul> <strong>Rule 2: Missing BAL is fatal</strong></p>

<p>A missing <code>blockAccessList</code> is a protocol violation, not a validation failure. The <code>-32602: Invalid params</code> error says "your request is malformed"—distinct from an INVALID payload status.</p>

<strong>Rule 3: BAL validation is re-execution</strong>

<p>This is the critical rule. The EL must:</p>

<ul><li>Execute all transactions in the payload</li>
<li>Build a BAL from the observed state accesses (see Section 06-07)</li>
<li>Compare the built BAL with the provided BAL</li>
<li>Return INVALID if they differ</li>
</ul>
<strong>Why re-execute instead of trusting the BAL?</strong>

<p>The BAL is <strong>not trusted input</strong>. A malicious proposer could include a wrong BAL to: <ul><li>Cause validators to disagree on validity</li> <li>Enable state reconstruction attacks</li> <li>Break parallel execution invariants</li> </ul> By re-executing and comparing, the EL ensures the BAL is exactly what a correct execution would produce.</p>

<strong>Performance implication</strong>: BAL validation has the same cost as block execution. There's no shortcut. However, <em>after</em> validation, the BAL enables parallelization for state root computation and sync.

<strong>Error response semantics</strong>:

<pre><code class="language-json">{
  &quot;status&quot;: &quot;INVALID&quot;,
  &quot;latestValidHash&quot;: null,
  &quot;validationError&quot;: &quot;blockAccessList mismatch at account 0x...&quot;
}</code></pre>

<ul><li><code>latestValidHash: null</code> — The EL doesn't know where the chain diverged</li>
<li><code>validationError</code> — Human-readable error (optional)</li>
</ul>
<strong>Cross-references</strong>:
<ul><li>Section 06-07: BAL Builder — how the comparison BAL is constructed</li>
<li>Section 08: Block Processing — where validation integrates into <code>process_block</code></li>
</ul>
<hr>

<h3><code>engine_getPayloadV6</code> (lines 73-101)</h3>

<pre><code class="language-markdown">This method is updated to return the new `ExecutionPayloadV4` structure.

#### Request

* method: `engine_getPayloadV6`
* params:
  1. `payloadId`: `DATA`, 8 Bytes - Identifier of the payload build process
* timeout: 1s</code></pre>

<strong>Purpose</strong>: CL asks EL to produce a block. EL returns a complete payload including the BAL.

<strong>Flow</strong>:
<pre><code class="language-text">CL selects proposer for slot N
    → CL calls engine_forkchoiceUpdatedV4 with PayloadAttributesV4
    → EL begins building block, returns payloadId
    → CL waits (up to timeout)
    → CL calls engine_getPayloadV6(payloadId)
    → EL returns ExecutionPayloadV4 with BAL populated
    → CL wraps payload in BeaconBlock and broadcasts</code></pre>

<h4>Response (lines 81-89)</h4>

<pre><code class="language-markdown">* result: `object`
  - `executionPayload`: [`ExecutionPayloadV4`](#executionpayloadv4)
  - `blockValue` : `QUANTITY`, 256 Bits - The expected value to be received by 
    the `feeRecipient` in wei
  - `blobsBundle`: [`BlobsBundleV2`](./osaka.md#blobsbundlev2)
  - `shouldOverrideBuilder` : `BOOLEAN` - Suggestion from the execution layer 
    to use this `executionPayload` instead of an externally provided one
  - `executionRequests`: `Array of DATA` - Execution layer triggered requests...</code></pre>

<strong>Why <code>blockValue</code>?</strong>

<p>MEV-boost integration. The CL compares local <code>blockValue</code> against builder bids to decide whether to use the local block or accept a builder's block.</p>

<strong>Why <code>shouldOverrideBuilder</code>?</strong>

<p>Edge cases where the EL knows the builder block is suboptimal: <ul><li>Builder block fails validation</li> <li>Builder block has lower value than claimed</li> <li>Censorship resistance concerns</li> </ul> <h4>Specification (lines 93-101)</h4></p>

<pre><code class="language-markdown">1. Client software **MUST** return `-38005: Unsupported fork` error if the 
   `timestamp` of the built payload does not fall within the time frame of the 
   Amsterdam activation.

2. When building the block, client software **MUST** collect all account 
   accesses and state changes during transaction execution and populate the 
   `blockAccessList` field in the returned `ExecutionPayloadV4` with the 
   RLP-encoded access list.</code></pre>

<strong>Rule 2: BAL construction is mandatory</strong>

<p>The EL doesn't have a choice—when building an Amsterdam block, it MUST:</p>

<ul><li>Track all state accesses during execution (see Section 03-05: State Tracker)</li>
<li>Build the BAL after transaction execution (see Section 06-07: Builder)</li>
<li>RLP-encode and include in the payload</li>
</ul>
<strong>Builder vs Validator divergence risk</strong>

<p>A subtle issue: if the block builder's EL constructs the BAL differently than validators' ELs reconstruct it, the block will be rejected. This is why the BAL spec is so precise about: <ul><li>Ordering (lexicographic by address, then by slot)</li> <li>Net-zero filtering (changes that result in no net change are excluded)</li> <li>Gas validation rules (which accesses are included vs excluded)</li> </ul> See Section 07: Builder Finalization for the deterministic construction algorithm.</p>

<strong>Cross-references</strong>:
<ul><li>Section 06-07: BAL Builder — construction during block building</li>
<li>Section 03-05: State Tracker — how accesses are recorded</li>
</ul>
<hr>

<h3><code>engine_getPayloadBodiesByHashV2</code> (lines 103-121)</h3>

<pre><code class="language-markdown">This method retrieves execution payload bodies including block access lists 
for specified blocks.

#### Request

* method: `engine_getPayloadBodiesByHashV2`
* params:
  1. `blockHashes`: `Array of DATA`, 32 Bytes - Array of block hashes
* timeout: 10s</code></pre>

<strong>Purpose</strong>: Fetch historical block bodies by hash, now including BALs.

<strong>Use cases</strong>:
<ul><li><strong>Sync</strong>: New nodes catching up on historical blocks</li>
<li><strong>Reorg handling</strong>: Re-fetching blocks after a chain reorganization</li>
<li><strong>Archive queries</strong>: Historical analysis</li>
</ul>
<h4>Specification (lines 118-121)</h4>

<pre><code class="language-markdown">1. Client software **MUST** set the `blockAccessList` field to `null` for 
   blocks that predate the Amsterdam fork activation.

2. Client software **MUST** set the `blockAccessList` field to `null` if 
   the block access list has been pruned from storage.</code></pre>

<strong>Rule 1: Pre-fork null handling</strong>

<p>When querying a pre-Amsterdam block hash, the response includes <code>null</code> for <code>blockAccessList</code>. This is NOT an error—it's expected behavior.</p>

<pre><code class="language-json">{
  &quot;transactions&quot;: [...],
  &quot;withdrawals&quot;: [...],
  &quot;blockAccessList&quot;: null  // Pre-Amsterdam or pruned
}</code></pre>

<strong>Rule 2: Pruning tolerance</strong>

<p>EL clients may prune BALs to save storage. The spec explicitly permits this: <ul><li>Callers must handle null gracefully</li> <li>There's no mandatory retention period</li> <li>Archive nodes may retain longer than full nodes</li> </ul> <strong>Why allow pruning?</strong></p>

<p>BALs can be large. For a worst-case block: <ul><li>~6,000 unique addresses touched</li> <li>Each with multiple storage slots</li> <li>RLP overhead per entry</li> </ul> Estimates suggest BALs average 50-200 KB per block, but can reach 500+ KB. At 12-second block times, that's ~1.5 TB/year just for BALs if not pruned.</p>

<strong>Gotchas</strong>:
<ul><li>Don't assume <code>null</code> means error—check block timestamp vs fork activation</li>
<li>If you need guaranteed BAL availability, use an archive node</li>
</ul>
<hr>

<h3><code>engine_getPayloadBodiesByRangeV2</code> (lines 123-145)</h3>

<pre><code class="language-markdown">This method retrieves execution payload bodies including block access lists 
for a range of blocks.

#### Request

* method: `engine_getPayloadBodiesByRangeV2`
* params:
  1. `start`: `QUANTITY`, 64 Bits - Starting block number
  2. `count`: `QUANTITY`, 64 Bits - Number of blocks to retrieve
* timeout: 10s</code></pre>

<strong>Purpose</strong>: Batch fetch of historical blocks by number range.

<strong>Why range queries?</strong>

<p>More efficient for sequential sync than individual hash lookups: <ul><li>Single round-trip for many blocks</li> <li>Natural for "give me blocks 1000-2000" during initial sync</li> </ul> The specification rules mirror <code>getPayloadBodiesByHashV2</code>:</p>

<pre><code class="language-markdown">1. Client software **MUST** set the `blockAccessList` field to `null` for 
   blocks that predate the Amsterdam fork activation.

2. Client software **MUST** set the `blockAccessList` field to `null` if 
   the block access list has been pruned from storage.</code></pre>

<strong>Mixed-fork ranges</strong>

<p>A range query spanning the Amsterdam fork returns: <ul><li><code>null</code> BALs for pre-fork blocks</li> <li>Actual BALs for post-fork blocks</li> </ul> <pre><code class="language-text">Request: start=15537390, count=5 (assuming fork at 15537393)
Response: [null, null, null, &lt;BAL&gt;, &lt;BAL&gt;]</code></pre></p>

<hr>

<h3><code>engine_forkchoiceUpdatedV4</code> (lines 147-185)</h3>

<pre><code class="language-markdown">#### Request

* method: `engine_forkchoiceUpdatedV4`
* params:
  1. `forkchoiceState`: [`ForkchoiceStateV1`](./paris.md#ForkchoiceStateV1).
  2. `payloadAttributes`: `Object|null` - Instance of [`PayloadAttributesV4`] or `null`.
* timeout: 8s</code></pre>

<strong>Purpose</strong>: CL tells EL the current fork choice head, and optionally asks EL to start building a new block.

<strong>Dual role</strong>:
<ul><li><strong>Fork choice update</strong>: "This is the canonical head now"</li>
<li><strong>Block building trigger</strong>: "Start building a block with these attributes"</li>
</ul>
If <code>payloadAttributes</code> is non-null, the EL returns a <code>payloadId</code> that the CL uses later with <code>engine_getPayloadV6</code>.

<h4>Specification (lines 174-185)</h4>

<pre><code class="language-markdown">1. Client software **MUST** verify that `forkchoiceState` matches the 
   [`ForkchoiceStateV1`](./paris.md#ForkchoiceStateV1) structure and return 
   `-32602: Invalid params` on failure.

2. Extend point (7) of the `engine_forkchoiceUpdatedV1` [specification] by 
   defining the following sequence of checks:

    1. `payloadAttributes` matches the [`PayloadAttributesV4`] structure
    2. `payloadAttributes.timestamp` does not fall within the time frame of 
       the Amsterdam fork, return `-38005: Unsupported fork` on failure.
    3. `payloadAttributes.timestamp` is greater than `timestamp` of a block 
       referenced by `forkchoiceState.headBlockHash`
    4. If any of the above checks fails, the `forkchoiceState` update 
       **MUST NOT** be rolled back.</code></pre>

<strong>Check 4 is subtle</strong>: If payload attributes validation fails, the fork choice state update still applies. This prevents:
<ul><li>CL sending bad attributes → EL rejects → CL retries with same state</li>
<li>Wasted work re-processing the fork choice update</li>
</ul>
<strong>Error atomicity</strong>:
<pre><code class="language-text">forkchoiceState update: SUCCESS
payloadAttributes validation: FAIL (-38003)
Result: forkchoiceState applied, no payload building started</code></pre>

<hr>

<h3><code>PayloadAttributesV4</code> (lines 187-196)</h3>

<pre><code class="language-markdown">This structure has the syntax of [`PayloadAttributesV3`](./cancun.md#payloadattributesv3) 
and appends a single field: `slotNumber`.

- `timestamp`: `QUANTITY`, 64 Bits
- `prevRandao`: `DATA`, 32 Bytes
- `suggestedFeeRecipient`: `DATA`, 20 Bytes
- `withdrawals`: `Array of WithdrawalV1`
- `parentBeaconBlockRoot`: `DATA`, 32 Bytes
- `slotNumber`: `QUANTITY`, 64 Bits</code></pre>

<strong>Why <code>slotNumber</code> in attributes?</strong>

<p>The CL passes the slot number so the EL can include it in the payload. This is a new Amsterdam field that: <ul><li>Lets EL know the exact beacon slot</li> <li>Enables slot-aware block building (MEV timing)</li> <li>Provides cross-layer consistency</li> </ul> <strong>Note</strong>: <code>slotNumber</code> was added alongside BALs but isn't directly related to BAL functionality.</p>

<hr>

<h3>Update the Methods of Previous Forks (lines 198-211)</h3>

<pre><code class="language-markdown">#### Osaka API

For the following methods:

- [`engine_newPayloadV4`](./prague.md#engine_newpayloadv4)
- [`engine_getPayloadV5`](./osaka.md#engine_getpayloadv5)
- [`engine_forkchoiceUpdatedV3`](./cancun.md#engine_forkchoiceupdatedv3)

a validation **MUST** be added:

1. Client software **MUST** return `-38005: Unsupported fork` error if the 
   `timestamp` of payload greater or equal to the Amsterdam activation timestamp.</code></pre>

<strong>Purpose</strong>: Prevent old API versions from being used for Amsterdam blocks.

<strong>Why explicitly disable?</strong>

<p>Without this rule, a misconfigured client might: <ul><li>Use <code>engine_newPayloadV4</code> for an Amsterdam block</li> <li>Validation passes (no BAL field expected)</li> <li>Block is accepted without BAL validation</li> <li>Chain split between V4 and V5 clients</li> </ul> By mandating <code>-38005</code> for old methods on new timestamps, the spec ensures fail-fast behavior.</p>

<strong>Upgrade coordination</strong>:
<pre><code class="language-text">Before Amsterdam: V4/V5 methods work
At Amsterdam: V4 rejects, V5 required
After Amsterdam: V4 always rejects for new blocks</code></pre>

<hr>

<h2>Error Code Reference</h2>

<table><tr><th>Code</th><th>Name</th><th>When</th></tr>
<tr><td><code>-32602</code></td><td>Invalid params</td><td>Malformed request (missing fields, wrong types)</td></tr>
<tr><td><code>-38003</code></td><td>Invalid payload attributes</td><td>PayloadAttributes validation failed</td></tr>
<tr><td><code>-38005</code></td><td>Unsupported fork</td><td>Timestamp/method version mismatch</td></tr></table>
<strong>Error vs INVALID status</strong>:
<ul><li>Error codes: Request-level problems (bad JSON, wrong method version)</li>
<li>INVALID status: Payload-level problems (bad BAL, invalid state root)</li>
</ul>
<hr>

<h2>Cross-References</h2>

<table><tr><th>Section</th><th>Connection</th></tr>
<tr><td>Section 01: RLP Types</td><td>BAL encoding format for <code>blockAccessList</code> field</td></tr>
<tr><td>Section 06-07: BAL Builder</td><td>How BALs are constructed for <code>getPayloadV6</code></td></tr>
<tr><td>Section 08: Block Processing</td><td>BAL validation during <code>newPayloadV5</code></td></tr>
<tr><td>Section 12: Consensus Layer</td><td>CL containers that wrap these payloads</td></tr>
<tr><td>Section 13: eth/71 Protocol</td><td>Alternative BAL retrieval path (devp2p)</td></tr></table>
<hr>

<h2>Implementation Notes</h2>

<h3>Timeout Implications</h3>

<table><tr><th>Method</th><th>Timeout</th><th>Implication</th></tr>
<tr><td><code>getPayloadV6</code></td><td>1s</td><td>Block building must be fast enough</td></tr>
<tr><td><code>getPayloadBodiesBy*</code></td><td>10s</td><td>Historical queries can be slower</td></tr>
<tr><td><code>forkchoiceUpdatedV4</code></td><td>8s</td><td>Complex state updates allowed</td></tr></table>
The 1s timeout on <code>getPayloadV6</code> is tight. If BAL construction is slow, it could delay block production. Implementations should:
<ul><li>Build BAL incrementally during execution</li>
<li>Not defer BAL construction to the <code>getPayload</code> call</li>
</ul>
<h3>Bandwidth Considerations</h3>

<p>For syncing nodes, <code>getPayloadBodiesByRangeV2</code> now returns significantly more data due to BALs. Clients should: <ul><li>Consider BAL size when setting <code>count</code> parameter</li> <li>Be prepared for larger responses</li> <li>Possibly prune BALs earlier on bandwidth-constrained nodes</li> </ul> <h3>Version Negotiation</h3></p>

<p>The Engine API uses method names for versioning, not protocol negotiation. Clients must: <ul><li>Support all active versions (V4 for pre-Amsterdam, V5 for Amsterdam+)</li> <li>Route requests based on block timestamp</li> <li>Reject cross-version misuse with <code>-38005</code></li> </ul></p>
</section>

<section id="section-12-consensus-layer">
<h1>Section 12: Consensus Layer</h1>

<h2>Source Files</h2>
<ul><li><code>specs/consensus-specs/specs/_features/eip7928/beacon-chain.md</code> (199 lines)</li>
<li><code>specs/consensus-specs/specs/_features/eip7928/p2p-interface.md</code> (40 lines)</li>
</ul>
<h2>Overview</h2>

<p>The Consensus Layer (CL) changes for EIP-7928 are minimal by design. The CL doesn't interpret the Block Access List (BAL)—it treats it as an opaque blob of bytes that it:</p>

<ul><li>Receives from the Execution Layer (EL) via the Engine API</li>
<li>Stores in the <code>ExecutionPayload</code> container</li>
<li>Commits to via <code>hash_tree_root</code> in the <code>ExecutionPayloadHeader</code></li>
<li>Passes to the EL for validation during <code>process_execution_payload</code></li>
</ul>
This section covers the SSZ type definitions, container modifications, and the single function change needed to support BALs in the beacon chain.

<hr>

<h2>Design Philosophy: CL as Opaque Carrier</h2>

<p>The consensus layer has a clear boundary: it handles consensus (validators, slots, attestations) and treats execution data as opaque. This is evident in how the BAL is typed:</p>

<pre><code class="language-text">BlockAccessList = ByteList[MAX_BYTES_PER_TRANSACTION]</code></pre>

<p>Not a structured type. Just bytes. The CL doesn't know or care what's inside—that's the EL's job.</p>

<strong>Why this layering matters</strong>:

<ul><li><strong>Upgrade independence</strong>: The EL can change BAL encoding (e.g., compression) without CL changes</li>
<li><strong>Validation separation</strong>: The CL validates SSZ structure; the EL validates semantic correctness</li>
<li><strong>Simpler CL clients</strong>: No need to implement RLP parsing or BAL logic</li>
<li><strong>Attack surface reduction</strong>: CL bugs can't corrupt BAL validation, and vice versa</li>
</ul>
This is the same pattern used for <code>transactions</code> (also <code>ByteList</code>), <code>withdrawals</code>, and <code>execution_requests</code>.

<hr>

<h2>Type Definitions</h2>

<h3><code>BlockAccessList</code> Type (beacon-chain.md, lines 24-26)</h3>

<pre><code class="language-python">| Name              | SSZ equivalent                        | Description                   |
| ----------------- | ------------------------------------- | ----------------------------- |
| `BlockAccessList` | `ByteList[MAX_BYTES_PER_TRANSACTION]` | RLP encoded block access list |</code></pre>

<strong>Purpose</strong>: Define an SSZ-compatible type for the BAL bytes.

<strong>Why <code>ByteList[MAX_BYTES_PER_TRANSACTION]</code>?</strong>

<p>The size bound is inherited from the existing <code>MAX_BYTES_PER_TRANSACTION</code> constant, which is <strong>1,073,741,824 bytes (1 GiB)</strong>. This is deliberately enormous—far larger than any realistic BAL—because:</p>

<ul><li><strong>Future-proofing</strong>: BAL size depends on state access patterns, which could grow</li>
<li><strong>Consistency</strong>: Using an existing constant avoids introducing new limits</li>
<li><strong>Practical ceiling</strong>: A 1 GiB BAL would require hundreds of millions of storage accesses, which is impossible within gas limits</li>
</ul>
<strong>Actual expected sizes</strong>:

<table><tr><th>Block type</th><th>Expected BAL size</th><th>Notes</th></tr>
<tr><td>Empty block</td><td>~100 bytes</td><td>Only system calls (beacon root, withdrawals)</td></tr>
<tr><td>Typical mainnet</td><td>10-100 KB</td><td>~200 unique accounts, ~500 storage slots</td></tr>
<tr><td>DEX-heavy block</td><td>100-500 KB</td><td>Many AMM pool interactions</td></tr>
<tr><td>Worst-case spam</td><td>1-5 MB</td><td>Adversarial access pattern</td></tr></table>
<strong>Gotcha</strong>: The 1 GiB limit is an SSZ encoding limit, not a consensus limit. Gas costs naturally constrain BAL size—you can't access enough state to fill 1 GiB.

<strong>Cross-references</strong>:
<ul><li>Section 01: RLP Types — The actual encoding within these bytes</li>
<li>Section 11: Engine API — How <code>blockAccessList</code> is transmitted as raw <code>DATA</code></li>
</ul>
<hr>

<h2>Extended Containers</h2>

<h3><code>ExecutionPayload</code> (beacon-chain.md, lines 30-51)</h3>

<pre><code class="language-python">class ExecutionPayload(Container):
    parent_hash: Hash32
    fee_recipient: ExecutionAddress
    state_root: Bytes32
    receipts_root: Bytes32
    logs_bloom: ByteVector[BYTES_PER_LOGS_BLOOM]
    prev_randao: Bytes32
    block_number: uint64
    gas_limit: uint64
    gas_used: uint64
    timestamp: uint64
    extra_data: ByteList[MAX_EXTRA_DATA_BYTES]
    base_fee_per_gas: uint256
    block_hash: Hash32
    transactions: List[Transaction, MAX_TRANSACTIONS_PER_PAYLOAD]
    withdrawals: List[Withdrawal, MAX_WITHDRAWALS_PER_PAYLOAD]
    blob_gas_used: uint64
    excess_blob_gas: uint64
    # [New in EIP7928]
    block_access_list: BlockAccessList</code></pre>

<strong>Purpose</strong>: The full execution payload container, extended with the BAL.

<strong>Field position matters</strong>:

<p>The <code>block_access_list</code> field is added <strong>at the end</strong> of the container. This is critical for SSZ:</p>

<ul><li><strong>Backwards compatibility of hash_tree_root</strong>: Adding fields at the end preserves the Merkle tree structure for all preceding fields</li>
<li><strong>Generalized indices stability</strong>: Light clients using generalized indices for proof verification don't break</li>
<li><strong>Optional field pattern</strong>: SSZ supports "extending" containers by appending fields</li>
</ul>
<strong>What the CL receives</strong>:

<p>The CL receives this container from the EL via <code>engine_getPayloadV6</code>. The <code>block_access_list</code> field contains raw RLP bytes that the CL stores but doesn't interpret:</p>

<pre><code class="language-text">EL builds block → EL populates block_access_list → EL sends ExecutionPayloadV4 via Engine API
                                                            ↓
CL receives → CL wraps in SSZ ExecutionPayload → CL gossips BeaconBlock</code></pre>

<strong>Relationship to Engine API</strong>:

<table><tr><th>Engine API field</th><th>SSZ container field</th><th>Encoding</th></tr>
<tr><td><code>ExecutionPayloadV4.blockAccessList</code></td><td><code>ExecutionPayload.block_access_list</code></td><td>RLP bytes</td></tr></table>
The naming convention differs slightly (<code>blockAccessList</code> vs <code>block_access_list</code>) due to JSON/SSZ conventions.

<strong>Cross-references</strong>:
<ul><li>Section 11: Engine API — <code>ExecutionPayloadV4</code> structure</li>
</ul>
<hr>

<h3><code>ExecutionPayloadHeader</code> (beacon-chain.md, lines 53-73)</h3>

<pre><code class="language-python">class ExecutionPayloadHeader(Container):
    parent_hash: Hash32
    fee_recipient: ExecutionAddress
    state_root: Bytes32
    receipts_root: Bytes32
    logs_bloom: ByteVector[BYTES_PER_LOGS_BLOOM]
    prev_randao: Bytes32
    block_number: uint64
    gas_limit: uint64
    gas_used: uint64
    timestamp: uint64
    extra_data: ByteList[MAX_EXTRA_DATA_BYTES]
    base_fee_per_gas: uint256
    block_hash: Hash32
    transactions_root: Root
    withdrawals_root: Root
    blob_gas_used: uint64
    excess_blob_gas: uint64
    # [New in EIP7928]
    block_access_list_root: Root</code></pre>

<strong>Purpose</strong>: A compact commitment to the execution payload, used in <code>BeaconState</code>.

<strong>Key distinction: <code>block_access_list</code> vs <code>block_access_list_root</code></strong>:

<table><tr><th>Container</th><th>Field</th><th>Type</th><th>Contains</th></tr>
<tr><td><code>ExecutionPayload</code></td><td><code>block_access_list</code></td><td><code>BlockAccessList</code> (bytes)</td><td>Full RLP-encoded BAL</td></tr>
<tr><td><code>ExecutionPayloadHeader</code></td><td><code>block_access_list_root</code></td><td><code>Root</code> (32 bytes)</td><td><code>hash_tree_root(block_access_list)</code></td></tr></table>
The header stores a <strong>commitment</strong> (root), not the full data. This enables:

<ul><li><strong>State size efficiency</strong>: <code>BeaconState</code> stores the header, not the full payload</li>
<li><strong>Light client proofs</strong>: Prove BAL inclusion without transmitting the full BAL</li>
<li><strong>Gossip efficiency</strong>: Headers can be verified before requesting full payloads</li>
</ul>
<strong>Why <code>hash_tree_root</code>, not <code>keccak256</code>?</strong>

<p>This is subtle but important. The <code>block_access_list_root</code> uses SSZ's <code>hash_tree_root</code>, while the EL's <code>block_access_list_hash</code> uses <code>keccak256(rlp_encoded_bal)</code>:</p>

<table><tr><th>Layer</th><th>Commitment</th><th>Hash function</th><th>Input</th></tr>
<tr><td>EL (Header)</td><td><code>block_access_list_hash</code></td><td>keccak256</td><td>RLP bytes</td></tr>
<tr><td>CL (Header)</td><td><code>block_access_list_root</code></td><td>hash_tree_root</td><td>SSZ ByteList</td></tr></table>
<strong>These are different hashes of the same data!</strong>

<ul><li>EL: <code>keccak256(rlp_bytes)</code> — used in block hash, validates BAL correctness</li>
<li>CL: <code>hash_tree_root(ByteList(rlp_bytes))</code> — used in SSZ Merkleization, enables CL proofs</li>
</ul>
This duality exists because each layer uses its native hash function. The CL doesn't need to compute <code>keccak256</code>—it delegates that validation to the EL via <code>verify_and_notify_new_payload</code>.

<strong>Cross-references</strong>:
<ul><li>Section 08: Block Processing — EL's <code>block_access_list_hash</code> computation</li>
</ul>
<hr>

<h3><code>BeaconState</code> (beacon-chain.md, lines 75-114)</h3>

<pre><code class="language-python">class BeaconState(Container):
    genesis_time: uint64
    genesis_validators_root: Root
    slot: Slot
    fork: Fork
    latest_block_header: BeaconBlockHeader
    block_roots: Vector[Root, SLOTS_PER_HISTORICAL_ROOT]
    state_roots: Vector[Root, SLOTS_PER_HISTORICAL_ROOT]
    historical_roots: List[Root, HISTORICAL_ROOTS_LIMIT]
    eth1_data: Eth1Data
    eth1_data_votes: List[Eth1Data, EPOCHS_PER_ETH1_VOTING_PERIOD * SLOTS_PER_EPOCH]
    eth1_deposit_index: uint64
    validators: List[Validator, VALIDATOR_REGISTRY_LIMIT]
    balances: List[Gwei, VALIDATOR_REGISTRY_LIMIT]
    randao_mixes: Vector[Bytes32, EPOCHS_PER_HISTORICAL_VECTOR]
    slashings: Vector[Gwei, EPOCHS_PER_SLASHINGS_VECTOR]
    previous_epoch_participation: List[ParticipationFlags, VALIDATOR_REGISTRY_LIMIT]
    current_epoch_participation: List[ParticipationFlags, VALIDATOR_REGISTRY_LIMIT]
    justification_bits: Bitvector[JUSTIFICATION_BITS_LENGTH]
    previous_justified_checkpoint: Checkpoint
    current_justified_checkpoint: Checkpoint
    finalized_checkpoint: Checkpoint
    inactivity_scores: List[uint64, VALIDATOR_REGISTRY_LIMIT]
    current_sync_committee: SyncCommittee
    next_sync_committee: SyncCommittee
    # [Modified in EIP7928]
    latest_execution_payload_header: ExecutionPayloadHeader
    next_withdrawal_index: WithdrawalIndex
    next_withdrawal_validator_index: ValidatorIndex
    historical_summaries: List[HistoricalSummary, HISTORICAL_ROOTS_LIMIT]
    deposit_requests_start_index: uint64
    deposit_balance_to_consume: Gwei
    exit_balance_to_consume: Gwei
    earliest_exit_epoch: Epoch
    consolidation_balance_to_consume: Gwei
    earliest_consolidation_epoch: Epoch
    pending_deposits: List[PendingDeposit, PENDING_DEPOSITS_LIMIT]
    pending_partial_withdrawals: List[PendingPartialWithdrawal, PENDING_PARTIAL_WITHDRAWALS_LIMIT]
    pending_consolidations: List[PendingConsolidation, PENDING_CONSOLIDATIONS_LIMIT]
    proposer_lookahead: Vector[ValidatorIndex, (MIN_SEED_LOOKAHEAD + 1) * SLOTS_PER_EPOCH]</code></pre>

<strong>Purpose</strong>: The full beacon chain state, extended with the modified <code>ExecutionPayloadHeader</code> type.

<strong>What changes</strong>:

<p>The <code>BeaconState</code> itself doesn't gain new fields—it's the <strong>type</strong> of <code>latest_execution_payload_header</code> that changes:</p>

<pre><code class="language-text">Before EIP-7928: latest_execution_payload_header: ExecutionPayloadHeader  # Fulu version
After EIP-7928:  latest_execution_payload_header: ExecutionPayloadHeader  # EIP7928 version</code></pre>

<p>Same field name, different container definition. The EIP-7928 version has <code>block_access_list_root</code>.</p>

<strong>State transition implications</strong>:

<p>When a block is processed, <code>latest_execution_payload_header</code> is updated to include the new BAL root:</p>

<pre><code class="language-text">Block N processed → state.latest_execution_payload_header.block_access_list_root updated</code></pre>

<p>This enables: <ul><li>Verification that subsequent blocks reference valid execution state</li> <li>Historical proofs about what BAL was committed to at each slot</li> </ul> <hr></p>

<h3><code>NewPayloadRequest</code> (beacon-chain.md, lines 116-119)</h3>

<pre><code class="language-markdown">*Note*: The `NewPayloadRequest` is unchanged. The `block_access_list` is
included in the `execution_payload` field.</code></pre>

<strong>Purpose</strong>: Clarify that no separate BAL transmission is needed.

<strong>Why explicitly state "unchanged"?</strong>

<p>Previous EIP additions sometimes required new fields in <code>NewPayloadRequest</code>. For example: <ul><li>EIP-4844 added <code>versioned_hashes</code> and <code>parent_beacon_block_root</code></li> <li>EIP-7685 added <code>execution_requests</code></li> </ul> EIP-7928 is different: the BAL is embedded <strong>inside</strong> the <code>execution_payload</code>, so no structural change to the request is needed. The EL extracts <code>block_access_list</code> from the payload directly.</p>

<strong>Data flow</strong>:

<pre><code class="language-text">CL: NewPayloadRequest(
    execution_payload=ExecutionPayload(
        ...,
        block_access_list=&lt;RLP bytes&gt;  # BAL embedded here
    ),
    versioned_hashes=[...],
    parent_beacon_block_root=...,
    execution_requests=[...]
)
                    ↓
EL: Extracts block_access_list from payload, validates against computed BAL</code></pre>

<hr>

<h2>Beacon Chain State Transition Function</h2>

<h3>Modified <code>process_execution_payload</code> (beacon-chain.md, lines 127-199)</h3>

<pre><code class="language-python">def process_execution_payload(
    state: BeaconState, body: BeaconBlockBody, execution_engine: ExecutionEngine
) -&gt; None:
    payload = body.execution_payload

    # Verify consistency of the parent hash with respect to the previous execution payload header
    assert payload.parent_hash == state.latest_execution_payload_header.block_hash
    # Verify prev_randao
    assert payload.prev_randao == get_randao_mix(state, get_current_epoch(state))
    # Verify timestamp
    assert payload.timestamp == compute_time_at_slot(state, state.slot)
    # Verify commitments are under limit
    assert (
        len(body.blob_kzg_commitments)
        &lt;= get_blob_parameters(get_current_epoch(state)).max_blobs_per_block
    )

    # Compute list of versioned hashes
    versioned_hashes = [
        kzg_commitment_to_versioned_hash(commitment) for commitment in body.blob_kzg_commitments
    ]

    # Verify the execution payload is valid
    assert execution_engine.verify_and_notify_new_payload(
        NewPayloadRequest(
            execution_payload=payload,
            versioned_hashes=versioned_hashes,
            parent_beacon_block_root=state.latest_block_header.parent_root,
            execution_requests=body.execution_requests,
        )
    )

    # Cache execution payload header
    state.latest_execution_payload_header = ExecutionPayloadHeader(
        parent_hash=payload.parent_hash,
        fee_recipient=payload.fee_recipient,
        state_root=payload.state_root,
        receipts_root=payload.receipts_root,
        logs_bloom=payload.logs_bloom,
        prev_randao=payload.prev_randao,
        block_number=payload.block_number,
        gas_limit=payload.gas_limit,
        gas_used=payload.gas_used,
        timestamp=payload.timestamp,
        extra_data=payload.extra_data,
        base_fee_per_gas=payload.base_fee_per_gas,
        block_hash=payload.block_hash,
        transactions_root=hash_tree_root(payload.transactions),
        withdrawals_root=hash_tree_root(payload.withdrawals),
        blob_gas_used=payload.blob_gas_used,
        excess_blob_gas=payload.excess_blob_gas,
        # [New in EIP7928]
        block_access_list_root=hash_tree_root(payload.block_access_list),
    )</code></pre>

<strong>Purpose</strong>: Process execution payloads, now including BAL commitment.

<strong>What changes vs Fulu</strong>:

<p>Only ONE line is added:</p>

<pre><code class="language-python">block_access_list_root=hash_tree_root(payload.block_access_list),</code></pre>

<p>This is the entire CL logic for EIP-7928. Everything else is unchanged.</p>

<strong>Detailed breakdown</strong>:

<table><tr><th>Lines</th><th>Purpose</th><th>EIP-7928 Change</th></tr>
<tr><td>131-140</td><td>Verify parent hash, randao, timestamp</td><td>None</td></tr>
<tr><td>141-145</td><td>Verify blob commitment count</td><td>None</td></tr>
<tr><td>147-150</td><td>Compute versioned hashes</td><td>None</td></tr>
<tr><td>152-159</td><td>Call EL for validation</td><td>None (BAL inside payload)</td></tr>
<tr><td>162-181</td><td>Update <code>latest_execution_payload_header</code></td><td>Add <code>block_access_list_root</code></td></tr></table>
<strong>Where BAL validation actually happens</strong>:

<p>The CL does NOT validate the BAL contents. It calls:</p>

<pre><code class="language-python">execution_engine.verify_and_notify_new_payload(NewPayloadRequest(...))</code></pre>

<p>This triggers the EL's <code>engine_newPayloadV5</code>, which: <ul><li>Executes transactions</li> <li>Builds the expected BAL</li> <li>Computes <code>keccak256(expected_bal_rlp)</code></li> <li>Compares against <code>block.header.block_access_list_hash</code></li> <li>Returns <code>VALID</code> or <code>INVALID</code></li> </ul> The CL only cares about the boolean result. If the EL says <code>VALID</code>, the CL trusts that the BAL is correct.</p>

<strong>Why <code>hash_tree_root</code> on bytes?</strong>

<p>When you call <code>hash_tree_root(ByteList)</code>, SSZ: <ul><li>Pads the bytes to a multiple of 32</li> <li>Chunks into 32-byte leaves</li> <li>Merkleizes the chunks</li> <li>Mixes in the length</li> </ul> This produces a 32-byte root that commits to the exact byte sequence. Any change to the BAL bytes changes the root.</p>

<strong>Edge case: Empty BAL</strong>:

<p>For blocks with no state changes (theoretically impossible in practice due to system calls), the BAL is <code>0xc0</code> (empty RLP list):</p>

<pre><code class="language-python">block_access_list = b'\xc0'  # RLP for []
block_access_list_root = hash_tree_root(ByteList(b'\xc0'))</code></pre>

<p>The CL handles this identically to any other BAL—it just commits to the bytes.</p>

<strong>Cross-references</strong>:
<ul><li>Section 08: Block Processing — EL-side <code>block_access_list_hash</code> validation</li>
<li>Section 11: Engine API — <code>engine_newPayloadV5</code> validation flow</li>
</ul>
<hr>

<h2>P2P Interface Modifications</h2>

<h3>Modified <code>compute_fork_version</code> (p2p-interface.md, lines 19-35)</h3>

<pre><code class="language-python">def compute_fork_version(epoch: Epoch) -&gt; Version:
    &quot;&quot;&quot;
    Return the fork version at the given ``epoch``.
    &quot;&quot;&quot;
    if epoch &gt;= EIP7928_FORK_EPOCH:
        return EIP7928_FORK_VERSION
    if epoch &gt;= FULU_FORK_EPOCH:
        return FULU_FORK_VERSION
    if epoch &gt;= ELECTRA_FORK_EPOCH:
        return ELECTRA_FORK_VERSION
    if epoch &gt;= DENEB_FORK_EPOCH:
        return DENEB_FORK_VERSION
    if epoch &gt;= CAPELLA_FORK_EPOCH:
        return CAPELLA_FORK_VERSION
    if epoch &gt;= BELLATRIX_FORK_EPOCH:
        return BELLATRIX_FORK_VERSION
    if epoch &gt;= ALTAIR_FORK_EPOCH:
        return ALTAIR_FORK_VERSION
    return GENESIS_FORK_VERSION</code></pre>

<strong>Purpose</strong>: Return the correct fork version for network protocol identification.

<strong>Why fork versions matter</strong>:

<p>Fork versions are 4-byte identifiers used throughout the CL networking stack:</p>

<table><tr><th>Usage</th><th>Purpose</th></tr>
<tr><td>ENR <code>eth2</code> field</td><td>Peer discovery filtering</td></tr>
<tr><td>Gossipsub topics</td><td>Topic name construction</td></tr>
<tr><td><code>ForkDigest</code></td><td>Domain separation in messages</td></tr>
<tr><td><code>SigningData</code></td><td>Signature domain separation</td></tr></table>
When EIP-7928 activates, nodes MUST use <code>EIP7928_FORK_VERSION</code> to:
<ul><li>Find peers on the correct fork</li>
<li>Subscribe to the correct gossip topics</li>
<li>Validate signatures with the correct domain</li>
</ul>
<strong>Network partition risk</strong>:

<p>If a node uses the wrong fork version: <ul><li>Pre-fork nodes reject post-fork blocks (different topics)</li> <li>Post-fork nodes reject pre-fork attestations (different domain)</li> <li>Network partitions along the fork boundary</li> </ul> This is intentional—it prevents accidental cross-fork message acceptance.</p>

<strong>Order of checks</strong>:

<p>The function checks forks in reverse chronological order: <pre><code class="language-text">EIP7928 → Fulu → Electra → Deneb → Capella → Bellatrix → Altair → Genesis</code></pre></p>

<p>This ensures the most recent applicable fork is returned. For <code>epoch = 500000</code>: <ul><li>If <code>EIP7928_FORK_EPOCH = 450000</code>, return <code>EIP7928_FORK_VERSION</code></li> <li>If <code>EIP7928_FORK_EPOCH = 600000</code>, fall through to Fulu check</li> </ul> <strong>What's NOT in this spec</strong>:</p>

<p>Notably absent from the p2p-interface.md: <ul><li>Topic changes (none needed—payload format changes, not topic structure)</li> <li>Req/resp changes (none needed—EIP-7928 doesn't add new CL requests)</li> <li>Gossip validation changes (none needed—CL treats BAL as opaque)</li> </ul> This is because EIP-7928 is execution-layer focused. The CL networking changes are minimal.</p>

<hr>

<h2>Cross-Layer Data Flow</h2>

<h3>Block Production Flow</h3>

<pre><code class="language-text">1. CL: Request payload via engine_forkchoiceUpdatedV4 (with PayloadAttributesV4)
   ↓
2. EL: Build block, record state accesses, construct BAL
   ↓
3. EL: Return ExecutionPayloadV4 via engine_getPayloadV6
   - Includes blockAccessList (RLP bytes)
   ↓
4. CL: Wrap in BeaconBlock
   - block.body.execution_payload.block_access_list = &lt;RLP bytes&gt;
   ↓
5. CL: Gossip BeaconBlock
   ↓
6. Validators: Attest to block (includes execution payload commitment)</code></pre>

<h3>Block Validation Flow</h3>

<pre><code class="language-text">1. CL: Receive BeaconBlock via gossip
   ↓
2. CL: Run process_execution_payload
   ↓
3. CL: Call verify_and_notify_new_payload(NewPayloadRequest)
   - Passes execution_payload (with block_access_list) to EL
   ↓
4. EL: Execute transactions, build expected BAL
   ↓
5. EL: Compute keccak256(expected_bal_rlp)
   ↓
6. EL: Compare against block.header.block_access_list_hash
   ↓
7. EL: Return {status: VALID} or {status: INVALID}
   ↓
8. CL: If VALID, update state.latest_execution_payload_header
   - Computes block_access_list_root = hash_tree_root(block_access_list)</code></pre>

<hr>

<h2>Gotchas and Edge Cases</h2>

<h3>1. Two Different Hashes for the Same Data</h3>

<p>The BAL has TWO commitments: <ul><li>EL: <code>keccak256(rlp_bytes)</code> in block header</li> <li>CL: <code>hash_tree_root(ByteList(rlp_bytes))</code> in <code>ExecutionPayloadHeader</code></li> </ul> These are NOT interchangeable. Don't confuse them in proofs.</p>

<h3>2. SSZ ByteList Length Limit</h3>

<p>The <code>BlockAccessList</code> type uses <code>MAX_BYTES_PER_TRANSACTION</code> (1 GiB). This is an SSZ encoding limit, not an operational limit. Actual BALs are constrained by gas limits to ~megabytes.</p>

<h3>3. No CL Validation of BAL Semantics</h3>

<p>The CL never parses the BAL. It's opaque bytes. Invalid RLP, wrong accounts, missing slots—all caught by the EL, not the CL.</p>

<h3>4. Fork Version Must Match</h3>

<p>Post-EIP-7928, nodes MUST use <code>EIP7928_FORK_VERSION</code>. Mixed versions cause network partitioning.</p>

<h3>5. Header Field Order</h3>

<code>block_access_list_root</code> is the LAST field in <code>ExecutionPayloadHeader</code>. Adding it elsewhere would break SSZ generalized indices.

<hr>

<h2>Summary</h2>

<p>EIP-7928's consensus layer changes are minimal:</p>

<table><tr><th>Component</th><th>Change</th></tr>
<tr><td>Types</td><td>Add <code>BlockAccessList = ByteList[MAX_BYTES_PER_TRANSACTION]</code></td></tr>
<tr><td><code>ExecutionPayload</code></td><td>Add <code>block_access_list: BlockAccessList</code> field</td></tr>
<tr><td><code>ExecutionPayloadHeader</code></td><td>Add <code>block_access_list_root: Root</code> field</td></tr>
<tr><td><code>BeaconState</code></td><td>Indirectly via <code>latest_execution_payload_header</code> type</td></tr>
<tr><td><code>process_execution_payload</code></td><td>Add one line: <code>block_access_list_root=hash_tree_root(...)</code></td></tr>
<tr><td>P2P</td><td>Add <code>EIP7928_FORK_VERSION</code> to <code>compute_fork_version</code></td></tr></table>
The CL is a carrier, not an interpreter. All semantic validation happens in the EL via the Engine API.
</section>

<section id="section-13-networking-and-synchronization">
<h1>Section 13: Networking and Synchronization</h1>

<h2>Source Files</h2>
<ul><li><code>specs/EIPs/EIPS/eip-7928.md</code> (networking-related sections)</li>
<li><code>specs/execution-apis/src/engine/amsterdam.md</code> (Engine API retrieval methods)</li>
</ul>
<h2>Overview</h2>

<p>This section documents how Block-Level Access Lists (BALs) are transmitted across the network. Unlike transactions (eth protocol) or blobs (CL gossip + DAS), BALs follow a unique path: they flow <strong>exclusively through the Engine API</strong> between the Execution Layer and Consensus Layer, with no dedicated peer-to-peer protocol.</p>

<p>This design represents a deliberate architectural choice with significant implications for synchronization, pruning, and the trust model between layers.</p>

<h2>Key Finding: No eth Protocol Extension</h2>

<strong>EIP-7928 does not define an <code>eth/71</code> or any other devp2p protocol for BAL transmission.</strong>

<p>The <code>PROJECT.md</code> reference to EIP-8070 as the "eth/71 Protocol" for BALs is incorrect. EIP-8070 defines eth/71 for the <strong>Sparse Blobpool</strong> feature (custody-aligned blob sampling)—a completely separate proposal unrelated to Block Access Lists.</p>

<h3>What EIP-7928 Actually Specifies</h3>

<p>From the EIP text:</p>

<p>> The <code>BlockAccessList</code> is not included in the block body. The EL stores BALs separately and transmits them as a field in the <code>ExecutionPayload</code> via the engine API.</p>

<p>And:</p>

<p>> Clients MUST store BALs separately from blocks and make them available via the engine API.</p>

<p>This means: <ul><li>BALs are <strong>not part of the RLP-encoded block body</strong> used in eth protocol messages (<code>GetBlockBodies</code>, <code>BlockBodies</code>)</li> <li>BALs are transmitted as part of <code>ExecutionPayload</code> via Engine API</li> <li>Historical BAL retrieval uses dedicated Engine API methods</li> </ul> <h3>Why No Dedicated eth Protocol?</h3></p>

<p>Several factors likely drove this design:</p>

<strong>1. CL Already Coordinates Sync</strong>

<p>Post-merge, the Consensus Layer drives block synchronization. The EL receives blocks through <code>engine_newPayloadVX</code> calls. Adding BAL retrieval to the same flow is natural.</p>

<strong>2. BALs Couple Tightly to Execution</strong>

<p>BALs are <strong>computed output</strong> of block execution, not user-submitted data. They must match exactly what the EL computes. Receiving BALs from untrusted peers would require full re-execution to validate—negating any benefit.</p>

<strong>3. Avoiding Protocol Complexity</strong>

<p>Adding new eth protocol messages requires coordination across all EL clients, protocol negotiation, and backwards compatibility handling. Using the existing Engine API avoids this.</p>

<strong>4. Storage and Pruning Locality</strong>

<p>BALs are used primarily for re-execution optimization and state reconstruction. Keeping them on the EL side (accessible via Engine API) allows EL-specific pruning policies.</p>

<h2>Engine API Methods for BAL Retrieval</h2>

<h3><code>engine_getPayloadBodiesByHashV2</code></h3>

<pre><code class="language-python"># Request
method: engine_getPayloadBodiesByHashV2
params:
  - blockHashes: Array[DATA, 32 Bytes]  # Blocks to retrieve
timeout: 10s

# Response
result: Array[ExecutionPayloadBodyV2 | null]</code></pre>

<strong>Specification (from amsterdam.md lines 104-120):</strong>

<pre><code class="language-markdown">#### Specification

This method follows the same specification as
[`engine_getPayloadBodiesByHashV1`](./shanghai.md#engine_getpayloadbodiesbyhashv1)
with the following additions:

1. Client software **MUST** set the `blockAccessList` field to `null` for
   blocks that predate the Amsterdam fork activation.

2. Client software **MUST** set the `blockAccessList` field to `null` if the
   block access list has been pruned from storage.</code></pre>

<strong>Key semantics:</strong>
<ul><li>Returns <code>null</code> for pre-Amsterdam blocks (backwards compatibility)</li>
<li>Returns <code>null</code> for pruned BALs (allows EL to manage storage)</li>
<li>Timeout of 10 seconds allows batch retrieval</li>
</ul>
<h3><code>engine_getPayloadBodiesByRangeV2</code></h3>

<pre><code class="language-python"># Request
method: engine_getPayloadBodiesByRangeV2
params:
  - start: QUANTITY, 64 Bits   # Starting block number
  - count: QUANTITY, 64 Bits   # Number of blocks
timeout: 10s

# Response
result: Array[ExecutionPayloadBodyV2 | null]</code></pre>

<strong>Specification (from amsterdam.md lines 126-143):</strong>

<pre><code class="language-markdown">#### Specification

This method follows the same specification as
[`engine_getPayloadBodiesByRangeV1`](./shanghai.md#engine_getpayloadbodiesbyrangev1)
with the following additions:

1. Client software **MUST** set the `blockAccessList` field to `null` for
   blocks that predate the Amsterdam fork activation.

2. Client software **MUST** set the `blockAccessList` field to `null` if the
   block access list has been pruned from storage.</code></pre>

<strong>Key semantics:</strong>
<ul><li>Range-based retrieval for efficient batch sync</li>
<li>Same null semantics as hash-based retrieval</li>
<li>Useful for checkpoint sync scenarios</li>
</ul>
<h3><code>ExecutionPayloadBodyV2</code> Structure</h3>

<p>From amsterdam.md lines 33-42:</p>

<pre><code class="language-markdown">### ExecutionPayloadBodyV2

This structure has the syntax of
[`ExecutionPayloadBodyV1`](./shanghai.md#executionpayloadbodyv1) and appends
the new field: `blockAccessList`.

- `transactions`: `Array of DATA` - Array of transaction objects...
- `withdrawals`: `Array of WithdrawalV1` - Array of withdrawals...
- `blockAccessList`: `DATA|null` - RLP-encoded block access list as defined
  in [EIP-7928](https://eips.ethereum.org/EIPS/eip-7928). Value is `null`
  for blocks produced before Amsterdam or if the data has been pruned.</code></pre>

<strong>Design notes:</strong>
<ul><li>BAL is included alongside transactions and withdrawals</li>
<li><code>null</code> serves double duty: pre-fork and pruned states</li>
<li>No separate field for "BAL unavailable but should exist"</li>
</ul>
<h2>Synchronization Flow</h2>

<h3>Block Production (Builder/Proposer)</h3>

<pre><code class="language-text">┌─────────────────────────────────────────────────────────────────────┐
│                        BLOCK PRODUCTION                             │
├─────────────────────────────────────────────────────────────────────┤
│                                                                     │
│  1. CL requests payload build                                       │
│     ┌──────┐  engine_forkchoiceUpdatedV4  ┌──────┐                 │
│     │  CL  │ ────────────────────────────→│  EL  │                 │
│     └──────┘  (payloadAttributes)          └──────┘                 │
│                                               │                     │
│  2. EL builds block, executes txs, collects BAL                    │
│                                               │                     │
│  3. CL retrieves built payload                │                     │
│     ┌──────┐  engine_getPayloadV6           │                      │
│     │  CL  │ ←──────────────────────────────┤                      │
│     └──────┘                                 │                      │
│     Response includes:                       │                      │
│     - ExecutionPayloadV4 (with blockAccessList)                    │
│     - BlobsBundle                                                   │
│     - executionRequests                                             │
│                                                                     │
│  4. CL broadcasts beacon block                                      │
│     - Beacon block includes execution_payload with BAL              │
│     - BAL hash committed in block header                            │
│                                                                     │
└─────────────────────────────────────────────────────────────────────┘</code></pre>

<h3>Block Validation (Attester/Full Node)</h3>

<pre><code class="language-text">┌─────────────────────────────────────────────────────────────────────┐
│                        BLOCK VALIDATION                             │
├─────────────────────────────────────────────────────────────────────┤
│                                                                     │
│  1. CL receives beacon block via gossip                            │
│     - Extracts ExecutionPayload (including blockAccessList)        │
│                                                                     │
│  2. CL sends payload for validation                                │
│     ┌──────┐  engine_newPayloadV5          ┌──────┐                │
│     │  CL  │ ─────────────────────────────→│  EL  │                │
│     └──────┘  (ExecutionPayloadV4)          └──────┘                │
│                                               │                     │
│  3. EL validates:                             │                     │
│     a. Executes transactions                 │                      │
│     b. Computes actual BAL                   │                      │
│     c. Compares with provided blockAccessList│                      │
│     d. Verifies keccak256(BAL) matches header hash                 │
│                                               │                     │
│  4. EL returns validation result              │                     │
│     ┌──────┐  PayloadStatus                  │                      │
│     │  CL  │ ←──────────────────────────────┤                      │
│     └──────┘  (VALID/INVALID)                │                      │
│                                                                     │
│  5. If VALID: EL stores BAL separately                             │
│                                                                     │
└─────────────────────────────────────────────────────────────────────┘</code></pre>

<h3>Historical Sync (Checkpoint Sync / Backfill)</h3>

<pre><code class="language-text">┌─────────────────────────────────────────────────────────────────────┐
│                      HISTORICAL SYNC                                │
├─────────────────────────────────────────────────────────────────────┤
│                                                                     │
│  Scenario: Node syncing from checkpoint, needs historical BALs     │
│                                                                     │
│  1. CL identifies blocks needing BAL data                          │
│                                                                     │
│  2. CL requests from EL (if EL has stored them)                    │
│     ┌──────┐  engine_getPayloadBodiesByRangeV2  ┌──────┐           │
│     │  CL  │ ──────────────────────────────────→│  EL  │           │
│     └──────┘  (start, count)                     └──────┘           │
│                                                    │                │
│  3. EL returns stored BALs (or null if pruned)    │                 │
│                                                    │                │
│  PROBLEM: If EL has pruned BALs, how does CL get them?             │
│                                                                     │
│  Options:                                                           │
│  a. CL fetches from beacon chain archive peers                     │
│     - BALs are part of ExecutionPayload in beacon blocks           │
│  b. EL re-executes blocks to regenerate BALs                       │
│     - Defeats purpose of BALs for sync optimization                │
│  c. Separate archive service                                        │
│     - Not specified in EIP                                          │
│                                                                     │
└─────────────────────────────────────────────────────────────────────┘</code></pre>

<h2>The Sync Gap: EL-to-EL BAL Retrieval</h2>

<h3>The Problem</h3>

<p>Consider these scenarios:</p>

<ul><li><strong>EL-only sync</strong>: An EL client syncing directly from peers (pre-merge style, or execution sync without CL)</li>
<li><strong>EL archive node</strong>: Node that wants full history but CL has pruned old beacon blocks</li>
<li><strong>Cross-EL data sharing</strong>: EL-to-EL requests for specific blocks</li>
</ul>
In all cases, there's no mechanism for an EL to request BALs from another EL peer.

<h3>Why This Might Be Intentional</h3>

<strong>Post-Merge Reality</strong>: EL clients don't sync independently anymore. The CL drives all synchronization. Every EL receives blocks via Engine API from its paired CL.

<strong>Trust Model</strong>: BALs received from untrusted EL peers would need full re-execution to validate. At that point, you've computed the BAL yourself—there's no benefit to receiving it.

<strong>CL as Archive</strong>: Beacon chain already stores the full ExecutionPayload (including BAL). Historical data retrieval can go through CL beacon chain sync.

<h3>What's Missing</h3>

<p>The EIP and Engine API spec don't address:</p>

<ul><li><strong>Pruning coordination</strong>: How does CL know if EL has pruned BALs?</li>
<li><strong>Regeneration policy</strong>: When should EL regenerate BALs vs. signal unavailability?</li>
<li><strong>Archive expectations</strong>: Must archive nodes store BALs indefinitely?</li>
</ul>
<h3>Weak Subjectivity Consideration</h3>

<p>From EIP-7928:</p>

<p>> The EL MUST retain BALs for at least the duration of the weak subjectivity period (<code>=3533 epochs</code>) to support synchronization with re-execution after being offline for less than the WSP.</p>

<p>This defines a minimum retention period (~2 weeks at 12-second slots), but: <ul><li>Doesn't define what happens for older blocks</li> <li>Doesn't specify how nodes sync BALs for the WSP window if they've been offline</li> </ul> <h2>Comparison to Other Data Types</h2></p>

<table><tr><th>Data Type</th><th>Transmission Method</th><th>Peer-to-Peer Protocol</th><th>Trust Model</th></tr>
<tr><td><strong>Transactions</strong></td><td>eth protocol (<code>Transactions</code>, <code>PooledTransactions</code>)</td><td>eth/68+</td><td>Untrusted, mempool validation</td></tr>
<tr><td><strong>Block Headers</strong></td><td>eth protocol (<code>GetBlockHeaders</code>, <code>BlockHeaders</code>)</td><td>eth/68+</td><td>Chain validation</td></tr>
<tr><td><strong>Block Bodies</strong></td><td>eth protocol (<code>GetBlockBodies</code>, <code>BlockBodies</code>)</td><td>eth/68+</td><td>Re-execution validates</td></tr>
<tr><td><strong>Blobs</strong></td><td>CL gossip + DAS</td><td>blob_sidecar_subnet_*</td><td>KZG commitment validation</td></tr>
<tr><td><strong>BALs</strong></td><td>Engine API only</td><td><strong>None</strong></td><td>Re-execution required</td></tr></table>
<strong>BALs are unique</strong>: They're the only execution-related data type without peer-to-peer retrieval.

<h2>Design Implications</h2>

<h3>For Client Implementers</h3>

<ul><li><strong>Storage decisions are local</strong>: EL decides pruning policy; CL queries and handles nulls</li>
<li><strong>Re-execution fallback</strong>: If BAL is unavailable, re-execute to regenerate</li>
<li><strong>No peer discovery needed</strong>: BAL availability doesn't affect peering</li>
</ul>
<h3>For Protocol Designers</h3>

<ul><li><strong>Engine API is the boundary</strong>: All BAL flow crosses EL↔CL via Engine API</li>
<li><strong>CL holds authority</strong>: CL decides when to request BALs, handles unavailability</li>
<li><strong>Future extensions possible</strong>: Could add eth protocol messages later if needed</li>
</ul>
<h3>For Node Operators</h3>

<ul><li><strong>Archive nodes need coordination</strong>: EL and CL archive policies should align</li>
<li><strong>Pruning has consequences</strong>: Pruned BALs require re-execution to regenerate</li>
<li><strong>WSP retention is mandatory</strong>: Must keep BALs for ~2 weeks minimum</li>
</ul>
<h2>Potential Future Extensions</h2>

<p>If EL-to-EL BAL retrieval becomes necessary, possible approaches:</p>

<h3>Option A: eth Protocol Extension</h3>

<pre><code class="language-text"># New messages for hypothetical eth/72

GetBlockAccessLists (0x15)
  [request_id: P, [block_hash_0: B32, block_hash_1: B32, ...]]

BlockAccessLists (0x16)
  [request_id: P, [bal_0: B, bal_1: B, ...]]
  # bal is RLP-encoded BlockAccessList or empty for unavailable</code></pre>

<strong>Pros</strong>: Standard eth protocol pattern, works with existing infrastructure
<strong>Cons</strong>: Requires full re-execution to validate received BALs

<h3>Option B: Portal Network</h3>

<p>Add BAL content type to Portal Network for light client access.</p>

<strong>Pros</strong>: Designed for historical data retrieval
<strong>Cons</strong>: Portal Network adoption, additional infrastructure

<h3>Option C: Accept Current Design</h3>

<p>The current Engine API approach may be sufficient: <ul><li>Post-merge, all sync goes through CL</li> <li>CL beacon chain stores ExecutionPayloads with BALs</li> <li>Re-execution is always possible as fallback</li> </ul> <h2>Summary</h2></p>

<p>EIP-7928 takes a minimalist approach to BAL networking:</p>

<ul><li><strong>No dedicated protocol</strong>: BALs flow through Engine API only</li>
<li><strong>CL coordinates</strong>: Consensus Layer requests BALs via retrieval methods</li>
<li><strong>Storage is EL-local</strong>: EL decides retention, returns null when unavailable</li>
<li><strong>Re-execution fallback</strong>: Always possible to regenerate BALs</li>
<li><strong>Gap acknowledged</strong>: EL-to-EL retrieval not specified, may not be needed</li>
</ul>
This design reflects post-merge reality: the Consensus Layer drives synchronization, and the Engine API is the definitive interface between layers.

<h2>Cross-References</h2>

<ul><li><strong>Section 11: Engine API</strong> — Full specification of all Engine API methods including BAL fields</li>
<li><strong>Section 12: Consensus Layer</strong> — How CL handles ExecutionPayload and BAL validation</li>
<li><strong>Section 08: Block Processing</strong> — BAL validation during <code>process_block</code></li>
<li><strong>Section 01: RLP Types</strong> — BAL encoding format transmitted via Engine API</li>
</ul>
</section>

<section id="section-14-eip-overview">
<h1>Section 14: EIP Overview</h1>

<h2>Source Files</h2>
<ul><li><code>specs/EIPs/EIPS/eip-7928.md</code> (549 lines)</li>
</ul>
<h2>Overview</h2>

<p>This section annotates the canonical EIP-7928 text itself—the authoritative specification from which all implementations derive. While previous sections covered the EELS implementation in detail, this section examines the EIP's design rationale, normative requirements, edge cases, and security considerations.</p>

<p>EIP-7928 is unusually comprehensive for an EIP, spanning both specification and implementation guidance. Understanding the EIP text itself is essential because: <ul><li><strong>It's the source of truth</strong>—implementations must conform to the EIP, not vice versa</li> <li><strong>It explains WHY</strong>—rationale sections capture design decisions that aren't in code</li> <li><strong>It defines the edge cases</strong>—normative behavior for corner cases that might seem arbitrary</li> </ul> <hr></p>

<h2>EIP Metadata (lines 1-12)</h2>

<pre><code class="language-yaml">---
eip: 7928
title: Block-Level Access Lists
description: Enforced block access lists with state locations and post-transaction state diffs
author: Toni Wahrstätter (@nerolation), Dankrad Feist (@dankrad), Francesco D`Amato (@fradamt), 
        Jochem Brouwer (@jochem-brouwer), Ignacio Hagopian (@jsign)
discussions-to: https://ethereum-magicians.org/t/eip-7928-block-level-access-lists/23337
status: Draft
type: Standards Track
category: Core
created: 2025-03-31
---</code></pre>

<strong>Author composition</strong>: The author list reflects the cross-cutting nature of BALs:
<ul><li><strong>Protocol researchers</strong> (Toni, Dankrad, Francesco): Design and rationale</li>
<li><strong>Client developers</strong> (Jochem, Ignacio): Implementation feasibility and edge cases</li>
</ul>
<strong>Category: Core</strong>: This is a consensus-critical change. Every node must compute identical BALs or the network partitions. This elevates the precision requirements beyond typical EIPs.

<hr>

<h2>Abstract (lines 14-17)</h2>

<pre><code class="language-markdown">This EIP introduces Block-Level Access Lists (BALs) that record all accounts and 
storage locations accessed during block execution, along with their post-execution values. 
BALs enable parallel disk reads, parallel transaction validation, parallel state root 
computation and executionless state updates.</code></pre>

<strong>Four capabilities, one data structure</strong>:

<table><tr><th>Capability</th><th>How BAL Enables It</th></tr>
<tr><td>Parallel disk reads</td><td>All accessed addresses known upfront → prefetch simultaneously</td></tr>
<tr><td>Parallel tx validation</td><td>Post-values included → verify tx i without waiting for tx i-1</td></tr>
<tr><td>Parallel state root</td><td>All modified accounts known → hash trie paths concurrently</td></tr>
<tr><td>Executionless state updates</td><td>Diff-only sync: apply changes without replaying EVM</td></tr></table>
<strong>The key insight</strong>: BALs transform block validation from inherently sequential (execute tx 1, then tx 2, ...) to embarrassingly parallel. The cost is ~70KB of additional data per block—a trade-off the EIP argues is worthwhile.

<hr>

<h2>Motivation (lines 19-31)</h2>

<pre><code class="language-markdown">Transaction execution cannot be parallelized without knowing in advance which addresses 
and storage slots will be accessed. While EIP-2930 introduced optional transaction access 
lists, they are not enforced.

This proposal enforces access lists at the block level, enabling:
- Parallel disk reads and transaction execution
- Parallel post-state root calculation
- State reconstruction without executing transactions
- Reduced execution time to `parallel IO + parallel EVM`</code></pre>

<h3>Why EIP-2930 Didn't Solve This</h3>

<a href="https://eips.ethereum.org/EIPS/eip-2930" target="_blank" rel="noopener">EIP-2930</a> introduced <em>optional</em> access lists per transaction. Problems:

<ul><li><strong>Not enforced</strong>: Transactions can access addresses not in their access list</li>
<li><strong>Superset, not exact set</strong>: Lists are hints for gas discounts, not commitments</li>
<li><strong>Per-transaction, not per-block</strong>: Parallel execution still requires knowing cross-tx conflicts</li>
</ul>
BALs differ fundamentally:
<ul><li><strong>Enforced</strong>: Block invalid if BAL doesn't match execution</li>
<li><strong>Exact set</strong>: Every accessed address, nothing more</li>
<li><strong>Post-values included</strong>: Know final state without executing</li>
</ul>
<h3>The Execution Parallelism Problem</h3>

<p>Consider a block with 200 transactions. Traditional execution:</p>

<pre><code class="language-text">T1 → T2 → T3 → ... → T200
     |
     Each must finish before next starts
     (might write what next reads)</code></pre>

<p>With BALs:</p>

<pre><code class="language-text">T1 ─┬── T2 ─┬── T3 ─┬── ... ─┬── T200
    │       │       │        │
    └───────┴───────┴────────┘
    All execute in parallel
    (BAL provides pre/post values)</code></pre>

<p>The BAL tells you: "T47 reads slot X, T89 writes slot X." You can execute them independently because the BAL provides T47's read value and T89's write value.</p>

<hr>

<h2>Block Structure Modification (lines 33-54)</h2>

<pre><code class="language-markdown">We introduce a new field to the block header, `block_access_list_hash`, which contains 
the Keccak-256 hash of the RLP-encoded block access list.</code></pre>

<h3>Why Hash in Header, Data Elsewhere?</h3>

<p>The block header includes <code>block_access_list_hash</code>, not the BAL itself. This mirrors transactions (header has <code>transactions_root</code>, body has transactions).</p>

<strong>Rationale</strong>:
<ul><li><strong>Header stays small</strong>: Headers propagate faster than bodies</li>
<li><strong>Data can be pruned</strong>: Old BALs can be discarded; hash remains for verification</li>
<li><strong>Consistent with Ethereum's data model</strong>: Commitment in header, data in body/payload</li>
</ul>
<h3>Empty Block Handling</h3>

<pre><code class="language-python"># When no state changes present:
block_access_list_hash = keccak256(rlp.encode([]))  # = 0x1dcc4de8dec75d7aab85b567b6ccd41ad312451b948a7413f0a142fd40d49347</code></pre>

<strong>Why <code>keccak256(rlp([]))</code> and not <code>keccak256(b'')</code>?</strong>

<p>The empty hash is <code>0x1dcc4de8...</code> (the RLP empty list hash), not <code>0xc5d2460...</code> (empty bytes hash). This is because: <ul><li>BALs are <em>always</em> RLP-encoded lists, even when empty</li> <li>Consistent encoding → consistent hashing</li> <li>Matches the "empty withdrawals" pattern from EIP-4895</li> </ul> <strong>Cross-reference</strong>: See <a href="08-block-processing.md" target="_blank" rel="noopener">Section 08: Block Processing</a> for <code>make_block_access_list</code> handling of empty blocks.</p>

<hr>

<h2>RLP Data Structures (lines 56-95)</h2>

<p>The EIP defines the type aliases that appear in the EELS implementation:</p>

<pre><code class="language-python"># Type aliases for RLP encoding
Address = bytes20          # 20-byte Ethereum address
StorageKey = uint256       # Storage slot key
StorageValue = uint256     # Storage value
Bytecode = bytes           # Variable-length contract bytecode
BlockAccessIndex = uint16  # 0 = pre-exec, 1..n = txs, n+1 = post-exec
Balance = uint256          # Post-transaction balance in wei
Nonce = uint64             # Account nonce</code></pre>

<h3>BlockAccessIndex Range</h3>

<code>BlockAccessIndex</code> is <code>uint16</code>, supporting up to 65,535 transactions per block. Current Ethereum blocks have at most ~1,500 transactions, leaving headroom for future scaling.

<strong>Why not <code>uint8</code>?</strong> Would limit to 255 transactions—already exceeded by some blocks.

<strong>Why not <code>uint32</code>?</strong> Unnecessary; 16 bits saves 2 bytes per change entry.

<h3>The Core Structures</h3>

<pre><code class="language-python"># StorageChange: [block_access_index, new_value]
StorageChange = [BlockAccessIndex, StorageValue]

# SlotChanges: [slot, [changes]]
SlotChanges = [StorageKey, List[StorageChange]]

# AccountChanges: [address, storage_changes, storage_reads, balance_changes, nonce_changes, code_changes]
AccountChanges = [
    Address,                    # address
    List[SlotChanges],          # storage_changes
    List[StorageKey],           # storage_reads
    List[BalanceChange],        # balance_changes
    List[NonceChange],          # nonce_changes
    List[CodeChange]            # code_changes
]</code></pre>

<strong>Design decision: Why separate storage_changes and storage_reads?</strong>

<p>Storage slots fall into three categories: <ul><li><strong>Written</strong> (value changed): Goes in <code>storage_changes</code></li> <li><strong>Read-only</strong>: Goes in <code>storage_reads</code></li> <li><strong>Written with same value</strong> (no-op write): Goes in <code>storage_reads</code></li> </ul> This separation enables: <ul><li><strong>Smaller diffs</strong>: Reads don't carry values (just keys)</li> <li><strong>Clear semantics</strong>: <code>storage_changes</code> = actual state mutations</li> <li><strong>Parallel execution</strong>: Know which reads can't conflict with writes</li> </ul> <strong>Cross-reference</strong>: See <a href="01-rlp-types.md" target="_blank" rel="noopener">Section 01: RLP Types</a> for the implementation.</p>

<hr>

<h2>Scope and Inclusion (lines 97-124)</h2>

<p>This is the most critical normative section—it defines exactly what MUST appear in the BAL.</p>

<h3>Must Include</h3>

<pre><code class="language-markdown">- Addresses with state changes (storage, balance, nonce, or code).
- Addresses accessed without state changes, including:
  - Targets of BALANCE, EXTCODESIZE, EXTCODECOPY, EXTCODEHASH opcodes
  - Targets of CALL, CALLCODE, DELEGATECALL, STATICCALL (even if they revert)
  - Target addresses of CREATE/CREATE2 if the target account is accessed
  - Transaction sender and recipient addresses (even for zero-value transfers)
  - COINBASE address if the block contains transactions or withdrawals
  - Beneficiary addresses for SELFDESTRUCT
  - System contract addresses accessed during pre/post-execution
  - Withdrawal recipient addresses
  - Precompiled contracts when called or accessed</code></pre>

<h3>Why Include Unchanged Addresses?</h3>

<p>The EIP explicitly requires: "Addresses with no state changes MUST still be present with empty change lists."</p>

<strong>Rationale</strong>: BALs serve two purposes:
<ul><li><strong>State diffs</strong> (what changed) — requires only changed addresses</li>
<li><strong>IO scheduling</strong> (what was accessed) — requires ALL accessed addresses</li>
</ul>
For parallel disk reads, you need to prefetch every address touched, not just those modified. An <code>EXTCODESIZE</code> on address X doesn't change state but still requires reading X's code from disk.

<h3>EIP-2930 Access Lists Are NOT Included</h3>

<pre><code class="language-markdown">Entries from an EIP-2930 access list MUST NOT be included automatically. Only addresses 
and storage slots that are actually touched or changed during execution are recorded.</code></pre>

<p>This is important: EIP-2930 access lists are <em>hints</em> that may be supersets of actual access. BALs are <em>precise</em>—only what was actually accessed.</p>

<strong>Gotcha</strong>: A transaction might include <code>0xABCD</code> in its EIP-2930 access list but never actually touch it. That address must NOT appear in the BAL.

<hr>

<h2>Gas Validation Before State Access (lines 126-170)</h2>

<p>This section specifies when state access occurs—critical for determining BAL inclusion.</p>

<h3>Two-Phase Validation</h3>

<pre><code class="language-markdown">State-accessing opcodes perform gas validation in two phases:
- Pre-state validation: Gas costs determinable without state access
- Post-state validation: Gas costs requiring state access

Pre-state validation MUST pass before any state access occurs.</code></pre>

<strong>Why this matters</strong>: If an opcode fails gas validation, does the target address appear in the BAL?

<p>The answer depends on <em>which</em> validation failed: <ul><li><strong>Pre-state fails</strong>: Target NOT accessed, NOT in BAL</li> <li><strong>Post-state fails</strong>: Target WAS accessed (to compute post-state costs), IS in BAL</li> </ul> <h3>The Validation Table</h3></p>

<pre><code class="language-markdown">| Instruction    | Pre-state Validation                                          |
|----------------|---------------------------------------------------------------|
| BALANCE        | access_cost                                                   |
| CALL           | access_cost + memory_expansion + GAS_CALL_VALUE (if value &gt; 0)|
| SLOAD          | access_cost                                                   |
| SSTORE         | More than GAS_CALL_STIPEND available                          |
| CREATE         | memory_expansion + INITCODE_WORD_COST + GAS_CREATE            |</code></pre>

<strong>SSTORE is special</strong>: The validation is "more than <code>GAS_CALL_STIPEND</code> available", not a specific gas amount. This is the EIP-2200 reentrancy guard.

<strong>Cross-reference</strong>: See <a href="09-vm-integration.md" target="_blank" rel="noopener">Section 09: VM Integration</a> for opcode-level implementation.

<h3>EIP-7702 Delegation Complexity</h3>

<pre><code class="language-markdown">When a call target has an EIP-7702 delegation, the target is accessed to resolve the 
delegation. If a delegation exists, the delegated address requires its own access_cost 
check before being accessed.</code></pre>

<p>This creates a two-hop access pattern:</p>

<pre><code class="language-text">CALL 0xTargetEOA
  │
  ├── Access 0xTargetEOA (to check for delegation)
  │   └── BAL: include 0xTargetEOA
  │
  └── If delegated to 0xDelegatedContract:
      ├── Check access_cost for 0xDelegatedContract
      │   ├── If passes: Access and include in BAL
      │   └── If fails: Do NOT include in BAL</code></pre>

<p>The original target is always included (it was accessed to resolve delegation). The delegated address is only included if its access_cost check passes.</p>

<hr>

<h2>Ordering and Determinism (lines 172-182)</h2>

<pre><code class="language-markdown">The following ordering rules MUST apply:
- Accounts: Lexicographic by address
- storage_changes: Slots lexicographic by storage key; within each slot, changes by block access index
- storage_reads: Lexicographic by storage key
- balance_changes, nonce_changes, code_changes: By block access index (ascending)</code></pre>

<h3>Why Strict Ordering?</h3>

<p>BALs are consensus-critical. Two clients processing the same block must produce identical BALs. Without deterministic ordering, semantically equivalent BALs could have different encodings → different hashes → consensus failure.</p>

<strong>Lexicographic ordering</strong> was chosen because:
<ul><li><strong>Simple</strong>: Sort bytes numerically (big-endian)</li>
<li><strong>Deterministic</strong>: No locale or implementation dependencies</li>
<li><strong>Efficient</strong>: Single-pass sorting with standard comparators</li>
</ul>
<strong>Cross-reference</strong>: See <a href="07-builder-finalization.md" target="_blank" rel="noopener">Section 07: Builder Finalization</a> for the sorting implementation.

<hr>

<h2>BlockAccessIndex Assignment (lines 184-192)</h2>

<pre><code class="language-markdown">BlockAccessIndex values MUST be assigned as follows:
- 0 for pre-execution system contract calls
- 1 ... n for transactions (in block order)
- n + 1 for post-execution system contract calls</code></pre>

<h3>The Three Phases</h3>

<table><tr><th>Index</th><th>Phase</th><th>Examples</th></tr>
<tr><td>0</td><td>Pre-execution</td><td>EIP-2935 (store parent hash), EIP-4788 (store beacon root)</td></tr>
<tr><td>1..n</td><td>Transactions</td><td>User transactions in block order</td></tr>
<tr><td>n+1</td><td>Post-execution</td><td>EIP-4895 (withdrawals), EIP-7002/7251 (validator operations)</td></tr></table>
<strong>Why separate indices for system calls?</strong>

<p>System calls are not transactions but do modify state. Separating them: <ul><li>Allows validators to verify pre/post system state independently</li> <li>Enables clear attribution of state changes</li> <li>Matches the execution phases in <code>process_block</code></li> </ul> <strong>Gotcha</strong>: Index 0 is pre-execution, NOT "first transaction." A block with 3 transactions uses indices 0, 1, 2, 3, 4 (not 1, 2, 3).</p>

<hr>

<h2>Recording Semantics (lines 194-238)</h2>

<h3>Storage Write vs Read Classification</h3>

<pre><code class="language-markdown">- Writes include:
  - Any value change (post-value ≠ pre-value)
  - Zeroing a slot (pre-value exists, post-value is zero)

- Reads include:
  - Slots accessed via SLOAD that are not written
  - Slots written with unchanged values (no-op writes)</code></pre>

<strong>The no-op write rule</strong>: If you <code>SSTORE</code> the same value that was already there, it's recorded as a <em>read</em>, not a write.

<strong>Why?</strong> Post-execution values in <code>storage_changes</code> are for state reconstruction. If a slot's value didn't change, including it in <code>storage_changes</code> would be misleading—the diff-only sync path would see a "change" that isn't.

<strong>Implementation check</strong>: See <a href="04-state-tracker-recording.md" target="_blank" rel="noopener">Section 04: State Tracker Recording</a> for how <code>record_storage_write</code> handles this.

<h3>Balance Recording Rules</h3>

<pre><code class="language-markdown">If an account's balance changes during a transaction, but its post-transaction balance 
is equal to its pre-transaction balance, then the change MUST NOT be recorded.</code></pre>

<p>This is the "net-zero filter" for balances. Example:</p>

<pre><code class="language-text">1. Alice sends 1 ETH to Bob  (Alice: -1 ETH)
2. Bob sends 1 ETH to Alice  (Alice: +1 ETH)
Result: Alice's balance unchanged, no balance_change recorded</code></pre>

<strong>But the address must be included</strong>: Even with no balance_change, Alice appears in the BAL because she was <em>accessed</em>. She just has an empty <code>balance_changes</code> list.

<hr>

<h2>Edge Cases (lines 240-310)</h2>

<p>The EIP specifies behavior for numerous edge cases. These are normative—implementations must handle them exactly as described.</p>

<h3>COINBASE / Fee Recipient</h3>

<pre><code class="language-markdown">The COINBASE address MUST be included if it experiences any state change. It MUST NOT 
be included for blocks with no transactions, provided there are no other state changes. 
If the COINBASE reward is zero, the COINBASE address MUST be included as a read.</code></pre>

<p>Three scenarios:</p>

<table><tr><th>Scenario</th><th>COINBASE in BAL?</th><th>balance_change?</th></tr>
<tr><td>Block has transactions, non-zero reward</td><td>Yes</td><td>Yes</td></tr>
<tr><td>Block has transactions, zero reward</td><td>Yes</td><td>No (read-only)</td></tr>
<tr><td>Empty block, no withdrawals</td><td>No</td><td>N/A</td></tr></table>
<h3>SELFDESTRUCT (In-Transaction)</h3>

<pre><code class="language-markdown">Accounts destroyed within a transaction MUST be included in AccountChanges without 
nonce or code changes. However, if the account had a positive balance pre-transaction, 
the balance change to zero MUST be recorded.</code></pre>

<strong>Why no nonce/code changes?</strong> The account is destroyed—there's no "post" state for nonce/code. But the balance going to zero IS a state change that must be recorded.

<strong>Storage handling</strong>: "Storage keys within the self-destructed contracts that were modified or read MUST be included as a <code>storage_reads</code> entry."

<p>After SELFDESTRUCT, all storage is considered read-only (you can't write to a dead contract). Any keys that <em>were</em> modified before destruction go to <code>storage_reads</code> because the final state is "gone" (conceptually zero/empty).</p>

<h3>System Contract Storage Diffs</h3>

<pre><code class="language-markdown">- EIP-2935 (block hash): Record single updated storage slot in ring buffer
- EIP-4788 (beacon root): Record two updated storage slots in ring buffer
- EIP-7002 (withdrawals): Record storage slots 0-3 after dequeuing
- EIP-7251 (consolidations): Record storage slots 0-3 after dequeuing</code></pre>

<p>These are explicit: system contracts have specific storage layouts, and the BAL must capture exactly those slots.</p>

<strong>Why enumerate?</strong> Implementers might otherwise miss system contract state changes that happen outside normal transaction execution.

<hr>

<h2>Engine API Section (lines 312-370)</h2>

<pre><code class="language-markdown">ExecutionPayloadV4 extends ExecutionPayloadV3 with:
- blockAccessList: RLP-encoded block access list

engine_newPayloadV5 validates execution payloads:
- Accepts ExecutionPayloadV4 structure
- Validates that computed access list matches provided blockAccessList
- Returns INVALID if access list is malformed or doesn't match</code></pre>

<h3>The Validation Flow</h3>

<pre><code class="language-text">CL → engine_newPayloadV5(payload with BAL)
       │
       ├── EL computes block_access_list_hash = keccak256(payload.blockAccessList)
       ├── EL sets header.block_access_list_hash = computed_hash
       ├── EL executes block, generates actual_BAL
       └── EL compares: RLP(actual_BAL) == payload.blockAccessList?
             │
             ├── Match: VALID
             └── Mismatch: INVALID</code></pre>

<strong>Critical</strong>: The EL doesn't just hash and compare—it re-executes and regenerates the BAL. This ensures the BAL actually represents the block's execution.

<h3>Retrieval Methods</h3>

<pre><code class="language-markdown">engine_getPayloadBodiesByHashV2: Returns ExecutionPayloadBodyV2 objects containing 
transactions, withdrawals, and blockAccessList</code></pre>

<strong>Purpose</strong>: Historical BAL retrieval for:
<ul><li>Syncing nodes that missed recent blocks</li>
<li>Rebuilding state without re-execution</li>
<li>Archive queries</li>
</ul>
<strong>Retention requirement</strong>: "The EL MUST retain BALs for at least the duration of the weak subjectivity period (~3533 epochs)"

<p>This is ~15 days. After that, nodes can prune BALs and require full re-execution for sync.</p>

<strong>Cross-reference</strong>: See <a href="11-engine-api.md" target="_blank" rel="noopener">Section 11: Engine API</a> for method signatures.

<hr>

<h2>State Transition Function (lines 372-450)</h2>

<p>The EIP provides pseudocode for the complete validation flow:</p>

<pre><code class="language-python">def validate_block(execution_payload, block_header):
    # 1. Set hash in header
    block_header.block_access_list_hash = keccak(execution_payload.blockAccessList)
    
    # 2. Execute and collect
    actual_bal = execute_and_collect_accesses(execution_payload)
    
    # 3. Verify match
    assert rlp.encode(actual_bal) == execution_payload.blockAccessList</code></pre>

<h3>The Collection Process</h3>

<pre><code class="language-python">def execute_and_collect_accesses(block):
    accesses = {}
    
    # Pre-execution (index = 0)
    track_system_contracts_pre(block, accesses, block_access_index=0)
    
    # Transactions (index = 1..n)
    for i, tx in enumerate(block.transactions):
        execute_transaction(tx)
        track_state_changes(tx, accesses, block_access_index=i+1)
    
    # Post-execution (index = n+1)
    post_index = len(block.transactions) + 1
    for withdrawal in block.withdrawals:
        apply_withdrawal(withdrawal)
        track_balance_change(withdrawal.address, accesses, post_index)
    track_system_contracts_post(block, accesses, post_index)
    
    return build_bal(accesses)</code></pre>

<p>This pseudocode maps directly to the EELS implementation: <ul><li><code>track_system_contracts_pre</code> → <code>process_pre_block</code> in <code>blocks.py</code></li> <li><code>execute_transaction</code> → <code>process_transaction</code> in <code>fork.py</code></li> <li><code>track_state_changes</code> → <code>StateTracker</code> hooks</li> <li><code>build_bal</code> → <code>make_block_access_list</code> in <code>builder.py</code></li> </ul> <strong>Cross-reference</strong>: See <a href="08-block-processing.md" target="_blank" rel="noopener">Section 08: Block Processing</a> for the implementation.</p>

<hr>

<h2>Concrete Example (lines 452-520)</h2>

<p>The EIP provides a detailed example block. Key observations:</p>

<h3>Example Structure</h3>

<pre><code class="language-text">Pre-execution:
  - EIP-2935: Store parent hash (block_access_index = 0)

Transactions:
  1. Alice → Bob (1 ETH) + BALANCE check (block_access_index = 1)
  2. Charlie deploys via factory (block_access_index = 2)

Post-execution:
  - Withdrawal to Eve (block_access_index = 3)</code></pre>

<h3>The Resulting BAL</h3>

<pre><code class="language-python">[
    # 0x0000F908... (Block hash contract) - storage write at index 0
    [0x0000F908..., [[slot, [[0, parent_hash]]]], [], [], [], []],
    
    # 0x2222... (checked by BALANCE) - accessed but unchanged
    [0x2222..., [], [], [], [], []],
    
    # 0xaaaa... (Alice) - balance and nonce change at index 1
    [0xaaaa..., [], [], [[1, post_balance]], [[1, 10]], []],
    
    # ... sorted lexicographically by address ...
]</code></pre>

<strong>Observations</strong>:
<ul><li>Addresses sorted lexicographically (0x0000... < 0x2222... < 0xaaaa...)</li>
<li>Accessed-but-unchanged addresses included with empty lists</li>
<li>Each change tagged with its block_access_index</li>
</ul>
<hr>

<h2>Rationale Section (lines 522-560)</h2>

<h3>Why Include All Accessed Addresses?</h3>

<pre><code class="language-markdown">Size vs parallelization: BALs include all accessed addresses (even unchanged) 
for complete parallel IO and execution.</code></pre>

<p>Trade-off: Larger BALs (~70KB average) vs. complete prefetch capability.</p>

<h3>Why Post-Values?</h3>

<pre><code class="language-markdown">Storage values for writes: Post-execution values enable state reconstruction 
during sync without individual proofs against state root.</code></pre>

<p>Alternative considered: Include only address+slot, require proofs for values. Rejected because: <ul><li>Proofs are expensive (~1KB per value)</li> <li>Would prevent diff-only sync</li> <li>Adds verification complexity</li> </ul> <h3>RLP vs SSZ</h3></p>

<pre><code class="language-markdown">RLP encoding: Native Ethereum encoding format, maintains compatibility with 
existing infrastructure.</code></pre>

<p>SSZ was considered for CL compatibility. RLP chosen because: <ul><li>EL natively uses RLP</li> <li>Engine API already bridges EL↔CL serialization</li> <li>No SSZ dependency in EL</li> </ul> <hr></p>

<h2>Size Analysis (lines 562-590)</h2>

<pre><code class="language-markdown">Average BAL size: ~72.4 KiB (compressed)

- Storage writes: ~29.2 KiB (40.3%)
- Storage reads: ~18.7 KiB (25.8%)
- Balance diffs: ~6.7 KiB (9.2%)
- Nonce diffs: ~1.1 KiB (1.5%)
- Code diffs: ~1.2 KiB (1.6%)
- Account addresses: ~7.7 KiB (10.7%)
- Touched-only addresses: ~3.5 KiB (4.8%)
- RLP overhead: ~4.4 KiB (6.1%)</code></pre>

<h3>Composition Analysis</h3>

<table><tr><th>Component</th><th>% of BAL</th><th>Why This Size?</th></tr>
<tr><td>Storage writes</td><td>40%</td><td>Full 32-byte values, 32-byte keys</td></tr>
<tr><td>Storage reads</td><td>26%</td><td>Keys only, no values</td></tr>
<tr><td>Balance diffs</td><td>9%</td><td>~300 balance changes per block</td></tr>
<tr><td>Addresses</td><td>15%</td><td>~1000 unique addresses per block</td></tr></table>
<strong>Key insight</strong>: Storage dominates. Optimizations should focus on storage encoding.

<h3>Compared to Current Block Sizes</h3>

<p>~70KB average is smaller than current worst-case calldata blocks (~128KB). Network overhead is manageable.</p>

<hr>

<h2>Security Considerations (lines 592-610)</h2>

<h3>Validation Overhead</h3>

<pre><code class="language-markdown">Validating access lists and balance diffs adds validation overhead but is essential 
to prevent acceptance of invalid blocks.</code></pre>

<strong>Attack vector</strong>: Without validation, an attacker could include a malformed BAL that passes hash check but misrepresents state changes.

<strong>Mitigation</strong>: Full re-execution and BAL regeneration. Every validating node does this.

<h3>Block Size Impact</h3>

<pre><code class="language-markdown">Increased block size impacts propagation but overhead (~70 KiB average) is 
reasonable for performance gains.</code></pre>

<strong>Trade-off analysis</strong>:
<ul><li>70KB additional per block</li>
<li>At 12s block time: ~6KB/s additional bandwidth</li>
<li>Benefit: Potential 10x parallelization of execution</li>
</ul>
The ratio favors inclusion.

<hr>

<h2>Backwards Compatibility (lines 612-618)</h2>

<pre><code class="language-markdown">This proposal requires changes to the block structure and engine API that are 
not backwards compatible and require a hard fork.</code></pre>

<p>Breaking changes: <ul><li><strong>Block header</strong>: New <code>block_access_list_hash</code> field</li> <li><strong>Engine API</strong>: V5 methods with new payload format</li> <li><strong>ExecutionPayload</strong>: New <code>blockAccessList</code> field</li> <li><strong>Validation logic</strong>: New verification step</li> </ul> No path exists for gradual rollout—all nodes must upgrade simultaneously at the fork block.</p>

<hr>

<h2>Cross-Reference Summary</h2>

<p>This EIP defines the specification that other sections implement:</p>

<table><tr><th>EIP Section</th><th>Implementation</th></tr>
<tr><td>RLP Data Structures</td><td><a href="01-rlp-types.md" target="_blank" rel="noopener">Section 01: RLP Types</a></td></tr>
<tr><td>Scope and Inclusion</td><td><a href="04-state-tracker-recording.md" target="_blank" rel="noopener">Section 04: State Tracker Recording</a></td></tr>
<tr><td>Ordering</td><td><a href="07-builder-finalization.md" target="_blank" rel="noopener">Section 07: Builder Finalization</a></td></tr>
<tr><td>Recording Semantics</td><td><a href="04-state-tracker-recording.md" target="_blank" rel="noopener">Section 04</a>, <a href="06-builder-construction.md" target="_blank" rel="noopener">Section 06</a></td></tr>
<tr><td>Gas Validation</td><td><a href="09-vm-integration.md" target="_blank" rel="noopener">Section 09: VM Integration</a></td></tr>
<tr><td>Engine API</td><td><a href="11-engine-api.md" target="_blank" rel="noopener">Section 11: Engine API</a></td></tr>
<tr><td>Block Processing</td><td><a href="08-block-processing.md" target="_blank" rel="noopener">Section 08: Block Processing</a></td></tr>
<tr><td>CL Integration</td><td><a href="12-consensus-layer.md" target="_blank" rel="noopener">Section 12: Consensus Layer</a></td></tr></table>
<hr>

<h2>Design Decisions and Alternatives</h2>

<h3>What Could Have Been Different</h3>

<table><tr><th>Choice Made</th><th>Alternative Considered</th><th>Why This Choice?</th></tr>
<tr><td>Block-level, not tx-level</td><td>Per-tx access lists</td><td>Block-level captures cross-tx dependencies</td></tr>
<tr><td>RLP encoding</td><td>SSZ encoding</td><td>Native EL format, no new dependencies</td></tr>
<tr><td>Post-values included</td><td>Only addresses/slots</td><td>Enables diff-only sync</td></tr>
<tr><td>Include unchanged addresses</td><td>Only changed addresses</td><td>Enables complete parallel IO</td></tr>
<tr><td>Lexicographic ordering</td><td>Insertion order</td><td>Deterministic across implementations</td></tr>
<tr><td>Hash in header, data in payload</td><td>Full BAL in header</td><td>Keeps header small</td></tr></table>
<h3>Open Questions</h3>

<ul><li><strong>Pruning policy</strong>: 3533 epochs is the minimum; should clients keep longer?</li>
<li><strong>Compression</strong>: RLP is uncompressed; should the spec define compression?</li>
<li><strong>Streaming validation</strong>: Can BAL validation happen during execution rather than after?</li>
</ul>
<hr>

<h2>Conclusion</h2>

<p>EIP-7928 is a comprehensive specification that enables fundamental changes to how Ethereum processes blocks. By committing to complete access information upfront, it transforms block validation from inherently sequential to embarrassingly parallel.</p>

<p>The ~70KB overhead per block is a conscious trade-off for: <ul><li>10x+ potential speedup in block validation</li> <li>Diff-only state sync without re-execution</li> <li>Parallel state root computation</li> <li>Foundation for future statelessness work</li> </ul> The specification is precise, the edge cases are enumerated, and the implementation in EELS demonstrates feasibility. What remains is client adoption and real-world performance validation.</p>
</section>
    </main>
  </div>
  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/python.min.js"></script>
  <script>
    // Syntax highlighting
    hljs.highlightAll();
    
    // Active nav tracking
    const sections = document.querySelectorAll('section');
    const navItems = document.querySelectorAll('.nav-item');
    
    const observer = new IntersectionObserver(entries => {
      entries.forEach(entry => {
        if (entry.isIntersecting) {
          const id = entry.target.id;
          navItems.forEach(item => {
            item.classList.toggle('active', item.getAttribute('href') === '#' + id);
          });
        }
      });
    }, { rootMargin: '-20% 0px -70% 0px' });
    
    sections.forEach(section => observer.observe(section));
    
    // Smooth scroll on nav click
    navItems.forEach(item => {
      item.addEventListener('click', e => {
        e.preventDefault();
        const target = document.querySelector(item.getAttribute('href'));
        if (target) {
          target.scrollIntoView({ behavior: 'smooth', block: 'start' });
          history.pushState(null, null, item.getAttribute('href'));
        }
      });
    });
  </script>
</body>
</html>